
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="msvalidate.01" content="A77181372F70D1DC2CC14CE5A5074DD4" />
  <meta name="google-site-verification" content="z-Pc5j8ZOiRrGa5d5_40zI-7Ub0Abh4AWPgidECbJ9c" />
  <title>C++ Constructors and Memory Leaks - J@ArangoDB</title>
  <meta name="author" content="jsteemann">

  
  <meta name="description" content="Preventing leaks in throwing constructors The easiest way to prevent memory leaks is to create all objects on
the stack and not using dynamic memory &hellip;">
  <meta name="keywords" content="c++">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jsteemann.github.io/blog/2015/11/18/on-exception-handling">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="J@ArangoDB" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<script src="/javascripts/monthly_archive.js"></script>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-53854700-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">J@ArangoDB</a></h1>
  
    <h2>{ "subject" : "ArangoDB", "tags": [ "multi-model", "nosql", "database" ] }</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jsteemann.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">C++ Constructors and Memory Leaks</h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-11-18T01:10:51+01:00" pubdate data-updated="true">Nov 18<span>th</span>, 2015</time>
        
      </p>
    
  </header>


<div class="entry-content"><h2>Preventing leaks in throwing constructors</h2>

<p>The easiest way to prevent memory leaks is to create all objects on
the stack and not using dynamic memory at all. However, often this is not
possible, for example because stack size is limited or objects need to
outlive the caller&rsquo;s scope.</p>

<p>Another way to prevent memory leaks and leaks of other resources is
obviously to employ the RAII pattern. How can it be used safely and
easily in practice, so memory leaks can be avoided?</p>

<p>This post will start with a few seemingly working but subtly ill-formed
techniques that a few common pitfalls. Later on it will provide a few
very simple solutions for getting it right.</p>

<!--more -->


<p>None of the solutions here are new or original.</p>

<p>I took some inspiration from the excellent <a href="http://gotw.ca/gotw/066.htm">constructor failures GotW post</a>.
That doesn&rsquo;t cover smart pointers and is not explicitly about preventing
preventing memory leak, so I put together this overview myself.</p>

<h2>Naive implementation</h2>

<p>Let&rsquo;s pretend we have a simple test program <code>main.cpp</code>, which
creates an object of class <em>MyClass</em> on the stack like this:</p>

<figure class='code'><figcaption><span>main.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &quot;MyClass.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">MyClass</span> <span class="n">myClass</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;NO EXCEPTION&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CAUGHT EXCEPTION&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The above code creates the <em>myClass</em> instance on the stack, so
itself will not leak any memory. When the creating of the <em>myClass</em>
instance fails for whatever reason, the instance newer existed so
the memory for holding a <em>MyClass</em> object will be freed automatically.
If object creation succeeds and the object goes out of scope at the
end of the <em>try</em> block, then the object&rsquo;s destructor will be called
and resources can be freed, too.</p>

<p>Obviously this is already good, so let&rsquo;s keep it as it is and have a
look at the implementation of <em>MyClass</em> now. This class will manage
two heap objects of type <em>A</em>, which are created using the helper
function <em>createInstance</em>:</p>

<figure class='code'><figcaption><span>MyClass.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &quot;A.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">MyClass</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">A</span><span class="o">*</span> <span class="n">a1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">A</span><span class="o">*</span> <span class="n">a2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">MyClass</span> <span class="p">()</span>
</span><span class='line'>    <span class="o">:</span> <span class="n">a1</span><span class="p">(</span><span class="n">createInstance</span><span class="p">()),</span>
</span><span class='line'>      <span class="n">a2</span><span class="p">(</span><span class="n">createInstance</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CTOR MYCLASS&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">~</span><span class="n">MyClass</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;DTOR MYCLASS&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">delete</span> <span class="n">a1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">delete</span> <span class="n">a2</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>For completeness, here is class <em>A</em>. It won&rsquo;t manage any resources
itself:</p>

<figure class='code'><figcaption><span>A.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">A</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CTOR A&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="o">~</span><span class="n">A</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;DTOR A&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// helper method for creating an instance of A</span>
</span><span class='line'><span class="n">A</span><span class="o">*</span> <span class="n">createInstance</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">shouldThrow</span> <span class="o">=</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">shouldThrow</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">throw</span> <span class="s">&quot;THROWING AN EXCEPTION&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">new</span> <span class="n">A</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>During this complete post, the code of <em>A.h</em> will remain unchanged.</p>

<p>Compiling and running the initial version of <code>main.cpp</code> will produce the
following output:</p>

<figure class='code'><figcaption><span>output of naive implementation</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CTOR A
</span><span class='line'>CTOR A
</span><span class='line'>CTOR MYCLASS
</span><span class='line'>NO EXCEPTION
</span><span class='line'>DTOR MYCLASS
</span><span class='line'>DTOR A
</span><span class='line'>DTOR A</span></code></pre></td></tr></table></div></figure>


<p>Valgrind also reports no memory leaks. Are we done already?</p>

<h2>Introducing exceptions</h2>

<p>No, because everything still went well. Let&rsquo;s introduce exceptions into
the picture and check what happens then.</p>

<p>Let&rsquo;s first introduce an exception in the constructor of <em>MyClass</em>.
We&rsquo;ll make the <em>createInstance</em> function throw on second invocation (we do
this by passing a value of <em>true</em> to it):</p>

<figure class='code'><figcaption><span>constructor throwing an exception</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">MyClass</span> <span class="p">()</span>
</span><span class='line'>  <span class="o">:</span> <span class="n">a1</span><span class="p">(</span><span class="n">createInstance</span><span class="p">()),</span>
</span><span class='line'>    <span class="n">a2</span><span class="p">(</span><span class="n">createInstance</span><span class="p">(</span><span class="kc">true</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CTOR MYCLASS&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Running the program will now emit the following:</p>

<figure class='code'><figcaption><span>output of naive implementation, with exception</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CTOR A
</span><span class='line'>CAUGHT EXCEPTION</span></code></pre></td></tr></table></div></figure>


<p>As we&rsquo;re throwing in the initializer list already, we don&rsquo;t even
reach the constructor body. This is no problem, but worse is that the
destructor for class <em>MyClass</em> is not being called at all.
Valgrind therefore reports the memory for first <em>A</em> instance as leaked.</p>

<p>By the way, the destructor for the <em>MyClass</em> instance is intentionally
not being called as the object hasn&rsquo;t been fully constructed and logically
never existed.</p>

<p>Will it help if we move the heap allocations from the initializer list
into the constructor body like this?</p>

<figure class='code'><figcaption><span>using the constructor body instead of the initializer list</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">MyClass</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CTOR MYCLASS&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">a1</span> <span class="o">=</span> <span class="n">createInstance</span><span class="p">();</span>
</span><span class='line'>  <span class="n">a2</span> <span class="o">=</span> <span class="n">createInstance</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Unfortunately not. Still no destructor invocations:</p>

<figure class='code'><figcaption><span>output of constructor body variant</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CTOR MYCLASS
</span><span class='line'>CTOR A
</span><span class='line'>CAUGHT EXCEPTION</span></code></pre></td></tr></table></div></figure>


<p>Remember: an object&rsquo;s destructor won&rsquo;t be called if its constructor threw
and the exception wasn&rsquo;t caught. That also means releasing an object&rsquo;s
resources solely via the destructor as in implementation above will not be
sufficient if resources are allocated in the constructor and the constructor
can throw.</p>

<p>What can be done about that?</p>

<p>Obviously all resource allocations can be moved into the constructor body so
exceptions can be caught there:</p>

<figure class='code'><figcaption><span>catching exceptions in constructor of MyClass</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">MyClass</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CTOR MYCLASS&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">a1</span> <span class="o">=</span> <span class="n">createInstance</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">a2</span> <span class="o">=</span> <span class="n">createInstance</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// must clean up a1 to prevent a leak</span>
</span><span class='line'>    <span class="k">delete</span> <span class="n">a1</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// and re-throw the exception</span>
</span><span class='line'>    <span class="k">throw</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>While the above will work, it&rsquo;s clumsy, verbose and error-prone. If
more objects need to be managed this will make us end up in deeply
nested try&hellip;catch blocks.</p>

<h2>try&hellip;catch for the initializer list</h2>

<p>But wait, wasn&rsquo;t there a try&hellip;catch feature especially for initializer
list code? Sounds like it could be useful. Maybe we can use this instead
so we can catch exceptions during initialization?</p>

<p>There is indeed something like that: exceptions thrown from the initializer
list  can be caught using the following special syntax:</p>

<figure class='code'><figcaption><span>catching exceptions thrown in the initializer list</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">MyClass</span> <span class="p">()</span>
</span><span class='line'>  <span class="k">try</span> <span class="o">:</span> <span class="n">a1</span><span class="p">(</span><span class="n">createInstance</span><span class="p">()),</span>
</span><span class='line'>        <span class="n">a2</span><span class="p">(</span><span class="n">createInstance</span><span class="p">(</span><span class="kc">true</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CTOR MYCLASS&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>  <span class="c1">// catch block for initializer list code</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CATCH BLOCK MYCLASS&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">delete</span> <span class="n">a1</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Running the program with the above <em>MyClass</em> constructor will also
do what is expected: when creating the second <em>A</em> instance, the
initializer list code will throw, invoking its catch block. Again
code execution won&rsquo;t make it into the constructor body, and we don&rsquo;t
see the destructor code in action.</p>

<p>The output of the program is:</p>

<figure class='code'><figcaption><span>output of initializer list variant </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CTOR A
</span><span class='line'>CATCH BLOCK MYCLASS
</span><span class='line'>DTOR A
</span><span class='line'>CAUGHT EXCEPTION</span></code></pre></td></tr></table></div></figure>


<p>Valgrind does not report a leak, so are we done now?</p>

<p>No, as the above code has a severe problem. It worked only
because we knew the second invocation of <em>createInstance</em> would fail.</p>

<p>But in the general case, either the first call or the second call
can fail. If the first call fails, then the initializer hasn&rsquo;t
initialized any of the object&rsquo;s members, and it would be unsafe to
delete any object members in the initializer&rsquo;s catch block. If the
second <em>createInstance</em> call fails, then the initializer has created
<em>a1</em> but not <em>a2</em>. To prevent a leak in this case, we should delete <em>a1</em>,
but we better don&rsquo;t delete <em>a2</em> yet.</p>

<p>But how do we tell in the catch block at what stage the initializer
list had thrown? There is no natural way to do this correctly without
introducing more state. And without that, we have the choice between
undefined behavior when deleting the not-yet-initialized object
members, and memory leaks when ignoring them.</p>

<h2>Not using pointers at all</h2>

<p>Note that if we wouldn&rsquo;t have used pointers for our managed <em>A</em> objects,
then we could have used the fact that destructors for all initialized
object members <strong>are</strong> actually called when object construction fails.</p>

<p>However, simple pointers don&rsquo;t have a destructor, so the objects they
point to remain and the memory is lost.</p>

<p>So one obvious solution for preventing memory leaks is to not use pointers,
and get rid of all <code>new</code> and <code>delete</code> statements.</p>

<p>In some situations we can probably get away with making the managed objects
regular class members of the class that manages them:</p>

<figure class='code'><figcaption><span>not using pointers</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">MyClass</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">A</span> <span class="n">a1</span><span class="p">;</span> <span class="c1">// no pointer anymore!</span>
</span><span class='line'>  <span class="n">A</span> <span class="n">a2</span><span class="p">;</span> <span class="c1">// no pointer anymore!</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">MyClass</span> <span class="p">()</span>
</span><span class='line'>    <span class="o">:</span> <span class="n">a1</span><span class="p">(),</span>
</span><span class='line'>      <span class="n">a2</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CTOR MYCLASS&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">~</span><span class="n">MyClass</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;DTOR MYCLASS&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// no delete statements needed anymore!</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now if any of the <em>A</em> constructors will throw an exception during
initialization, everything will be cleaned up properly. Now we can make
use of the destructor of <em>A</em>. If <em>A</em> instances are not pointers but
regular objects, the destructors for already created instances will
be called normally, and no destructors will be called for the not-yet-initialized
<em>A</em> instances. That&rsquo;s how it should be. We don&rsquo;t get this benefit with
regular pointers, which don&rsquo;t have a destructor.</p>

<p>As an aside, we got rid of the <code>delete</code> statements in the destructor
and may even get away with the default destructor.</p>

<p>Obviously this is an easy and safe solution, but it also has a few
downsides. Here are a few (incomplete list):</p>

<ul>
<li>when compiling <em>MyClass</em>, the compiler will now need to know the
definition for class <em>A</em>. You can&rsquo;t get away with a simple forward
declaration for class <em>A</em> anymore as in the case when the class
only contained pointers to <em>A</em>.
So this solution increases the source code dependencies and coupling.</li>
<li>instances of managed objects (e.g. <em>A</em>) will need to be created when
the managing object (e.g. <em>MyClass</em>) is created. There is no way to
postpone the object creation as in the case of when using pointers.</li>
<li>in general, the lifetime of the managed objects is tied to the lifetime
of the managing object. This may or may not be ok, depending on
requirements.</li>
</ul>


<h2>Using smart pointers (e.g. std::unique_ptr)</h2>

<p>In many cases the superior alternative to all the above is using one
of the available smart pointer classes for managing resources.</p>

<p>The promise of smart pointers is that resource management becomes easier,
safer and more flexible with them.</p>

<p>Really useful smart pointers (this excludes <code>std::auto_ptr</code>) are part
of standard C++ since C++11, and to my knowledge they can be used in
all C++11-compatible compilers and even in some older ones. Apart from
that, smart pointers are available in Boost for a long time already.</p>

<p>In the following snippets, I&rsquo;ll be using smart pointers of type
<code>std::unique_ptr</code> as it is the perfect fit for this particular problem.
I won&rsquo;t cover <code>shared_ptr</code>, <code>weak_ptr</code> or other types of smart pointers
here.</p>

<p>When using an <code>std::unique_ptr</code> for managing the resources of <em>MyClass</em>,
the <em>MyClass</em> code becomes:</p>

<figure class='code'><figcaption><span>using std::unique_ptr</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;memory&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">MyClass</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">a1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">MyClass</span> <span class="p">()</span> <span class="o">:</span>
</span><span class='line'>    <span class="n">a1</span><span class="p">(</span><span class="n">createInstance</span><span class="p">()),</span>
</span><span class='line'>    <span class="n">a2</span><span class="p">(</span><span class="n">createInstance</span><span class="p">(</span><span class="kc">true</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CTOR MYCLASS&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">~</span><span class="n">MyClass</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;DTOR MYCLASS&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>With a <code>unique_ptr</code>, we can still create resources when needed,
either in the initializer list, the constructor or even later. The
resources can still be created dynamically using <code>new</code> (as is still done
by function <em>createInstance</em>). When we&rsquo;re not taking the resources
away from the <code>unique_ptr</code>s, then they will free their managed
objects automatically and safely. We don&rsquo;t need to bother with <code>delete</code>.</p>

<p>And we don&rsquo;t need to bother with nested try&hellip;catch blocks either. If
anything goes wrong during object creation, any already assigned
<code>unique_ptr</code>s will happily release the resources they manage in their
own destructors.</p>

<p>It does not matter if the above code throws an exception in the first
invocation of <em>createInstance</em>, in the second or not at all: in every
case any allocated resources are released properly, and still there
is no need for any explicit exception handling or cleanup code. This is
what a smart pointer will do for us, behind the scenes.</p>

<p>Simply compare the following two code snippets, which both create three
instances of <em>A</em> while making sure no memory will be leaked if the
initialization goes wrong:</p>

<figure class='code'><figcaption><span>solution using smart pointers</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">a1</span><span class="p">(</span><span class="n">createInstance</span><span class="p">());</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">(</span><span class="n">createInstance</span><span class="p">());</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">a3</span><span class="p">(</span><span class="n">createInstance</span><span class="p">());</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// now do something with a1, a2, a3</span>
</span><span class='line'><span class="c1">// managed objects will be released automatically when</span>
</span><span class='line'><span class="c1">// the unique_ptrs go out of scope</span>
</span><span class='line'><span class="c1">// note: they may go out of scope unintentionally if</span>
</span><span class='line'><span class="c1">// some code below will throw an exception...</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>solution using nested try&#8230;catch blocks</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">A</span><span class="o">*</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'><span class="n">A</span><span class="o">*</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'><span class="n">A</span><span class="o">*</span> <span class="n">a3</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">;</span>
</span><span class='line'><span class="k">try</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">;</span>
</span><span class='line'>  <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">a3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">delete</span> <span class="n">a2</span><span class="p">;</span>
</span><span class='line'>    <span class="k">throw</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">delete</span> <span class="n">a1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">throw</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// now do something with a1, a2, a3</span>
</span><span class='line'><span class="c1">// objects a1, a2, a3 will not be released automatically</span>
</span><span class='line'><span class="c1">// when a1, a2, a3 go out of scope. any user of a1, a2, a3</span>
</span><span class='line'><span class="c1">// below must make sure to release the objects when they</span>
</span><span class='line'><span class="c1">// go out of scope or when an exception is thrown...</span>
</span></code></pre></td></tr></table></div></figure>


<p>Obviously the smart pointer-based solution is less verbose,
but it is also safer and hard to get wrong. It is especially
useful for initializing and managing dynamically allocated
object members, because as we&rsquo;ve seen most of the other
ways to do this are either subtly broken or much more complex.</p>

<p>Apart from that, we can take the managed object from out of a
<code>unique_ptr</code> and take over responsibility for managing its
lifetime.</p>

<p>Further on the plus side, a class definition that contains
<code>unique_ptr</code>s can be compiled with only forward declarations
for the managed types. However, when the <code>unique_ptr</code> is a
regular object member, at least the class destructor
implementation will need to know the size of the managed type
so it can call <code>delete</code> properly.</p>

<p>The downside of using smart pointers is that they may impose
minimal overhead when compared to the pure pointer-based
solution. However in most cases this overhead should be
absolutely negligible or even be optimized away by the compiler.
It may make a difference though when compiling without any
optimizations, but this shouldn&rsquo;t matter too much in reality.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">jsteemann</span></span>

      








  


<time datetime="2015-11-18T01:10:51+01:00" pubdate data-updated="true">Nov 18<span>th</span>, 2015</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/c-plus-plus/'>C++</a>, <a class='category' href='/blog/categories/development/'>Development</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://jsteemann.github.io/blog/2015/11/18/on-exception-handling/" data-via="steemann" data-counturl="http://jsteemann.github.io/blog/2015/11/18/on-exception-handling/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/09/10/arangodb-php-driver-improvements/" title="Previous Post: ArangoDB-PHP driver improvements">&laquo; ArangoDB-PHP driver improvements</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/11/18/bind-parameters-in-aql-editor/" title="Next Post: Using bind parameters in the AQL editor">Using bind parameters in the AQL editor &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
	<h1>About ArangoDB</h1>
	<ul>
    <li><a href="https://www.arangodb.com/">ArangoDB homepage</a></li>
    <li><a href="https://github.com/arangodb/arangodb">ArangoDB repository on Github</a></li>
  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/11/18/improved-deadlock-detection/">Improved Deadlock Detection</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/18/bind-parameters-in-aql-editor/">Using Bind Parameters in the AQL Editor</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/18/on-exception-handling/">C++ Constructors and Memory Leaks</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/10/arangodb-php-driver-improvements/">ArangoDB-PHP Driver Improvements</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/30/on-building-aql-query-strings/">On Building AQL Query Strings</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/01/how-v8-is-used-in-arangodb/">How V8 Is Used in ArangoDB</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/blog/categories/aql/'>AQL (30)</a></li><li><a href='/blog/categories/arangodb/'>ArangoDB (51)</a></li><li><a href='/blog/categories/arangoshell/'>ArangoShell (7)</a></li><li><a href='/blog/categories/bash/'>Bash (2)</a></li><li><a href='/blog/categories/c-plus-plus/'>C++ (8)</a></li><li><a href='/blog/categories/concepts/'>Concepts (8)</a></li><li><a href='/blog/categories/development/'>Development (7)</a></li><li><a href='/blog/categories/es6/'>ES6 (4)</a></li><li><a href='/blog/categories/foxx/'>Foxx (6)</a></li><li><a href='/blog/categories/git/'>Git (1)</a></li><li><a href='/blog/categories/graphs/'>Graphs (1)</a></li><li><a href='/blog/categories/indexes/'>Indexes (5)</a></li><li><a href='/blog/categories/javascript/'>JavaScript (8)</a></li><li><a href='/blog/categories/linux/'>Linux (7)</a></li><li><a href='/blog/categories/logstash/'>Logstash (1)</a></li><li><a href='/blog/categories/mysql/'>MySQL (1)</a></li><li><a href='/blog/categories/node-dot-js/'>Node.js (1)</a></li><li><a href='/blog/categories/parsing/'>Parsing (2)</a></li><li><a href='/blog/categories/performance/'>Performance (19)</a></li><li><a href='/blog/categories/php/'>PHP (3)</a></li><li><a href='/blog/categories/redis/'>Redis (1)</a></li><li><a href='/blog/categories/schemas/'>Schemas (3)</a></li><li><a href='/blog/categories/traversals/'>Traversals (1)</a></li><li><a href='/blog/categories/travisci/'>TravisCI (3)</a></li><li><a href='/blog/categories/wal/'>WAL (2)</a></li></ul>
</section>
<section>
  <h1>Monthly Archives</h1>
  <div class="monthly_archive"><ul class="year_list"><li class="year first_open">2015 (42)</li><ul class="month_list"><li class="month"><a href='/blog/2015/11/'>NOV (3)</a></li><li class="month"><a href='/blog/2015/09/'>SEP (1)</a></li><li class="month"><a href='/blog/2015/08/'>AUG (2)</a></li><li class="month"><a href='/blog/2015/07/'>JUL (5)</a></li><li class="month"><a href='/blog/2015/06/'>JUN (4)</a></li><li class="month"><a href='/blog/2015/05/'>MAY (8)</a></li><li class="month"><a href='/blog/2015/04/'>APR (7)</a></li><li class="month"><a href='/blog/2015/03/'>MAR (3)</a></li><li class="month"><a href='/blog/2015/02/'>FEB (5)</a></li><li class="month"><a href='/blog/2015/01/'>JAN (4)</a></li></ul><li class="year first_open">2014 (18)</li><ul class="month_list"><li class="month"><a href='/blog/2014/12/'>DEC (3)</a></li><li class="month"><a href='/blog/2014/11/'>NOV (3)</a></li><li class="month"><a href='/blog/2014/10/'>OCT (6)</a></li><li class="month"><a href='/blog/2014/08/'>AUG (5)</a></li><li class="month"><a href='/blog/2014/06/'>JUN (1)</a></li></ul></ul></div>
</section>

<section>
<h1>Stack Overflow</h1>
<a href="http://stackoverflow.com/users/3042070/stj">
<img src="http://stackoverflow.com/users/flair/3042070.png" width="208" height="58" alt="profile for stj at Stack Overflow, Q&amp;A for professional and enthusiast programmers" title="profile for stj at Stack Overflow, Q&amp;A for professional and enthusiast programmers">
</a>
</section>


  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - jsteemann -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
