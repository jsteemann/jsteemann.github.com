
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="google-site-verification" content="z-Pc5j8ZOiRrGa5d5_40zI-7Ub0Abh4AWPgidECbJ9c" />
  <title>Why JSON? - J@ArangoDB</title>
  <meta name="author" content="jsteemann">

  
  <meta name="description" content="To JSON or not? We&rsquo;re often asked why ArangoDB uses JSON as its
data-interchange format for transferring documents from clients to
the database &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jsteemann.github.io/blog/2014/08/14/why-json">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="J@ArangoDB" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<script src="/javascripts/monthly_archive.js"></script>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-53854700-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">J@ArangoDB</a></h1>
  
    <h2>Notes on ArangoDB development</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jsteemann.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Why JSON?</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-14T22:27:27+02:00" pubdate data-updated="true">Aug 14<span>th</span>, 2014</time>
        
      </p>
    
  </header>


<div class="entry-content"><h1>To JSON or not?</h1>

<p>We&rsquo;re often asked why ArangoDB uses <a href="http://json.org">JSON</a> as its
data-interchange format for transferring documents from clients to
the database server and back. This is often accompanied by the
question if we could use <code>&lt;insert fancy format here&gt;</code> instead.</p>

<p>In the following article, I&rsquo;ll try to outline the reasons for why
we picked JSON as the interchange format, and why we still use it.</p>

<p>I&rsquo;ll start with a discussion of the pros and cons of JSON, look at
some alternative formats and present my personal opinion on why
using a different format may not provide too much benefit for us,
at least at the moment.</p>

<!-- more -->


<p>This post does not intend to say that any of these formats are better
or worse in general. I think there are applications for all of them.</p>

<p>However, I wanted to look at the different formats with our specific
use case, i.e. a RESTful database, in mind.</p>

<h1>What I don&rsquo;t like about JSON</h1>

<p>JSON is often criticized for its inefficiency and lack of <strong>real</strong>
data types. I&rsquo;ll often criticize it myself.</p>

<p>Following are my personal top 3 pain points.</p>

<h2>Parsing and memory allocation</h2>

<p>I have to admit that parsing JSON is painful from the efficiency
perspective. When the JSON parser encounters a <code>{</code> token,
it will know this is the start of an object, but it has no idea how
many object members will follow and need to be stored with the
object. The same is true for lists (starting with <code>[</code>).</p>

<p>String values are no different: when the parser encounters a <code>"</code>,
the length of the string is still unknown. To determine the length
of the string, one must read until the end of the string, taking
into account escape sequences for special characters, e.g. <code>\/</code>,
<code>\n</code>, <code>\t</code>, <code>\\</code>, but also Unicode escape sequences.</p>

<p>For example, the escaped 36-byte string <code>In K\u00f6ln, it's 15 \u00b0 outside</code>
will be parsed into the 28-byte UTF-8 string <code>In Köln, it's 15 ° outside</code>.</p>

<p>With the overall size of objects, lists or strings unknown at the
start of a token, it&rsquo;s hard to reserve the <strong>right</strong> amount of memory.
Instead, memory either needs to be allocated on the fly as JSON
tokens are parsed, or (potentially too big) chunk(s) of memory
needs to be put aside at the start of parsing. The parser can
then use this already allocated memory to store whatever is found
afterwards.</p>

<h2>Verbosity</h2>

<p>JSON data can also become very fluffy. I already mentioned that
serializing strings to JSON might incur some overhead due to escape
sequences.</p>

<p>But there&rsquo;s more things like this: each boolean value requires 4
(<code>true</code>) or 5 (<code>false</code>) bytes respectively. Repeating object member
names need to be stored repeatedly, as JSON does not provide string
interning or similar mechanisms.</p>

<h2>Data types</h2>

<p>Apart from that, the JSON type system is limited. There is only one
type to represent numbers. Different types for representing numbers
of different value ranges are (intentionally) missing. For example,
one might miss 64 bit integer data types or arbitrary precision
numbers. A date type (for calendar dates and times) is often missed, too.</p>

<p>And yes, binary data cannot be represented in JSON without converting
them into a JSON string first. This may require base64-encoding or
something similar.</p>

<p>In general, the available data types in JSON are very limited, and the
format by itself is not extensible. Extending JSON with own type information
will either create ill-formed JSON (read: <em>non-portable</em>) or would
introduce special meaning members that other programs and tools won&rsquo;t
understand (read: <em>non-portable</em>).</p>

<h1>Why still use JSON?</h1>

<p>So what are the reasons to still stick with JSON?
From my point of view, there are still a few good reasons to do so:</p>

<h2>Simplicity</h2>

<p>The <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf">JSON specification</a>
fits on five pages (including images). It is simple and intuitive.</p>

<p>Additionally, JSON-encoded data is instantly comprehensible. There is
simply no need to look up the meanings of binary magic values in format
specifications. It is also very easy to spot errors in ill-formed JSON.</p>

<p>In my eyes, looking at JSON data during a debugging session is much
easier than looking at binary data (and I do look at binary data sometimes).</p>

<h2>Flexibility</h2>

<p>JSON requires no schema to be defined for data. This is good, as it allows to
get something done earlier. Schemas also tend to change over time, and this
can become a problem with other formats that have schemas. With schema-less JSON,
a schema change becomes a no-brainer &ndash; just change the data inside the JSON
and you&rsquo;re done. No need to maintain a separate schema.</p>

<p>The schema-relaxed approach of JSON also plays quite well with languages that
are loosely typed or allow runtime modifications of data structures. Most
scripting languages are in this category.</p>

<h2>Language support</h2>

<p>JSON is supported in almost every environment. Support for JSON is
sometimes built into languages directly (JavaScript) or the languages come
with built-in serialization and deserialization functions (e.g. PHP).
Just go and use it.</p>

<p>For any other language without built-in support for JSON, it won&rsquo;t be hard to find
a robust implementation for JSON serialization/deserialization.</p>

<p>In the ArangoDB server, we use a lot of JavaScript code ourselves. Users
can also extend the server functionality with JavaScript. Guess what happens
when a JSON request is sent to the server and its payload is handed to a
JavaScript-based action handler in the server? Yes, we&rsquo;ll take the request
body and create JavaScript objects from it. This is as simple as it can be,
because we have native JSON support in JavaScript, our server-side programming
language.</p>

<p>We also encourage users to use ArangoDB as a back end for their JavaScript-based
front ends. Especially when running in a browser, using JSON as the interchange
format inside AJAX* requests makes sense. You don&rsquo;t want to load serialization/deserialization
libraries that handle binary format into front ends for various reasons.</p>

<p>Many tools, including browsers, also support inspecting JSON data or can
import or export JSON-encoded data.</p>

<p>*Pop quiz: does anyone remember what was the meaning of the &ldquo;X&rdquo; in AJAX??</p>

<h1>Alternatives</h1>

<p>As I have tried to outline above, I think JSON has both strengths and
weaknesses. Is there an alternative format that is superior? I am listing
a few candidate formats below, and try to assess them quickly.</p>

<p>One thing that they all have in common is that they are not as much supported
by programming languages and tools as JSON is at the moment. For most of the
alternative formats, you would have to install some library in the environment
of your choice. XML is already available in many environments by default, with
the notable exception of JavaScript.</p>

<p>Even if a format is well supported by most programming languages, there are
other tools that should handle the format, too.</p>

<p>If there aren&rsquo;t any tools that allow converting existing data into the format,
then this is a severe limitation. Browsers, for example, are important tools.
Most of the alternative formats cannot be inspected easily with a browser,
which makes debugging data transfers from browser-based applications hard.</p>

<p>Additionally, one should consider how much example datasets are available.
I think at the moment it&rsquo;s much more likely that you&rsquo;ll find a JSON-encoded
dump of Wikipedia somewhere on the Internet than in one of the alternative
formats.</p>

<h2>Proprietary format</h2>

<p>An alternative to using JSON would be to create and our own binary format.
We could use a protocol tailored to our needs, and make it very very
efficient. The disadvantages of using a proprietary format are
that it is nowhere supported, so writing clients for ArangoDB in
another language becomes much harder for ourselves and for third-party
contributors. Effectively, we would need to write an adapter for
our binary protocol for each environment we want to have ArangoDB
used in.</p>

<p>This sounds like it would take a lot of time and keep us from doing
other things.</p>

<h2>XML</h2>

<p>It&rsquo;s human-readable, understandable, has a good standard type system
and is extensible. But if you thought that JSON is already inefficient
and verbose, try using XML and have fun. A colleague of mine even
claimed that XML is not human-readable due to its chattyness.</p>

<p>XML also hasn&rsquo;t been adopted much in the JavaScript community, and we
need to find a format that plays nicely with JavaScript.</p>

<h2>Smile</h2>

<p>There is also the <a href="http://wiki.fasterxml.com/SmileFormat">Smile</a> format.
Its goals are to provide an efficient alternative to JSON. It looks
good, but it does not seem to be used much outside of <a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>.
As mentioned earlier, we need a format that is supported in a variety of
environments.</p>

<h2>BSON</h2>

<p>Then there is <a href="http://bsonspec.org/">BSON</a>, made popular by MongoDB.
We had a look at it. It is not as space-efficient as it could be, but
it makes memory allocation very easy and allows for fast packing and
unpacking. It is not so good when values inside the structure need to
be updated. There are BSON-libraries for several languages</p>

<p>Still, it is a binary format. Using it for communication in the ArangoDB
cases includes using it from arbitrary JavaScript programs (including
applications run in a browser), using it in AJAX calls etc. This sounds
a bit like debugging hell.</p>

<h2>Msgpack</h2>

<p><a href="http://msgpack.org/">Msgpack</a> so far looks like the most-promising
alternative. It seems to become available in more and more programming
language environments. The format also seems to be relatively efficient.</p>

<p>A major drawback is that as a binary format, it will still be hard to debug.
Tool support is also not that great yet. Using Msgpack with a browser also
sounds like fun. I&rsquo;d like if tools like Firebug could display Msgpack
packet internals.</p>

<h2>Protocol buffers</h2>

<p>Two years ago, we also experimented with <a href="https://code.google.com/p/protobuf/">Protocol buffers</a>.
Protocol buffers require to set up a schema for the data first, and
then provide efficient means to serialize data from the wire into
programming-language objects.</p>

<p>The problem is that there are no fixed schemas in a document database
like ArangoDB. Users can structure their documents as they like. Each
document can have a completely different structure.</p>

<p>We ended up defining a schema for something JSON-like inside Protocol
buffers, and it did not make much sense in our use case.</p>

<h1>Conclusion</h1>

<p>There are alternative formats out there that address some of the issues
that JSON has from my point of view. However, none of the other formats
is yet that widely supported and easy to use as JSON.</p>

<p>This may change over time.</p>

<p>For our use case, it looks like Msgpack could fit quite well, but
probably only as a second, alternative interface for highest-efficiency
data transfers.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">jsteemann</span></span>

      








  


<time datetime="2014-08-14T22:27:27+02:00" pubdate data-updated="true">Aug 14<span>th</span>, 2014</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/arangodb/'>ArangoDB</a>, <a class='category' href='/blog/categories/concepts/'>Concepts</a>, <a class='category' href='/blog/categories/schemas/'>Schemas</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://jsteemann.github.io/blog/2014/08/14/why-json/" data-via="steemann" data-counturl="http://jsteemann.github.io/blog/2014/08/14/why-json/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/08/07/benchmarking-arangodbs-write-ahead-log/" title="Previous Post: Benchmarking ArangoDB's write-ahead log">&laquo; Benchmarking ArangoDB's write-ahead log</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/08/20/speeding-up-server-side-operations/" title="Next Post: Speeding up server-side operations">Speeding up server-side operations &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
	<h1>About ArangoDB</h1>
	<ul>
    <li><a href="https://www.arangodb.com/">ArangoDB homepage</a></li>
    <li><a href="https://github.com/arangodb/arangodb">ArangoDB repository on Github</a></li>
  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/02/07/using-ccache-when-working-with-different-branches/">Using Ccache When Working With Different Branches</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/05/using-arangodb-as-a-logstash-output/">Using ArangoDB as a Logstash Output</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/03/using-dynamic-attribute-names-in-aql/">Using Dynamic Attribute Names in AQL</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/31/yaor-yet-another-optimizer-rule/">YAOR - Yet Another Optimizer Rule</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/28/using-custom-visitors-in-aql-graph-traversals/">Using Custom Visitors in AQL Graph Traversals</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/blog/categories/aql/'>AQL (8)</a></li><li><a href='/blog/categories/arangodb/'>ArangoDB (20)</a></li><li><a href='/blog/categories/arangoshell/'>ArangoShell (2)</a></li><li><a href='/blog/categories/bash/'>Bash (1)</a></li><li><a href='/blog/categories/c-plus-plus/'>C++ (5)</a></li><li><a href='/blog/categories/concepts/'>Concepts (4)</a></li><li><a href='/blog/categories/development/'>Development (5)</a></li><li><a href='/blog/categories/foxx/'>Foxx (2)</a></li><li><a href='/blog/categories/graphs/'>Graphs (1)</a></li><li><a href='/blog/categories/indexes/'>Indexes (1)</a></li><li><a href='/blog/categories/javascript/'>JavaScript (5)</a></li><li><a href='/blog/categories/linux/'>Linux (5)</a></li><li><a href='/blog/categories/logstash/'>Logstash (1)</a></li><li><a href='/blog/categories/mysql/'>MySQL (1)</a></li><li><a href='/blog/categories/performance/'>Performance (4)</a></li><li><a href='/blog/categories/schemas/'>Schemas (3)</a></li><li><a href='/blog/categories/traversals/'>Traversals (1)</a></li><li><a href='/blog/categories/travisci/'>TravisCI (2)</a></li><li><a href='/blog/categories/wal/'>WAL (2)</a></li></ul>
</section>
<section>
  <h1>Monthly Archives</h1>
  <div class="monthly_archive"><ul class="year_list"><li class="year first_open">2015 (7)</li><ul class="month_list"><li class="month"><a href='/blog/2015/02/'>FEB (3)</a></li><li class="month"><a href='/blog/2015/01/'>JAN (4)</a></li></ul><li class="year first_open">2014 (18)</li><ul class="month_list"><li class="month"><a href='/blog/2014/12/'>DEC (3)</a></li><li class="month"><a href='/blog/2014/11/'>NOV (3)</a></li><li class="month"><a href='/blog/2014/10/'>OCT (6)</a></li><li class="month"><a href='/blog/2014/08/'>AUG (5)</a></li><li class="month"><a href='/blog/2014/06/'>JUN (1)</a></li></ul></ul></div>
</section>

<section>
<h1>Stack Overflow</h1>
<a href="http://stackoverflow.com/users/3042070/stj">
<img src="http://stackoverflow.com/users/flair/3042070.png" width="208" height="58" alt="profile for stj at Stack Overflow, Q&amp;A for professional and enthusiast programmers" title="profile for stj at Stack Overflow, Q&amp;A for professional and enthusiast programmers">
</a>
</section>


  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - jsteemann -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
