<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Graphs | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/graphs/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2015-04-25T01:06:54+02:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Custom Visitors in AQL Graph Traversals]]></title>
    <link href="http://jsteemann.github.io/blog/2015/01/28/using-custom-visitors-in-aql-graph-traversals/"/>
    <updated>2015-01-28T22:21:35+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/01/28/using-custom-visitors-in-aql-graph-traversals</id>
    <content type="html"><![CDATA[<p>This post is about some recent extensions for the AQL graph traversal functionality
in ArangoDB.</p>

<p>These extensions allow invoking user-defined JavaScript code for filtering
and results generation in AQL queries that contain traversals.</p>

<p>This should make AQL graph traversals much more powerful than before.
Additionally, AQL graph traversals get more configurable, allowing to write
traversal functions with control-flow logic and complex filtering. As a
side-effect, this change facilitates writing specialized traversal functions
with much higher efficiency than the general-purpose, cover-all-cases default
ones.</p>

<p>The extensions are currently available in the devel branch of ArangoDB on in the
2.4 branch (with 2.4.2 being the first release to include them).</p>

<!-- more -->


<h1>Example graph</h1>

<p>For all following examples, I&rsquo;ll be using a small example graph that can be set
up by running <a href="/downloads/code/world-graph-setup.js">this script</a> from the ArangoShell.</p>

<p>I have chosen this small graph because it is easy to understand and still complex
enough to demonstrate some common traversal use cases.</p>

<p>The example graph consists of the following two collections:</p>

<ul>
<li><code>v</code>: a collection with vertex documents</li>
<li><code>e</code>: an edge collection containing the connections between vertices in <code>v</code></li>
</ul>


<p>All vertices in the graph have a <code>type</code> attribute, with types being either <code>root</code>,
<code>continent</code>, <code>country</code> or <code>capital</code>. The graph is a tree, so it has only one vertex
with type <code>root</code>. The root vertex is named <em>world</em>. Below the root there are only
vertices of type <code>continent</code>. These are also connected to some <code>country</code> vertices.
Finally, <code>country</code> vertices are also connected to <code>capital</code> vertices:</p>

<p><code>plain
root &lt;--[is in]-- continent &lt;--[is in]-- country &lt;--[is in]-- capital
</code></p>

<p>In the examples, we&rsquo;ll only look at the vertices and ignore what the connections
look like.</p>

<h1>Custom visitors</h1>

<p>We know the graph is a tree, so let&rsquo;s print its structure in a textual format
using AQL. We&rsquo;ll employ a <strong>custom visitor function</strong> for this. A custom visitor is
a user-defined callback function that is called for every vertex that is encountered
during a graph traversal. Custom visitor functions need to be written in JavaScript
and be registered once before they can be used from an AQL query.</p>

<p>Custom visitors have the following function signature:
<code>js visitor function signature
function (config, result, vertex, path)
</code></p>

<p>The function parameters have the following meanings:</p>

<ul>
<li><code>config</code>: the traversal configuration</li>
<li><code>result</code>: the result already generated by the traversal. This is important only
if the visitor is designed to modify an existing result in-place</li>
<li><code>vertex</code>: the currently visited vertex document</li>
<li><code>path</code>: the path from the start vertex to the currently visited vertex document.
The path will contain an array <code>vertices</code> and an array <code>edges</code></li>
</ul>


<p>Let&rsquo;s register a custom visitor named <code>myfunctions::structurePrinter</code>. This can done
by running the following code from the ArangoShell:</p>

<p>```js registering a custom visitor to print the tree structure
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex, path) {
  var indentation = new Array(path.vertices.length).join(&ldquo;  &rdquo;);
  var label       = &ldquo;&ndash; &rdquo; + vertex.name + &ldquo; (&rdquo; + vertex.type + &ldquo;)&rdquo;;
  return indentation + label;
});
```</p>

<h2>Processing vertex data with a function</h2>

<p>The above function will be called for every vertex in the graph when we use it in
a traversal. Let&rsquo;s do it and run the AQL query to invoke the visitor function.</p>

<p>I suggest running the query from the web interface&rsquo;s <strong>AQL editor</strong>:</p>

<p><code>plain invoking the custom visitor
LET params = {
  visitor : "myfunctions::structurePrinter",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>The visitor will visit all vertices in the graph, starting at the vertex
<code>v/world</code> as specified. It will then follow incoming connections using a
depth-first search (this was not specified in the query as it is the default).</p>

<p>As we started with the root vertex of the graph, the query will visit all
vertices exactly once. Fortunately the example graph is a tree and does not
contain any cycles, so we do not have to care about how to make the traversal
terminate. The traversal will automatically terminate after it has visited all nodes.</p>

<p>The AQL query should produce something like this:</p>

<p><code>js query result
[
  "- World (root)",
  "  - North America (continent)",
  "    - Bahamas (country)",
  "      - Nassau (capital)",
  "    - Canada (country)",
  "      - Ottawa (capital)",
  "    - Antigua and Barbuda (country)",
  "      - Saint John's (capital)",
  "    - Barbados (country)",
  "      - Bridgetown (capital)",
  "  - Asia (continent)",
  "    - Afghanistan (country)",
  "      - Kabul (capital)",
  ...
]
</code></p>

<p>This should provide a good overview of the graph&rsquo;s contents.</p>

<h2>Referring to elements in the path</h2>

<p>To return the above result in a more structured manner, let&rsquo;s overwrite the
previous visitor function with one that returns the most interesting vertex
attributes individually. Let&rsquo;s include one that shows the nesting level of
each vertex in the tree:</p>

<p>```js registering another custom visitor to return the tree structure
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex, path) {
  return {</p>

<pre><code>name: vertex.name, 
type: vertex.type, 
level: path.vertices.length 
</code></pre>

<p>  };
});
```</p>

<p>Running the same AQL query will now return something like:</p>

<p>```js query result
[
  {</p>

<pre><code>"name" : "World", 
"type" : "root", 
"level" : 1 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "North America", 
"type" : "continent", 
"level" : 2 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Bahamas", 
"type" : "country", 
"level" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Nassau", 
"type" : "capital", 
"level" : 4 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Canada", 
"type" : "country", 
"level" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Ottawa", 
"type" : "capital", 
"level" : 4 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Antigua and Barbuda", 
"type" : "country", 
"level" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Saint John's", 
"type" : "capital", 
"level" : 4 
</code></pre>

<p>  },
  &hellip;
]
```</p>

<h2>Adding control flow</h2>

<p>Now let&rsquo;s add some control flow to the visitor function. The following visitor
function will also return information about each vertex' parent &ndash; except for the
root vertex, which does not have a parent:</p>

<p>```js a custom visitor with simple control flow
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex, path) {
  var res = {</p>

<pre><code>name: vertex.name, 
type: vertex.type, 
level: path.vertices.length
</code></pre>

<p>  };
  if (path.vertices.length > 1) {</p>

<pre><code>res.parent = { 
  name: path.vertices[path.vertices.length - 2].name, 
  type: path.vertices[path.vertices.length - 2].type
}; 
</code></pre>

<p>  }
  return res;
});
```</p>

<p>Running our AQL query will now produce a different type of result for the root vertex
than for all the other vertices:</p>

<p>```js query result
[
  {</p>

<pre><code>"name" : "World", 
"type" : "root", 
"level" : 1 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "North America", 
"type" : "continent", 
"level" : 2, 
"parent" : { 
  "name" : "World", 
  "type" : "root" 
} 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Bahamas", 
"type" : "country", 
"level" : 3, 
"parent" : { 
  "name" : "North America", 
  "type" : "continent" 
} 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Nassau", 
"type" : "capital", 
"level" : 4, 
"parent" : { 
  "name" : "Bahamas", 
  "type" : "country" 
} 
</code></pre>

<p>  },
  &hellip;
]
```</p>

<p>Of course much more things can be achieved by peeking the <em>path</em> variable.</p>

<h1>Filtering</h1>

<p>Now let&rsquo;s try to restrict the results of a graph traversal to just some vertices,
for example, all European countries. As we know the structure of the graph is quite
simple, the following naive approach will already do:</p>

<p>```js a custom visitor returning only European country names
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex, path) {
  if (path.vertices.length > 1 &amp;&amp;</p>

<pre><code>  path.vertices[path.vertices.length - 2].name === "Europe") {
return vertex.name; 
</code></pre>

<p>  }
});
```</p>

<p>But the above is clearly not ideal.</p>

<p>First of all, the traversal will still <strong>visit every vertex</strong> in the graph, even though
most vertices will not be returned. Ideally, one will want to restrict a traversal to
visit as few vertices as possible, especially in a big graph or in a graph that contains
cycles.</p>

<p>Second, the above visitor is looking into a vertex' direct parent for filtering. This
will work for graphs that have a rigid structure, but may not work in more complex setups.</p>

<p>We better use a dedicated function for filtering. Such function can control
if a given vertex is going to be visited (via calling the <em>visitor</em> function) and if its
connections should be followed. It can skip non-interesting vertices early, providing a
good way to make traversals more efficient.</p>

<p>A filter function can be specified in the <em>filterVertices</em> attribute of the traversal options.
If specified, <em>filterVertices</em> needs to contain the name of a custom AQL function. A filter
function again needs to be written in JavaScript and has the following signature:</p>

<p><code>js filter function signature
function (config, vertex, path)
</code></p>

<p>The filter function will be called for each vertex. It can return one of the
following values:</p>

<ul>
<li><code>"prune"</code>: visit the vertex, but do not descend into its connections</li>
<li><code>"exclude"</code>: do not visit the vertex, but do descend into its connections</li>
<li><code>[ "prune", "exclude" ]</code>: do not visit, and do not descend</li>
<li><code>undefined</code> (default): visit and descend</li>
</ul>


<p>The following filter function will return <code>"exclude"</code> for the root vertex, leading
to the visitor not being called for it. However, the traversal will still descend
into the connections of the root node.</p>

<p>On the next level, all continents will be enumerated. The filter will return
<code>[ "prune", "exclude" ]</code> for all continents but Europe, leading to the visitor not
being invoked for these continents, and their connections not being followed.
For the <em>Europe</em> vertex, it will return <code>"exclude"</code>,
meaning the visitor will not be called, but the traversal will descend into the
connections of <code>Europe</code>.</p>

<p>For all vertices of type <code>country</code>, the visitor will be
called. This is ok because the filter previously prevented the traversal from
descending into any other country but <em>Europe</em>.</p>

<p>Finally, the filter will return <code>"prune"</code> for all countries, meaning the traversal
will not descend into a country&rsquo;s connections (in this case that would be the captial vertices).
This will make the traversal end at the <code>country</code> level.</p>

<p>Here it is:</p>

<p>```js registering a filter for European countries
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::europeFilter&rdquo;, function (config, vertex, path) {
  if (vertex.type === &ldquo;country&rdquo;) {</p>

<pre><code>return "prune";
</code></pre>

<p>  }</p>

<p>  if (vertex.type === &ldquo;continent&rdquo;) {</p>

<pre><code>if (vertex.name !== "Europe") {
  return [ "prune", "exclude" ];
}
</code></pre>

<p>  }</p>

<p>  return &ldquo;exclude&rdquo;;
});
```</p>

<p>Putting the logic into the filter function allows using a very simple visitor:</p>

<p>```js a very simple visitor
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex) {
  return vertex.name;
});
```</p>

<p>We must also slightly extend our AQL query and tell it to use our custom filter function:
<code>plain invoking the custom visitor and the custom filter
LET params = {
  filterVertices : "myfunctions::europeFilter",
  visitor : "myfunctions::structurePrinter",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>Running the adjusted AQL query should produce something like:
<code>js query results
[
  "Austria",
  "Croatia",
  "Bosnia and Herzegovina",
  "Andorra",
  "Bulgaria",
  ...
]
</code></p>

<p>Custom filter functions are a very general approach. Obviously much more complex tasks
than shown here can be achieved with them. We have often been asked for ways to set up
complex filter conditions in AQL traversals, and I hope these custom filter functions
will cover most of that.</p>

<h1>Special visitors</h1>

<p>Traversal depths can be controlled with the general configuration parameters
<code>minDepth</code> and <code>maxDepth</code>. These parameters are helpful to make the traversal only
include vertices occurring after the specified distance from the start vertex, or
up to the specified distance away from the start vertex. This helps bounding
traversals, but is not flexible enough when handling graphs with very distinct
path lengths.</p>

<h2>Returning only leaf nodes</h2>

<p>For example, <strong>finding leaf nodes</strong> in a graph is quite hard using a default
traversal. The <em>filterVertices</em> function cannot be used to find leaf nodes, because
<em>filterVertices</em> is called before a vertex' connections are determined. The same is true
for visitor functions. There were not provided any information about whether the
currently visited vertex has connections or not. All a visitor could previously do
to find leaf nodes is to return each visited vertex along with the full path information.
Some post-processing of the traversal result with regular AQL was then required to
detect the leaf nodes in that result.</p>

<p>This could easily get inefficient, especially in a big graphs for which the intermediate
results created by the default traversal visitor grew beyond reasonable sizes.</p>

<p>We therefore added a mechanism that can pass information about the vertex' connections
to the visitor. This allows writing new types of visitor functions. For example, it
makes it easy to write visitors that can return only leaf nodes.</p>

<p>In order to have the traversal pass the currently visited vertex' connections to the
visitor function, the traversal parameter <code>order</code> must be set to a value of <code>"preorder-expander"</code>.
The traversal&rsquo;s visitor function will then be called with an additional fifth
parameter named <code>connected</code>, which is an array of the connections of the current
vertex. This array will be empty if the traversal&rsquo;s expander function did not
find any connections for the vertex.</p>

<p>Here&rsquo;s a simple visitor that will make a traversal return only all leaf nodes:</p>

<p>```js a visitor that receives information about connections, too
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::leafNodeVisitor&rdquo;, function (config, result, vertex, path, connected) {
  if (connected &amp;&amp; connected.length === 0) {</p>

<pre><code>return vertex.name + " (" + vertex.type + ")";
</code></pre>

<p>  }
});
```</p>

<p>And here&rsquo;s an AQL query that shows how to use this type of visitor:</p>

<p><code>plain invoking the leaf node visitor
LET params = {
  order : "preorder-expander",
  visitor : "myfunctions::leafNodeVisitor",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>As a result, the above query will only print vertices of type <code>capital</code>
(because those are the only leaf nodes in the graph).</p>

<p>The nice thing when looking at the custom visitor function is that it only
filters on the number of connections, but not on vertex type or anything else
specific for this type of graph.</p>

<p>So it seems like the above function is general purpose and can be reused for
other graphs, too.</p>

<h2>Counting vertices</h2>

<p>Let&rsquo;s say we wanted to count the number of vertices in the graph, or the number of
vertices that passed our <em>filterVertices</em> function.</p>

<h3>Counting globally</h3>

<p>This is easy to achieve with a custom visitor like this:</p>

<p>```js registering a visitor that counts the number of vertices visited
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::vertexCounter&rdquo;, function (config, result) {
  if (result.length === 0) {</p>

<pre><code>result.push(0);
</code></pre>

<p>  }
  result[0]++;
});
```</p>

<p>Note that the above visitor function does not return anything, but will modify an existing
result in place. As a result, it will produce one counter value, which will be increased
whenever the visitor is called for a vertex.</p>

<p>To invoke this visitor and retrieve the count value, we have to set the <em>visitorReturnsResults</em>
attribute in the AQL query to <em>false</em>. This will make the traversal code pass the existing
result into the visitor and does not expect it to return any results via a <code>return</code> instruction.
Here&rsquo;s how to run this visitor:</p>

<p><code>plain invoking the global vertex counter
LET params = {
  visitor : "myfunctions::vertexCounter",
  visitorReturnsResults : false
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>The result will simply be:
<code>js query result
[
  87
]
</code></p>

<h3>Counting by type</h3>

<p>Let&rsquo;s say we wanted to count vertices by type. This is similar, except that now one global
counter value is insufficient and we instead need an object to keep track of the different
counters. We can still get away with modifying an existing result in place:</p>

<p>```js registering a visitor that counts vertices by type
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::vertexCounter&rdquo;, function (config, result, vertex) {
  if (result.length === 0) {</p>

<pre><code>result.push({ });
</code></pre>

<p>  }
  var vertexType = vertex.type;
  if (! result[0].hasOwnProperty(vertexType)) {</p>

<pre><code>result[0][vertexType] = 1;
</code></pre>

<p>  }
  else {</p>

<pre><code>result[0][vertexType]++;
</code></pre>

<p>  }
});
```</p>

<p>Our invocation AQL query does not change. The result of this visitor for the example graph will be:
```js query result
[
  {</p>

<pre><code>"root" : 1, 
"continent" : 6, 
"country" : 40, 
"capital" : 40 
</code></pre>

<p>  }
]
```</p>

<p>Of course such visitors can be combined with custom filters.</p>

<p>You probably ask why writing custom code is required to achieve a simple task like counting.
The main reason for this is that the traversal functionality is very general purpose and
is not optimized for a specific use case like just counting. For example, the default traversal
visitor will copy the complete vertex and path information into the result.</p>

<p>This can produce very big intermediate results if the graph is big or vertices contain lots
of data. If all we want is to count the number of vertices globally or per type, we are better
off with something more specialized.</p>

<p>The good news is that the most simple use case &ldquo;count all vertices&rdquo; there is a predefined
visitor named <code>_AQL::COUNTINGVISITOR</code> that can directly be used from a query, without prior
registration of a custom function:</p>

<p><code>plain using the predefined countingvisitor function
LET params = {
  visitor : "_AQL::COUNTINGVISITOR"
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<h1>Accessing components from the path</h1>

<p>Visitors are allowed to peek into the <code>paths</code> variable to check how the currently visited
vertex is linked to others.</p>

<p>The paths variable is an object with a <code>vertices</code> sub-attribute and an <code>edges</code> sub-attribute.
<code>vertices</code> is an array including all vertices in the path from the start vertex up to the
currently visited vertex. The currently visited vertex is included in this array.
<code>edges</code> is an array including all connections (edges) between the start vertex and the
currently visited vertex. This array might be empty, in case the visitor is called for the
start vertex.</p>

<p>The following visitor function demonstrates how to peek into <code>paths</code>: it will produce a
stringified version of the path for all leaf vertices:</p>

<p>```js registering a visitor that accesses components from the path
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::leafNodePathVisitor&rdquo;, function (config, result, vertex, path, connected) {
  if (connected &amp;&amp; connected.length === 0) {</p>

<pre><code>var res = "";
path.vertices.forEach(function(v, i) {
  if (i &gt; 0 &amp;&amp; i &lt;= path.edges.length) {
    res += " &lt;--[" + path.edges[i - 1].type + "]-- ";
  }
  res += v.name;
});
return res;
</code></pre>

<p>  }
});
```</p>

<p>It can be invoked as follows:</p>

<p><code>plain using the visitor that accesses path components
LET params = {
  order : "preorder-expander",
  visitor : "myfunctions::leafNodePathVisitor",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>It will return something like the following:
<code>js query result
[
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Algeria &lt;--[is-in]-- Algiers",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Angola &lt;--[is-in]-- Luanda",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Botswana &lt;--[is-in]-- Gaborone",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Burkina Faso &lt;--[is-in]-- Ouagadougou",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Burundi &lt;--[is-in]-- Bujumbura",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Cameroon &lt;--[is-in]-- Yaounde",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Chad &lt;--[is-in]-- N'Djamena",
  ...
]
</code></p>

<p>Note: the contents of the <code>path</code> variable will change between calls to the
visitor function. Therefore is it not safe to reference arrays or objects from <code>path</code>
in the result for visitors that modify the <code>result</code> variable in place (i.e. when
<em>visitorReturnsResults</em> is set to <em>false</em>). The safe way to put path components
into the result of such visitors is to clone the parts of the path before putting
them into <code>result</code>.</p>

<h1>Passing parameters into visitors and filters</h1>

<p>It is often useful to pass own parameters into function to provide some sort
of invocation context. For example, the purpose of the following visitor function
is to return an object with only certain attributes of each visited vertex:</p>

<p>```js a visitor that can return arbitrary vertex attributes:
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::attributesPrinter&rdquo;, function (config, result, vertex) {
  var values = { };
  if (typeof config.data === &ldquo;object&rdquo; &amp;&amp; Array.isArray(config.data.attributes)) {</p>

<pre><code>config.data.attributes.forEach(function (attribute) {
  values[attribute] = vertex[attribute];
});
</code></pre>

<p>  }
  return values;
});
<code>``
Which attributes the function will return can be configured by passing in an
array of attribute names in the</code>config<code>parameter's</code>data<code>sub-attribute. Here's
an AQL query that will configure the visitor to return</code>_id<code>and</code>type`:</p>

<p>```plain invoking the attributes visitor
LET params = {
  visitor : &ldquo;myfunctions::attributesPrinter&rdquo;,
  visitorReturnsResults : true,
  data: {</p>

<pre><code>attributes: [ "_id", "type", "name" ] 
</code></pre>

<p>  }<br/>
}
FOR result IN TRAVERSAL(v, e, &ldquo;v/world&rdquo;, &ldquo;inbound&rdquo;, params)
  RETURN result
```</p>
]]></content>
  </entry>
  
</feed>
