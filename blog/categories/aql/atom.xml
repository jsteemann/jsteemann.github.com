<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: AQL, | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/aql/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2015-06-01T14:30:09+02:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[On Getting Unique Values]]></title>
    <link href="http://jsteemann.github.io/blog/2015/06/01/on-getting-unique-values/"/>
    <updated>2015-06-01T13:27:13+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/06/01/on-getting-unique-values</id>
    <content type="html"><![CDATA[<p>While paging through the issues in the <a href="https://github.com/arangodb/arangodb">ArangoDB issue tracker</a>
I came across <a href="https://github.com/arangodb/arangodb/issues/987">issue #987</a>, titled
<em>Trying to get distinct document attribute values from a large collection fails</em>.</p>

<p>The issue was opened around 10 months ago when ArangoDB 2.2 was around. We improved AQL performance
somewhat since then, so I was eager to see how the query would perform in ArangoDB 2.6, especially
when comparing it to 2.2.</p>

<!-- more -->


<p>For reproduction I quickly put together some example data to run the query on:
<code>js setting up example data
var db = require("org/arangodb").db;
var c = db._create("test");
for (var i = 0; i &lt; 4 * 1000 * 1000; ++i) {
  c.save({ _key: "test" + i, value: (i % 100) });
}
require("internal").wal.flush(true, true);
</code></p>

<p>This produces a collection named <code>test</code> with 4 million documents. Each document has a numeric <code>value</code>
attribute, which in total has 100 unique values. I remembered from a conversation with the guy that
opened the issue that the number of distinct values was 100 or even slightly lower. I didn&rsquo;t bother
to create an index on the <code>value</code> attribute, which might have sped up the query.</p>

<p>With data available, it was time to run the query and measure its execution time:
<code>js running the query
var time = require("internal").time;
var start = time();
db._query("FOR doc IN test COLLECT value = doc.value RETURN value");
time() - start;
</code></p>

<p>Running this in 2.2.7 took 3 minutes and 18 seconds before bursting with the following error message:</p>

<p>```plain 2.2.7 error message
#</p>

<h1>Fatal error in CALL_AND_RETRY_2</h1>

<h1>Allocation failed &ndash; process out of memory</h1>

<p>#
```</p>

<p>In the 2.2 branch AQL queries were fully transformed to JavaScript and executed using V8. Obviously
that didn&rsquo;t work well with large collections. That was one of the reasons why version 2.3 saw a major
rewrite of the AQL engine.</p>

<p>As a consequence, running the query in 2.3 (2.3.5) worked fine. Execution took around 28 seconds.
The same was true for 2.4 (2.4.8) and 2.5 (2.5.5).</p>

<p>Finally, running the query in 2.6.0 completed in just 3.2 seconds.</p>

<p>The reasons for the speedup are the optimizations done for <code>COLLECT</code> (see
<a href="/blog/2015/04/22/collecting-with-a-hash-table/">COLLECTing with a hash table</a>, the
<a href="/blog/2015/05/04/return-value-optimization-for-aql/">Return value optimization for AQL</a> and some
minor optimizations within AQL that didn&rsquo;t get a pretty working title.</p>

<p>Looks like in sum all the optimizations put into 2.6 really pay out.</p>
]]></content>
  </entry>
  
</feed>
