<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: AQL | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/aql/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2015-11-19T00:43:32+01:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Improved Deadlock Detection]]></title>
    <link href="http://jsteemann.github.io/blog/2015/11/18/improved-deadlock-detection/"/>
    <updated>2015-11-18T19:24:24+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/11/18/improved-deadlock-detection</id>
    <content type="html"><![CDATA[<p>The upcoming ArangoDB version 2.8 (currently in devel) will
provide a much better deadlock detection mechanism than its
predecessors.</p>

<p>The new deadlock detection mechanism will kick in automatically
when it detects operations that are mutually waiting for each other.
In case it finds such deadlock, it will abort one of the operations
so that the others can continue and overall progress can be made.</p>

<!-- more -->


<p>In previous versions of ArangoDB, deadlocks could make operations
wait forever, requiring the server to be stopped and restarted.</p>

<h2>How deadlocks can occur</h2>

<p>Here&rsquo;s a simple example for getting into a deadlock state:</p>

<p>Transaction A wants to write to collection c1 and to read from collection
c2. In parallel, transaction B wants to write to collection c2 and read
from collection c1. If the sequence of operations is interleaved as follows,
then the two transactions prevent each other from making progress:</p>

<ul>
<li>transaction A successfully acquires write-lock on c1</li>
<li>transaction B sucessfull acquires write-lock on c2</li>
<li>transaction A tries to acquire read-lock on c2 (and must wait for B)</li>
<li>transaction B tries to acquire read-lock on c1 (and must wait for A)</li>
</ul>


<p>Here&rsquo;s these such two transactions being started from two ArangoShell
instances in parallel (left is A, right is B):</p>

<p><img src="/downloads/screenshots/deadlock.png"></p>

<p>(note that this screenshot is from 2.8 and the automatic deadlock detection
had already detected the deadlock and aborted one of the transactions)</p>

<p>In general, deadlocks can occur only when multiple operations (AQL
queries or other transactions) try to access the same resources
(collections) at the same time, and only if the operations already
have already acquired some locks on these resources. And finally
each operation needs to involve more than one collection, so there
is the potential for already having acquired some locks but having
to wait for others.</p>

<h2>Dynamically added collections</h2>

<p>Most operations will just work fine and will not cause any deadlocks.
This is especially true for all operations that involve only a single
collection. This leaves multi-collection AQL queries and multi-collection
userland transactions.</p>

<p>Normally these will also work fine. This is because when a query or
transaction starts, it will tell the transaction manager about the resources
(collections) it will need. The transaction manager can then acquire the
required resources in a deterministic fashion that prevents deadlocks.
If all queries and transactions properly announce upfront which collections
they will access, there will also be no deadlocks.</p>

<p>But for some operations its hard to predict at transaction start which
collections will be accessed. This includes some AQL functions that
can dynamically access collection data without having to specify the
collection name anywhere in the query.</p>

<p>A good example for this is the <code>GRAPH_EDGES</code> AQL function, which will get
a graph name as its first input parameter, but not the names of the underlying
edge collection(s). When this function is used in an AQL query, the
query parser will just find a function parameter containing a graph name
but doesn&rsquo;t know it&rsquo;s a collection name.</p>

<p><code>
GRAPH_EDGES("myEdges", [ { type: "friend" } ])
</code></p>

<p>The <code>"myEdges"</code> graph name will look like any other string to the parser.
It does not know about the contexts in which strings may have special meanings.</p>

<p>Note that even if this would be fixed, the problem won&rsquo;t go away entirely:
a function call parameter in a query isn&rsquo;t necessarily a constant but can
be an arbitrary expression:</p>

<p><code>
FOR doc IN collection
  RETURN GRAPH_EDGES(CONCAT(doc.graphName, '-test'), [ doc.example ])
</code></p>

<p>At least in this case the AQL query parser won&rsquo;t find a collection name,
so when the AQL query starts it is yet unknown which collections will be
accessed. Only at runtime when the function is actually executed, the
collection names will be looked up by finding the graph description in the
<code>_graphs</code>system collection. Then the edge collections participating in
the graph will be added to the query dynamically. Only this dynamic addition
adds the potential for deadlock.</p>

<p>This dynamic addition of collections in unavoidable for conveniently
querying data from collections whose names are unknown when the query starts.</p>

<h2>Deadlock detection</h2>

<p>Whenever transaction manager detects a deadlock in ArangoDB 2.8, it will
automatically abort one of the blocking transactions. The transaction will
be rolled back and all modifications it has made will be reverted. The
operation will fail with error code 29 (<em>deadlock detected</em>) and raise an
exception that the user can handle in the calling code.</p>

<p>Deadlocks will be found if two transactions mutually lock each other as
seen in the screenshot above, but also for more complex setups. The following
screenshot shows four parallel transactions that block each other indirectly.</p>

<p><img src="/downloads/screenshots/threeway-deadlock.png"></p>

<p>The top left window (transaction 1) will block the one in the top right
(transaction 2), and is itself blocked by the transaction in the bottom left
(transaction 3).</p>

<p>The transaction in the top right window (transaction 2) blocks the one in the
bottom left (transaction 3), and is itself blocked by the one in the top left
(transaction 1).</p>

<p>Transaction 3 (bottom left) is blocked by transaction 2 (top right).
Transaction 4 (bottom right) does exactly the same as transaction 3.</p>

<p>With these transactions, we end up in this waiting state:</p>

<ul>
<li>T1 waits for T3 and T4</li>
<li>T2 waits for T1</li>
<li>T3 waits for T2</li>
<li>T4 waits for T2</li>
</ul>


<p>This waiting state is cyclic (T1 &lt; T3 &lt; T2 &lt; T1) and therefore no progress
can be made. This is exactly a situation in which the transaction manager
will abort one of the transactions.</p>

<p>No configuration is required for the deadlock detection mechanism. It will
always be active and cannot be configured or turned off.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Bind Parameters in the AQL Editor]]></title>
    <link href="http://jsteemann.github.io/blog/2015/11/18/bind-parameters-in-aql-editor/"/>
    <updated>2015-11-18T19:24:24+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/11/18/bind-parameters-in-aql-editor</id>
    <content type="html"><![CDATA[<p>The AQL editor in the web interface is useful for running ad hoc AQL
queries and trying things out. It provides a feature to <em>explain</em> the
query and inspect its execution plan. This can be used to check if the
query uses indexes, and which.</p>

<p>So far the AQL editor only supported using query string literals, but <strong>it
lacked support for bind parameters</strong>. Queries issued by application code
however often <strong>will use bind parameters</strong> for security reasons. Often
enough this prevented copying &amp; pasting queries from the application code into
the AQL editor and vice versa without making manual adjustments.</p>

<!-- more -->


<p>This has been fixed in the upcoming ArangoDB version 2.8 (currently in
development). Bind parameters can now be used in the AQL editor as well.
Bind parameters can be entered as JSON values, the same format that is
used for bind parameters in the HTTP REST API and in (JavaScript) application
code.</p>

<p>The queries can also be saved in the AQL editor along with their bind parameter
values for later reuse.</p>

<p>Screenshot from the feature in 2.8:</p>

<p><img src="/downloads/screenshots/bind-parameters.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On Building AQL Query Strings]]></title>
    <link href="http://jsteemann.github.io/blog/2015/08/30/on-building-aql-query-strings/"/>
    <updated>2015-08-30T23:14:42+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/08/30/on-building-aql-query-strings</id>
    <content type="html"><![CDATA[<p>I recently wrote two recipes about generating AQL query
strings. They are contained in the ArangoDB cookbook by now:</p>

<ul>
<li><a href="https://docs.arangodb.com/cookbook/AvoidingInjection.html">Avoiding parameter injection in AQL</a></li>
<li><a href="https://docs.arangodb.com/cookbook/MultilineQueryStrings.html">Writing multi-line AQL queries</a></li>
</ul>


<p>After that, Github user <em>tracker1</em> suggested in <a href="https://github.com/arangodb/arangodb/issues/1457">Github issue 1457</a>
to take the ES6 template string variant even further, using a generator function for
string building, and also using promises and ES7 async/await.</p>

<p>We can&rsquo;t use ES7 async/await in ArangoDB at the moment due to lacking support
in V8, but the suggested template string generator function seemed to be an
obvious improvement that deserved inclusion in ArangoDB.</p>

<!-- more -->


<p>Basically, the suggestion is to use regular JavaScript variables/expressions in
the template string and have them substituted <em>safely</em>.</p>

<p>With regular AQL bind parameters, a query looks like this:</p>

<p><code>``js
var bindVars = { name: "test" };
var query =</code>FOR doc IN collection</p>

<pre><code>         FILTER doc.name == @name 
         RETURN doc._key`;
</code></pre>

<p>db._query(query, bindVars);
```</p>

<p>This is immune to parameter injection, because the query string and the bind parameter
value are passed in separately. But it&rsquo;s <strong>not very ES6-y</strong>.</p>

<p>Now, after partly implementing <em>tracker1</em>&rsquo;s suggestion, JavaScript values
and expressions can be used much more <em>naturally</em> when building AQL query strings:</p>

<p><code>``js
var name = "test";
var query = aqlQuery</code>FOR doc IN collection</p>

<pre><code>                 FILTER doc.name == ${name} 
                 RETURN doc._key`;
</code></pre>

<p>db._query(query);
```</p>

<p><code>${name}</code> is regular ES template string syntax and would normally be substituted
with the value of JavaScript variable <code>name</code>. Such simple substitution would be unsafe,
because it would make the query vulnerable to parameter injection. So we&rsquo;re also
using a template string generator function named <code>aqlQuery</code>. This function comes
bundled with ArangoDB 2.7.</p>

<p>Under the hood, <code>aqlQuery</code> will create regular AQL bind parameters for each occurrence
of a template string parameter. It will keep the query string and the actual bind
parameter values separate, so it is safe to use.</p>

<p>The function will return an object with that can directly be passed on to the
<code>db._query()</code> function. Here&rsquo;s what <code>aqlQuery</code> will generate for the above example
(note: some whitespace was removed from the output):</p>

<p>```js
{
  &ldquo;query&rdquo; : &ldquo;FOR doc IN collection FILTER doc.name == @value0 RETURN doc._key&rdquo;,
  &ldquo;bindVars&rdquo; : {</p>

<pre><code>"value0" : "test" 
</code></pre>

<p>  }
}
```</p>

<p>The <code>aqlQuery</code> template string generator function is available in 2.7, which is
currently in development. The changes are contained in the <code>devel</code> branch only
at the moment, but will become available in following 2.7 release. A pull request
has been issued to have the cookbook recipes updated to include <code>aqlQuery</code>, too.</p>

<p><code>aqlQuery</code> can be used in 2.7 from the ArangoShell, inside arangod (e.g. from inside
Foxx actions) and from ArangoDB&rsquo;s web interface.</p>

<p>All other variants for building AQL queries are still fully supported.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing RETURN DISTINCT]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/27/introducing-return-distinct/"/>
    <updated>2015-07-27T11:48:41+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/27/introducing-return-distinct</id>
    <content type="html"><![CDATA[<p>Last week saw the addition of the <code>RETURN DISTINCT</code> for AQL queries.
This is a new shortcut syntax for making result sets unique.</p>

<p>For this purpose it can be used as an easier-to-memorize alternative for
the already existing <code>COLLECT</code> statement. <code>COLLECT</code> is very flexible and
can be used for multiple purposes, but it is syntactic overkill for making
a result set unique.</p>

<p>The new <code>RETURN DISTINCT</code> syntax makes queries easier to write and understand.</p>

<!-- more -->


<p>Here&rsquo;s a non-scientific proof for this claim:</p>

<p>Compare the following queries, which both return each distinct <code>age</code> attribute
value from the collection:</p>

<p><code>plain making result set unique using COLLECT
FOR doc IN collection
  COLLECT age = doc.age
  RETURN age
</code></p>

<p><code>plain making result set unique using RETURN DISTINCT
FOR doc IN collection
  RETURN DISTINCT doc.age
</code></p>

<p>Clearly, the query using <code>RETURN DISTINCT</code> is more intuitive, especially for
AQL beginners. Apart from that, using <code>RETURN DISTINCT</code> will save a bit of typing
compared to the longer <code>COLLECT</code>-based query.</p>

<p>Internally both <code>COLLECT</code> and <code>RETURN DISTINCT</code> will work by creating an
<code>AggregateNode</code>. The optimizer will try the <em>sorted</em> and the <em>hashed</em> variants
for both, so they should perform about the same.</p>

<p>However, the result of a <code>RETURN DISTINCT</code> does not have any guaranteed order,
so the optimizer will not insert a post-<code>SORT</code> for it. It may do so for a regular
<code>COLLECT</code>.</p>

<p>As mentioned before, <code>COLLECT</code> is more flexible than <code>RETURN DISTINCT</code>.
Notably, <code>COLLECT</code> is superior to <code>RETURN DISTINCT</code> when the result set should
be made unique using more than one criterion, e.g.</p>

<p><code>plain using more than one criterion for uniqueness
FOR doc IN collection
  COLLECT status = doc.status, age = doc.age,
  RETURN { status, age }
</code></p>

<p>This is currently not achievable via <code>RETURN DISTINCT</code>, as it only works
with a single criterion.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AQL Object Literal Simplification]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/27/aql-object-literal-simplification/"/>
    <updated>2015-07-27T11:33:09+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/27/aql-object-literal-simplification</id>
    <content type="html"><![CDATA[<p>ArangoDB&rsquo;s <code>devel</code> branch recently saw a change that makes writing
some AQL queries a bit simpler.</p>

<p>The change introduces an optional shorthand notation for object attributes
in the style of ES6&rsquo;s enhanced object literal notation.</p>

<!-- more -->


<p>For example, consider the following query that groups values by <code>age</code>
attribute and counts the number of documents per distinct <code>age</code> value:</p>

<p><code>plain example query
FOR doc IN collection
  COLLECT age = doc.age WITH COUNT INTO length
  RETURN { age: age, length: length }
</code></p>

<p>The object declaration in the last line of the query is somewhat redundant
because one has to type identical attribute names and values:</p>

<p><code>plain the long notation for object literals
RETURN { age: age, length: length }
</code></p>

<p>In this case, the new shorthand notation simplifies the <code>RETURN</code> to:</p>

<p><code>plain using shorthand notation for object literals
RETURN { age, length }
</code></p>

<p>In general, the shorthand notation can be used for all object literals when
there is an attribute name that refers to a query variable of the same name.</p>

<p>It can also be mixed with the longer notation, e.g.:</p>

<p><code>plain mixing long and shorthand notation
RETURN { age, length, dateCreated: DATE_NOW() }
</code></p>
]]></content>
  </entry>
  
</feed>
