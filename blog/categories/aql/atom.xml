<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: AQL | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/aql/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2015-07-28T23:34:59+02:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introducing RETURN DISTINCT]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/27/introducing-return-distinct/"/>
    <updated>2015-07-27T11:48:41+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/27/introducing-return-distinct</id>
    <content type="html"><![CDATA[<p>Last week saw the addition of the <code>RETURN DISTINCT</code> for AQL queries.
This is a new shortcut syntax for making result sets unique.</p>

<p>For this purpose it can be used as an easier-to-memorize alternative for
the already existing <code>COLLECT</code> statement. <code>COLLECT</code> is very flexible and
can be used for multiple purposes, but it is syntactic overkill for making
a result set unique.</p>

<p>The new <code>RETURN DISTINCT</code> syntax makes queries easier to write and understand.</p>

<!-- more -->


<p>Here&rsquo;s a non-scientific proof for this claim:</p>

<p>Compare the following queries, which both return each distinct <code>age</code> attribute
value from the collection:</p>

<p><code>plain making result set unique using COLLECT
FOR doc IN collection
  COLLECT age = doc.age
  RETURN age
</code></p>

<p><code>plain making result set unique using RETURN DISTINCT
FOR doc IN collection
  RETURN DISTINCT doc.age
</code></p>

<p>Clearly, the query using <code>RETURN DISTINCT</code> is more intuitive, especially for
AQL beginners. Apart from that, using <code>RETURN DISTINCT</code> will save a bit of typing
compared to the longer <code>COLLECT</code>-based query.</p>

<p>Internally both <code>COLLECT</code> and <code>RETURN DISTINCT</code> will work by creating an
<code>AggregateNode</code>. The optimizer will try the <em>sorted</em> and the <em>hashed</em> variants
for both, so they should perform about the same.</p>

<p>However, the result of a <code>RETURN DISTINCT</code> does not have any guaranteed order,
so the optimizer will not insert a post-<code>SORT</code> for it. It may do so for a regular
<code>COLLECT</code>.</p>

<p>As mentioned before, <code>COLLECT</code> is more flexible than <code>RETURN DISTINCT</code>.
Notably, <code>COLLECT</code> is superior to <code>RETURN DISTINCT</code> when the result set should
be made unique using more than one criterion, e.g.</p>

<p><code>plain using more than one criterion for uniqueness
FOR doc IN collection
  COLLECT status = doc.status, age = doc.age,
  RETURN { status, age }
</code></p>

<p>This is currently not achievable via <code>RETURN DISTINCT</code>, as it only works
with a single criterion.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AQL Object Literal Simplification]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/27/aql-object-literal-simplification/"/>
    <updated>2015-07-27T11:33:09+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/27/aql-object-literal-simplification</id>
    <content type="html"><![CDATA[<p>ArangoDB&rsquo;s <code>devel</code> branch recently saw a change that makes writing
some AQL queries a bit simpler.</p>

<p>The change introduces an optional shorthand notation for object attributes
in the style of ES6&rsquo;s enhanced object literal notation.</p>

<!-- more -->


<p>For example, consider the following query that groups values by <code>age</code>
attribute and counts the number of documents per distinct <code>age</code> value:</p>

<p><code>plain example query
FOR doc IN collection
  COLLECT age = doc.age WITH COUNT INTO length
  RETURN { age: age, length: length }
</code></p>

<p>The object declaration in the last line of the query is somewhat redundant
because one has to type identical attribute names and values:</p>

<p><code>plain the long notation for object literals
RETURN { age: age, length: length }
</code></p>

<p>In this case, the new shorthand notation simplifies the <code>RETURN</code> to:</p>

<p><code>plain using shorthand notation for object literals
RETURN { age, length }
</code></p>

<p>In general, the shorthand notation can be used for all object literals when
there is an attribute name that refers to a query variable of the same name.</p>

<p>It can also be mixed with the longer notation, e.g.:</p>

<p><code>plain mixing long and shorthand notation
RETURN { age, length, dateCreated: DATE_NOW() }
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AQL Improvements for 2.7]]></title>
    <link href="http://jsteemann.github.io/blog/2015/06/17/aql-improvements-for-27/"/>
    <updated>2015-06-17T12:35:16+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/06/17/aql-improvements-for-27</id>
    <content type="html"><![CDATA[<p>With ArangoDB 2.6 being in beta already, it&rsquo;s time to look at some
features scheduled for 2.7. Today I&rsquo;ll showcase a few AQL parser
improvements that are present in the <code>devel</code> branch already, which will
be the foundation for the 2.7 release.</p>

<!-- more -->


<h2>Star operator</h2>

<p>The already existing star operator (<code>[*]</code>) is much more flexible in 2.7
than in previous ArangoDB versions. It now allows filtering the values it
iterates over, and optional projections.</p>

<p>These features will be demonstrated using the following example member data:</p>

<p><code>json example data for queries
[
  { "name" : "sir alfred", "age" : 60, "likes" : [ "lettuce", "tortoises" ] },
  { "name" : "mozquito", "age" : 15, "likes" : [ "skateboards", "music" ] },
  { "name" : "murphy", "age" : 28, "likes" : [ "juice", "tarts", "cakes" ] },
  { "name" : "helga", "age" : 52, "likes" : [ "home", "garden", "tortoises", "cakes" ] }
]
</code></p>

<p>To return all members with an age of 40 or higher and that also like tortoises,
we can now combine the star operator with an inline <code>FILTER</code> expression:</p>

<p><code>plain star operator with inline FILTER
RETURN @members[* FILTER CURRENT.age &gt;= 40 &amp;&amp; "tortoises" IN CURRENT.likes]
</code></p>

<p>The inline <code>FILTER</code> expression has access to the current array element via the
pseudo-variable <code>CURRENT</code>. The <code>FILTER</code> expression can thus access the element&rsquo;s
attributes and sub-attributes, and also use them in function expressions.</p>

<p>The above query will return only two array members as expected:</p>

<p><code>json
[
  { "name" : "sir alfred", "age" : 60, "likes" : [ "lettuce", "tortoises" ] },
  { "name" : "helga", "age" : 52, "likes" : [ "home", "garden", "tortoises", "cakes" ] }
]
</code></p>

<p>It&rsquo;s also possible to extract just a specific sub-attribute of each result value:</p>

<p><code>plain extracting just a sub-attribute
RETURN @members[* FILTER CURRENT.age &gt;= 40 &amp;&amp; "tortoises" IN CURRENT.likes].name
</code></p>

<p>This will return:</p>

<p><code>json query result
[
  "sir alfred",
  "helga"
]
</code></p>

<p>If we don&rsquo;t want to return the whole match but a single attribute is not enough, the
star operator can be used in combination with arbitrary projections, too.</p>

<p>The following query extracts the matching members a <code>FILTER</code> as above, but now only
returns each member&rsquo;s <code>age</code> attribute and the number of values in the member&rsquo;s <code>likes</code>
attribute:</p>

<p><code>plain extracting with a FILTER and a projection
RETURN @members[* FILTER CURRENT.age &gt;= 40 &amp;&amp; "tortoises" IN CURRENT.likes RETURN {
  name: CURRENT.name,
  likes: LENGTH(CURRENT.likes)
}]
</code></p>

<p>This will produce the following result:</p>

<p><code>json query result
[
  { "name" : "sir alfred", "likes" : 2 },
  { "name" : "helga", "likes" : 4 }
]
</code></p>

<p>If only a certain number of values is required, the star operator can be combined
with a <code>LIMIT</code> clause, too. This is useful for testing whether at least one of the
array members satisfies a <code>FILTER</code> condition:</p>

<p><code>plain limiting the number of results
RETURN @members[* FILTER "garden" IN CURRENT.likes LIMIT 1]
</code></p>

<p>Overall, the star operator is now much more powerful than before, so in many queries
it can replace full-blown <code>FOR</code> loops and subqueries when the goal simply is to iterate
over sub-parts of a result.</p>

<h2>Multi-star operator</h2>

<p>In 2.7 there is now also a <em>multi-star</em> operator (<code>[**]</code>). This operator can be used to
iterate over an array, too. In addition it will also flatten its input, so it can be used
for collapsing nested array structures.</p>

<p>This is useful in cases where a flat result is required but the single star operator would
return a nested array.</p>

<p>Consider this query with the single star operator:</p>

<p><code>plain extracting nested arrays
RETURN @members[* FILTER CURRENT.age &gt;= 40].likes[*]
</code></p>

<p>This will produce:</p>

<p><code>json result of single star query
[
  [ "lettuce", "tortoises" ],
  [ "home", "garden", "tortoises", "cakes" ]
]
</code></p>

<p>To get a collapsed array, we can employ the double star operator:</p>

<p><code>plain extracting flattend arrays
RETURN @members[* FILTER CURRENT.age &gt;= 40].likes[**]
</code></p>

<p>Then we&rsquo;ll get:</p>

<p><code>json result of double star query
[
  "lettuce",
  "tortoises",
  "home",
  "garden",
  "tortoises",
  "cakes"
]
</code></p>

<p>Note: the result of this query can also be made unique using the standard AQL
function <code>UNIQUE()</code>.</p>

<p>The star operator in 2.7 can have any number of levels. Using it with a single
star will simply iterate over the input array, using it with two stars will
collapse one level of the input, using it with three stars will collapse two
levels of the input etc.</p>

<h2>Subquery result usage</h2>

<p>While working on the AQL parser anyway, the grammar has been modified so
it allows a few more types of expressions.</p>

<p>For example, the result of a subquery can now be used as an array and the
subquery results can be accessed by position directly:</p>

<p>```plain accessing subquery results by position</p>

<pre><code>RETURN (
  FOR i IN [ 1, 2, 3 ] 
    RETURN i
)[0]
</code></pre>

<p>```</p>

<p>The trailing <code>[0]</code> led to a parse error in previous versions. To make this
work in previous versions, the subquery result needs to be captured in an
extra variable using <code>LET</code> before accessing the 0th member of that variable:</p>

<p>```plain workaround for accessing subquery results by position</p>

<pre><code>LET temp = (
  FOR i IN [ 1, 2, 3 ] 
    RETURN i
)
RETURN temp[0]
</code></pre>

<p>```</p>

<p>The parser generalizations now also allow to use the star operator directly
on a subquery result and access its individual members:</p>

<p>```plain expanding subquery results using star operator</p>

<pre><code>RETURN (
  FOR member IN [ 
    { name: "sir alfred" }, 
    { name: "mozquito" }
  ]
   RETURN member
)[*].name
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Speeding Up Array/object Literal Access]]></title>
    <link href="http://jsteemann.github.io/blog/2015/06/15/speeding-up-array-slash-object-literal-access/"/>
    <updated>2015-06-15T15:56:27+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/06/15/speeding-up-array-slash-object-literal-access</id>
    <content type="html"><![CDATA[<p>Last week some further optimization slipped into 2.6. The optimization can
provide significant speedups in AQL queries using huge array/object bind parameters
and passing them into V8-based functions.</p>

<!-- more -->


<p>It started with an ArangoDB user reporting a specific query to run unexpectedly slow.
The part of the query that caused the problem was simple and looked like this:</p>

<p><code>plain problematic query
FOR doc IN collection
  FILTER doc.attribute == @value
  RETURN TRANSLATE(doc.from, translations, 0)
</code></p>

<p>In the original query, <code>translations</code> was a big, constant object literal. Think of
something like the following, but with a lot more values:</p>

<p><code>json example translations value
{
  "p1" : 1,
  "p2" : 2,
  "p3" : 40,
  "p4" : 9,
  "p5" : 12
}
</code></p>

<p>The translations were used for replacing an attribute value in existing documents
with a lookup table computed outside the AQL query.</p>

<p>The number of values in the <code>translations</code> object was varying from query to query,
with no upper bound on the number of values. It was possible that the query was
running with 50,000 lookup values in the <code>translations</code> object.</p>

<p>When trying to reproduce the problem, we expected that the query would get at worst
<em>linearly</em> slower with an increasing number of lookup values. But in reality, the
following <em>non-linear</em> execution times were observed when increasing the number of
lookup values:</p>

<p>```plain execution times for varying input sizes, without optimization</p>

<h1>of values |  execution time</h1>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<pre><code>      1 |        0.6111 s
      2 |        0.6078 s  
      4 |        0.6021 s
      8 |        0.6160 s
     16 |        0.6925 s
     32 |        0.7107 s
     64 |        0.7677 s
    128 |        0.8576 s
    256 |        1.0544 s
    512 |        1.4579 s
   1024 |        8.8303 s
   2048 |       17.3674 s
   4096 |       35.3109 s
   8192 |       74.9161 s
  16384 |      145.0837 s
  32768 |      361.9870 s
  65536 |      880.4995 s
</code></pre>

<p>```</p>

<p>(note: all values stated above are wall-clock times for running the query with a
FILTER condition matching 50,000 documents &ndash; i.e. the <code>TRANSLATE()</code> expression was
executed 50,000 times per query)</p>

<p>With small objects passed in <code>translate</code>, the execution times only increased slowly
even when object sizes were doubled. The <code>TRANSLATE()</code> expression&rsquo;s share of the
overall query execution time was still low for small objects, even when doubling
their sizes. However, it got pretty bad for objects with 1,024 members already, and
from that point on, execution times more than doubled if object sizes got doubled.</p>

<p>The <code>TRANSLATE()</code> function itself has O(1) complexity, so we could rule it out as
the problem cause. However, <code>TRANSLATE()</code> is V8-based, and it turned out that there
was a problem when the number of values in the <code>translations</code> object increased from
1022 to 1023. At that particular threshold, execution time quadrupled.</p>

<p>At 1023 object members, V8 seems to change the internal object format, which probably
requires rearranging the object data internally. V8 has several <em>internal</em> types for
representing JavaScript objects, and converting between them is not free.</p>

<p>The obvious optimization opportunity for this case was to create the <code>translations</code>
object value just once as a V8 object, and reuse the same object when calling the
<code>TRANSLATE()</code> function repeatedly. This avoids repeated creation and destruction of
the V8 objects used in function calls, and as a side effect may also lead to less garbage
values being accumulated when functions are called repeatedly.</p>

<p>The optimization is possible here because the <code>translations</code> object is an object literal
and thus constant. It will also work for array literals and bind parameters (which
are also treated as literals once their values are known).</p>

<p>Here are the execution time for running the <code>TRANSLATE()</code> on 50,000 documents with the
modification:</p>

<p>```plain execution times, with optimization</p>

<h1>of values |  execution time</h1>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<pre><code>      1 |        0.6251 s
      2 |        0.6302 s  
      4 |        0.6138 s
      8 |        0.6141 s
     16 |        0.6685 s
     32 |        0.6232 s
     64 |        0.6204 s
    128 |        0.6326 s
    256 |        0.6460 s
    512 |        0.6275 s
   1024 |        0.6639 s
   2048 |        0.6345 s
   4096 |        0.6554 s
   8192 |        0.6789 s
  16384 |        0.7569 s
  32768 |        0.7636 s
  65536 |        1.0173 s
</code></pre>

<p>```</p>

<p>Looks like this is going to scale way better.</p>

<p>The optimization is disabled for big array/objects which are non-constant (e.g. a variable
or the result of an expression), or for parameters passed into user-defined AQL functions.
Enabling it for user-defined AQL functions is not safe because in theory these might
modify their arguments (and function arguments are passed by reference &ndash; passing them
by value would also defeat the purpose of the optimization).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On Getting Unique Values]]></title>
    <link href="http://jsteemann.github.io/blog/2015/06/01/on-getting-unique-values/"/>
    <updated>2015-06-01T13:27:13+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/06/01/on-getting-unique-values</id>
    <content type="html"><![CDATA[<p>While paging through the issues in the <a href="https://github.com/arangodb/arangodb">ArangoDB issue tracker</a>
I came across <a href="https://github.com/arangodb/arangodb/issues/987">issue #987</a>, titled
<em>Trying to get distinct document attribute values from a large collection fails</em>.</p>

<p>The issue was opened around 10 months ago when ArangoDB 2.2 was around. We improved AQL performance
somewhat since then, so I was eager to see how the query would perform in ArangoDB 2.6, especially
when comparing it to 2.2.</p>

<!-- more -->


<p>For reproduction I quickly put together some example data to run the query on:
<code>js setting up example data
var db = require("org/arangodb").db;
var c = db._create("test");
for (var i = 0; i &lt; 4 * 1000 * 1000; ++i) {
  c.save({ _key: "test" + i, value: (i % 100) });
}
require("internal").wal.flush(true, true);
</code></p>

<p>This produces a collection named <code>test</code> with 4 million documents. Each document has a numeric <code>value</code>
attribute, which in total has 100 unique values. I remembered from a conversation with the guy that
opened the issue that the number of distinct values was 100 or even slightly lower. I didn&rsquo;t bother
to create an index on the <code>value</code> attribute, which might have sped up the query.</p>

<p>With data available, it was time to run the query and measure its execution time:
<code>js running the query
var time = require("internal").time;
var start = time();
db._query("FOR doc IN test COLLECT value = doc.value RETURN value");
time() - start;
</code></p>

<p>Running this in 2.2.7 took 3 minutes and 18 seconds before bursting with the following error message:</p>

<p>```plain 2.2.7 error message
#</p>

<h1>Fatal error in CALL_AND_RETRY_2</h1>

<h1>Allocation failed &ndash; process out of memory</h1>

<p>#
```</p>

<p>In the 2.2 branch AQL queries were fully transformed to JavaScript and executed using V8. Obviously
that didn&rsquo;t work well with large collections. That was one of the reasons why version 2.3 saw a major
rewrite of the AQL engine.</p>

<p>As a consequence, running the query in 2.3 (2.3.5) worked fine. Execution took around 28 seconds.
The same was true for 2.4 (2.4.8) and 2.5 (2.5.5).</p>

<p>Finally, running the query in 2.6.0 completed in just 3.2 seconds.</p>

<p>The reasons for the speedup are the optimizations done for <code>COLLECT</code> (see
<a href="/blog/2015/04/22/collecting-with-a-hash-table/">COLLECTing with a hash table</a>, the
<a href="/blog/2015/05/04/return-value-optimization-for-aql/">Return value optimization for AQL</a> and some
minor optimizations within AQL that didn&rsquo;t get a pretty working title.</p>

<p>Looks like in sum all the optimizations put into 2.6 really pay out.</p>
]]></content>
  </entry>
  
</feed>
