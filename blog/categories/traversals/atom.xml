<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Traversals | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/traversals/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2015-01-30T00:13:40+01:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Custom Visitors in AQL Graph Traversals]]></title>
    <link href="http://jsteemann.github.io/blog/2015/01/28/using-custom-visitors-in-aql-graph-traversals/"/>
    <updated>2015-01-28T22:21:35+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/01/28/using-custom-visitors-in-aql-graph-traversals</id>
    <content type="html"><![CDATA[<p>This post is about some recent extensions for the AQL graph traversal functionality
in ArangoDB.</p>

<p>These extensions allow invoking user-defined JavaScript code for filtering
and results generation in AQL queries that contain traversals.</p>

<p>This should make AQL graph traversals much more powerful than before.
Additionally, AQL graph traversals get more configurable, allowing to write
traversal functions with control-flow logic and complex filtering. As a
side-effect, this change facilitates writing specialized traversal functions
with much higher efficiency than the general-purpose, cover-all-cases default
ones.</p>

<p>The extensions are currently available in the devel branch of ArangoDB, but will</p>

<!-- more -->


<h1>Example graph</h1>

<p>For all following examples, I&rsquo;ll be using a small example graph that can be set
up by running <a href="/downloads/code/world-graph-setup.js">this script</a> from the ArangoShell.</p>

<p>I have chosen this small graph because it is easy to understand and still complex
enough to demonstrate some common traversal use cases.</p>

<p>The example graph consists of the following two collections:</p>

<ul>
<li><code>v</code>: a collection with vertex documents.</li>
<li><code>e</code>: an edge collection containing the connections between vertices in <code>v</code></li>
</ul>


<p>All vertices in the graph have a <code>type</code> attribute, with types being either <code>root</code>,
<code>continent</code>, <code>country</code> or <code>capital</code>. The graph is a tree, so it has only one vertex
with type <code>root</code>. The root vertex is named <em>world</em>. Below the root there are only
vertices of type <code>continent</code>. These are also connected to some <code>country</code> vertices.
Finally, <code>country</code> vertices are also connected to <code>capital</code> vertices:</p>

<p><code>plain
root &lt;--[is in]-- continent &lt;--[is in]-- country &lt;--[is in]-- captial
</code></p>

<p>In the examples, we&rsquo;ll only look at the vertices and ignore what the connections
look like.</p>

<h1>Custom visitors</h1>

<p>We know the graph is a tree, so let&rsquo;s print its structure in a textual format
using AQL. We&rsquo;ll employ a <strong>custom visitor function</strong> for this. A custom visitor is
a user-defined callback function that is called for every vertex that is encountered
during a graph traversal. Custom visitor functions need to be written in JavaScript
and be registered once before they can be used from an AQL query.</p>

<p>Custom visitors have the following function signature:
<code>js visitor function signature
function (config, result, vertex, path)
</code></p>

<p>The function parameters have the following meanings:</p>

<ul>
<li><code>config</code>: the traversal configuration</li>
<li><code>result</code>: the result already generated by the traversal. This is important only
if the visitor is designed to modify an existing result in-place</li>
<li><code>vertex</code>: the currently visited vertex document</li>
<li><code>path</code>: the path from the start vertex to the currently visited vertex document.
The path will contain an array <code>vertices</code> and an array <code>edges</code></li>
</ul>


<p>Let&rsquo;s register a custom visitor named <code>myfunctions::structurePrinter</code>. This can done
by running the following code from the ArangoShell:</p>

<p>```js registering a custom visitor to print the tree structure
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex, path) {
  var indentation = Array(path.vertices.length).join(&ldquo;  &rdquo;);
  var label       = &ldquo;&ndash; &rdquo; + vertex.name + &ldquo; (&rdquo; + vertex.type + &ldquo;)&rdquo;;
  return indentation + label;
});
```</p>

<p>Now we can run the following AQL query to invoke the visitor:
<code>plain invoking the custom visitor
LET params = {
  visitor : "myfunctions::structurePrinter",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>The visitor will visit all vertices in the graph, starting at the vertex
<code>v/world</code> as specified. It will then follow incoming connections using a
depth-first search (this was not specified in the query as it is the default).</p>

<p>As we started with the root vertex of the graph, the query will visit all
vertices exactly once. Fortunately the example graph is a tree and does not
contain any cycles, so we do not have to care about how to make the traversal
terminate. The traversal will automatically terminate after it has visited all nodes.</p>

<p>The AQL query should produce something like this:</p>

<p><code>js query result
[
  "- World (root)",
  "  - North America (continent)",
  "    - Bahamas (country)",
  "      - Nassau (capital)",
  "    - Canada (country)",
  "      - Ottawa (capital)",
  "    - Antigua and Barbuda (country)",
  "      - Saint John's (capital)",
  "    - Barbados (country)",
  "      - Bridgetown (capital)",
  "  - Asia (continent)",
  "    - Afghanistan (country)",
  "      - Kabul (capital)",
  ...
]
</code></p>

<p>This should provide a good overview of the graph&rsquo;s contents.</p>

<p>To return the above result in a more structured manner, let&rsquo;s overwrite the
previous visitor function with one that returns the most interesting vertex
attributes individually:</p>

<p>```js registering another custom visitor to return the tree structure
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex, path) {
  return {</p>

<pre><code>name: vertex.name, 
type: vertex.type, 
level: path.vertices.length 
</code></pre>

<p>  };
});
```</p>

<p>Running the same AQL query will now return something like:</p>

<p>```js query result
[
  {</p>

<pre><code>"name" : "World", 
"type" : "root", 
"level" : 1 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "North America", 
"type" : "continent", 
"level" : 2 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Bahamas", 
"type" : "country", 
"level" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Nassau", 
"type" : "capital", 
"level" : 4 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Canada", 
"type" : "country", 
"level" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Ottawa", 
"type" : "capital", 
"level" : 4 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Antigua and Barbuda", 
"type" : "country", 
"level" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Saint John's", 
"type" : "capital", 
"level" : 4 
</code></pre>

<p>  },
  &hellip;
]
```</p>

<p>Now let&rsquo;s add some control flow to the visitor function. The following visitor
function will also return information about each vertex' parent &ndash; except for the
root vertex, which does not have a parent:</p>

<p>```js a custom visitor with simple control flow
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structureReturner&rdquo;, function (config, result, vertex, path) {
  var result = {</p>

<pre><code>name: vertex.name, 
type: vertex.type, 
level: path.vertices.length
</code></pre>

<p>  };
  if (path.vertices.length > 1) {</p>

<pre><code>result.parent = { 
  name: path.vertices[path.vertices.length - 2].name, 
  type: path.vertices[path.vertices.length - 2].type
}; 
</code></pre>

<p>  }
  return result;
});
```</p>

<p>Running our AQL query will now produce a different type of result for the root vertex
than for all the other vertices:</p>

<p>```js query result
[
  {</p>

<pre><code>"name" : "World", 
"type" : "root", 
"level" : 1 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "North America", 
"type" : "continent", 
"level" : 2, 
"parent" : { 
  "name" : "World", 
  "type" : "root" 
} 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Bahamas", 
"type" : "country", 
"level" : 3, 
"parent" : { 
  "name" : "North America", 
  "type" : "continent" 
} 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Nassau", 
"type" : "capital", 
"level" : 4, 
"parent" : { 
  "name" : "Bahamas", 
  "type" : "country" 
} 
</code></pre>

<p>  },
  &hellip;
]
```</p>

<h1>Filtering</h1>

<p>Now let&rsquo;s try to restrict the results of a graph traversal to just some vertices,
for example, all European countries. As we know the structure of the graph is quite
simple, the following naive approach will already do:</p>

<p>```js a custom visitor returning only European country names
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structureReturner&rdquo;, function (config, result, vertex, path) {
  if (path.vertices.length > 1 &amp;&amp;</p>

<pre><code>  path.vertices[path.vertices.length - 2].name === "Europe") {
return vertex.name; 
</code></pre>

<p>  }
});
```</p>

<p>But the above is clearly not ideal.</p>

<p>First of all, the traversal will still <strong>visit every vertex</strong> in the graph, even though
most vertices will not be returned. Ideally, one will want to restrict a traversal to
visit as few vertices as possible, especially in a big graph or in a graph that contains
cycles.</p>

<p>Second, the above visitor is looking into a vertex' direct parent for filtering. This
will work for graphs that have a rigid structure, but may not work in more complex setups.</p>

<p>We better use a dedicated function for filtering. Such function can control
if a given vertex is going to be visited (via calling the <em>visitor</em> function) and if its
connections should be followed. It can skip non-interesting vertices early, providing a
good way to make traversals more efficient.</p>

<p>A filter function can be specified in the <em>filter</em> attribute of the traversal options.
If specified, <em>filter</em> needs to contain the name of a custom AQL function. A filter
function again needs to be written in JavaScript and has the following signature:</p>

<p><code>js filter function signature
function (config, vertex, path)
</code></p>

<p>The filter function will be called for each vertex. It can return one of the
following values:</p>

<ul>
<li><code>"prune"</code>: visit the vertex, but do not descend into its connections</li>
<li><code>"exclude"</code>: do not visit the vertex, but do descend into its connections</li>
<li><code>[ "prune", "exclude" ]</code>: do not visit, and do not descend</li>
<li><code>undefined</code> (default): visit and descend</li>
</ul>


<p>The following filter function will return <code>"exclude"</code> for the root vertex, leading
to the visitor not being called for it. However, the traversal will still descend
into the connections of the root node.</p>

<p>On the next level, all continents will be enumerated. The filter will return
<code>[ "prune", "exclude" ]</code> for all continents but Europe, leading to the visitor not
being invoked for these continents, and their connections not being followed.
For the <em>Europe</em> vertex, it will return <code>"exclude"</code>,
meaning the visitor will not be called, but the traversal will descend into the
connections of <code>Europe</code>.</p>

<p>For all vertices of type <code>country</code>, the visitor will be
called. This is ok because the filter previously prevented the traversal from
descending into any other country but <em>Europe</em>.</p>

<p>Finally, the filter will return <code>"prune"</code> for all countries, meaning the traversal
will not descend into a country&rsquo;s connections (in this case that would be the captial vertices).
This will make the traversal end at the <code>country</code> level.</p>

<p>Here it is:</p>

<p>```js registering a filter for European countries
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::europeFilter&rdquo;, function (config, vertex, path) {
  if (vertex.type === &ldquo;country&rdquo;) {</p>

<pre><code>return "prune";
</code></pre>

<p>  }</p>

<p>  if (vertex.type === &ldquo;continent&rdquo;) {</p>

<pre><code>if (vertex.name !== "Europe") {
  return [ "prune", "exclude" ];
}
</code></pre>

<p>  }</p>

<p>  return &ldquo;exclude&rdquo;;
});
```</p>

<p>Putting the logic into the filter function allows using a very simple visitor:</p>

<p>```js a very simple visitor
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structureReturner&rdquo;, function (config, result, vertex) {
  return vertex.name;
});
```</p>

<p>We must also slightly extend our AQL query and tell it to use our custom filter function:
<code>plain invoking the custom visitor and the custom filter
LET params = {
  filter : "myfunctions::europeFilter",
  visitor : "myfunctions::structurePrinter",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>Running the adjusted AQL query should produce something like:
<code>js query results
[
  "Austria",
  "Croatia",
  "Bosnia and Herzegovina",
  "Andorra",
  "Bulgaria",
  ...
]
</code></p>

<p>Custom filter functions are a very general approach. Obviously much more complex tasks
than shown here can be achieved with them. We have often been asked for ways to set up
complex filter conditions in AQL traversals, and I hope these custom filter functions
will cover most of that.</p>

<h1>Special visitors</h1>

<p>Traversal depths can be controlled with the general configuration parameters
<code>minDepth</code> and <code>maxDepth</code>. These parameters are helpful to make the traversal only
include vertices occurring after the specified distance from the start vertex, or
up to the specified distance away from the start vertex. This helps bounding
traversals, but is not flexible enough when handling graphs with very distinct
path lengths.</p>

<p>For example, <strong>finding leaf nodes</strong> in a graph is quite hard using a default
traversal. The <em>filter</em> function cannot be used to find leaf nodes, because
<em>filter</em> is called before a vertex' connections are determined. The same is true
for visitor functions. There were not provided any information about whether the
currently visited vertex has connections or not. All a visitor could previously do
to find leaf nodes is to return each visited vertex along with the full path information.
Some post-processing of the traversal result with regular AQL was then required to
detect the leaf nodes in that result.</p>

<p>This could easily get inefficient, especially in a big graphs for which the intermediate
results created by the default traversal visitor grew beyond reasonable sizes.</p>

<p>We therefore added a mechanism that can pass information about the vertex' connections
to the visitor. This allows writing new types of visitor functions. For example, it
makes it easy to write visitors that can return only leaf nodes.</p>

<p>In order to have the traversal pass the currently visited vertex' connections to the
visitor function, the traversal parameter <code>order</code> must be set to a value of <code>"preorder-expander"</code>.
The traversal&rsquo;s visitor function will then be called with an additional fifth
parameter named <code>connected</code>, which is an array of the connections of the current
vertex. This array will be empty if the traversal&rsquo;s expander function did not
find any connections for the vertex.</p>

<p>Here&rsquo;s a simple visitor that will make a traversal return only all leaf nodes:</p>

<p>```js a visitor that receives information about connections, too
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::leafNodeVisitor&rdquo;, function (config, result, vertex, path, connected) {
  if (connected &amp;&amp; connected.length === 0) {</p>

<pre><code>return vertex.name + " (" + vertex.type + ")";
</code></pre>

<p>  }
});
```</p>

<p>And here&rsquo;s an AQL query that shows how to use this type of visitor:</p>

<p><code>plain invoking the leaf node visitor
LET params = {
  order : "preorder-expander",
  visitor : "myfunctions::leafNodeVisitor",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>As a result, the above query will only print vertices of type <code>capital</code>
(because those are the only leaf nodes in the graph).</p>

<p>The nice thing when looking at the custom visitor function is that it only
filters on the number of connections, but not on vertex type or anything else
specific for this type of graph.</p>

<p>So it seems like the above function is general purpose and can be reused for
other graphs, too.</p>

<h1>Passing parameters into visitors</h1>

<p>It is often useful to pass own parameters into function to provide some sort
of invocation context. For example, the purpose of the following visitor function
is to return an object with only certain attributes of each visited vertex:</p>

<p>```js a visitor that can return arbitrary vertex attributes:
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::attributesReturner&rdquo;, function (config, result, vertex) {
  var values = { };
  if (typeof config.data === &ldquo;object&rdquo; &amp;&amp; Array.isArray(config.data.attributes)) {</p>

<pre><code>config.data.attributes.forEach(function (attribute) {
  values[attribute] = vertex[attribute];
});
</code></pre>

<p>  }
  return values;
});
<code>``
Which attributes the function will return can be configured by passing in an
array of attribute names in the</code>config<code>parameter's</code>data<code>sub-attribute. Here's
an AQL query that will configure the visitor to return</code>_id<code>and</code>type`:</p>

<p>```plain invoking the attributes visitor
LET params = {
  visitor : &ldquo;myfunctions::attributesReturner&rdquo;,
  visitorReturnsResults : true,
  data: {</p>

<pre><code>attributes: [ "_id", "type" ] 
</code></pre>

<p>  }<br/>
}
FOR result IN TRAVERSAL(v, e, &ldquo;v/world&rdquo;, &ldquo;inbound&rdquo;, params)
  RETURN result
```</p>

<h1>Aggregation</h1>

<p>Let&rsquo;s say we wanted to count the number of vertices per type. As standard AQL supports
aggregation, this is easy to do without custom visitor functions. All we need to do is to
return each vertex' <code>type</code> attribute from a traversal, pass that through <code>COLLECT...COUNT</code>
and finally return the aggregated results:</p>

<p>```plain aggregation example using COLLECT on a TRAVERSAL result
FOR result IN TRAVERSAL(v, e, &ldquo;v/world&rdquo;, &ldquo;inbound&rdquo;)
  COLLECT vertexType = result.vertex.type WITH COUNT INTO vertexCount
  RETURN {</p>

<pre><code>type: vertexType, 
count: vertexCount 
</code></pre>

<p>  }
```</p>

<p>The problem with this is that the call to <code>TRAVERSAL</code> can produce a very big intermediate
result if the graph is big. By default, <code>TRAVERSAL</code> will follow all connections, and put
all visited vertices and path information into its result. This can get out of hand size-wise
and use lots of resources. If all we want is to count the number of vertices per type, we
won&rsquo;t be interested in all the details a default traversal will produce, so we need something
that creates only very small results.</p>

<p>For this task, we can create a very specialized visitor function that will be very efficient:</p>

<p>```js registering a visitor that counts vertices by type
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::vertexTypeCounter&rdquo;, function (config, result, vertex) {
  if (result.length === 0) {</p>

<pre><code>result.push({ });
</code></pre>

<p>  }
  var vertexType = vertex.type;
  if (! result[0].hasOwnProperty(vertexType)) {</p>

<pre><code>result[0][vertexType] = 1;
</code></pre>

<p>  }
  else {</p>

<pre><code>result[0][vertexType]++;
</code></pre>

<p>  }
});
```</p>

<p>Our invocation AQL query looks like this:
<code>plain invoking the vertex type counter
LET params = {
  visitor : "myfunctions::vertexTypeCounter",
  visitorReturnsResults : false
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>One important thing to note is that the <em>visitorReturnsResults</em> traversal parameter was set to
<em>false</em>. This means that the visitor function will not return any values. This is intentional.</p>

<p>Instead, this visitor will be modifying the traversal&rsquo;s result incrementally, in place.
In the beginning, there won&rsquo;t be any result, so the visitor will be pushing an empty object into it.
This object will contain the counters, with the type names as attribute keys. For every vertex
type encountered, a key will be created in this object and initialized with 1. If the key
already existed, it will be incremented.</p>

<p>The final result of this visitor for the example graph will be:
```js query result
[
  {</p>

<pre><code>"root" : 1, 
"continent" : 6, 
"country" : 40, 
"capital" : 40 
</code></pre>

<p>  }
]
```</p>

<p>Not only is this the final result of the AQL query, but also the intermediate result that the
<code>TRAVERSAL</code> has produced. Cleary this will not cost as much memory as if the <code>TRAVERSAL</code> had
copied all visited vertex data and paths to them into the intermediate result.</p>
]]></content>
  </entry>
  
</feed>
