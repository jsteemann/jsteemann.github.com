<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ArangoDB | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/arangodb/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2015-02-07T18:04:14+01:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using ArangoDB as a Logstash Output]]></title>
    <link href="http://jsteemann.github.io/blog/2015/02/05/using-arangodb-as-a-logstash-output/"/>
    <updated>2015-02-05T23:39:23+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/02/05/using-arangodb-as-a-logstash-output</id>
    <content type="html"><![CDATA[<p>Inspired by a question on <a href="http://stackoverflow.com/questions/28314711/logstash-output-for-arangodb">StackOverflow</a>,
I did some investigation about how to make <a href="http://www.elasticsearch.org/overview/logstash/">Logstash</a>
send log events to ArangoDB.</p>

<p>There is no dedicated Logstash output plugin for ArangoDB on the
<a href="https://github.com/logstash-plugins">Logstash plugins page</a>, so I had already accepted to write
one on my own.</p>

<p>Browsing the plugins page for inspiration, I found an
<a href="https://github.com/logstash-plugins/logstash-output-http">HTTP output plugin for Logstash</a>.
It seems to be general enough that it can send the log event in JSON format to any HTTP-speaking backend.</p>

<p>ArangoDB&rsquo;s API is JSON over HTTP, so it sounded like a perfect match. I briefly tried it out and
it seemed to work fine.</p>

<!-- more -->


<p>Here are the steps I carried out to connect the two:</p>

<h2>Prepare an ArangoDB server</h2>

<p>I started an ArangoDB server with default configuration (binding to IP address 127.0.0.1 and port
8529). I then used the ArangoShell to create a collection named <code>logstash</code>:</p>

<p><code>js
db._create("logstash");
</code></p>

<p>This collection will be used for storing the log events sent by Logstash.</p>

<h2>Download Logstash</h2>

<p>In order to run Logstash, you must have Java installed, which I assume you already have.</p>

<p>Now it&rsquo;s time to download Logstash. You can download and unpack it with the command following.
The current version is 1.5.0 beta1 (<strong>warning: 100 MB download!</strong>):</p>

<p><code>bash
wget "http://download.elasticsearch.org/logstash/logstash/logstash-1.5.0.beta1.tar.gz"
tar xvfz logstash-1.5.0.beta1.tar.gz
cd Downloads/logstash-1.5.0.beta1
</code></p>

<h2>Connecting Logstash with ArangoDB</h2>

<p>We are now ready to start Logstash. I&rsquo;ll start it in a mode that will send all input from
stdin as log events to ArangoDB. I am using the <code>stdin</code> input plugin, and the <code>http</code> output
plugin for this. The <code>http</code> output plugin needs to know the URL to send the log events to.</p>

<p>The URL is ArangoDB&rsquo;s base URL plus the REST API method for storing a single document, with
the name of the target collection (<code>logstash</code>) appended.</p>

<p>Here is the full command:</p>

<p><code>bash
bin/logstash -e 'input { stdin } } output { http { http_method =&gt; "post" url =&gt; "http://127.0.0.1:8529/_api/document?collection=logstash" format =&gt; "json" } }'
</code></p>

<p>Logstash may need a few seconds to start. The HTTP plugin will print a message about itself
being a milestone 1 release only, but it works. Anything entered in the terminal should now be
sent as a log event to ArangoDB.</p>

<p>For example, type <code>fingers crossed!</code> and hit enter:</p>

<p><code>
Using milestone 1 output plugin 'http'. This plugin should work, but would benefit from use by folks like you. Please let us know if you find bugs or have suggestions on how to improve this plugin.  For more information on plugin milestones, see http://logstash.net/docs/1.5.0.beta1/plugin-milestones {:level=&gt;:warn}
fingers crossed!
</code></p>

<p>Let&rsquo;s check if the log event made it into ArangoDB. I have used the ArangoShell for this:</p>

<p>```js
db.logstash.toArray()
[
  {</p>

<pre><code>"_id" : "logstash/3507690866496", 
"_key" : "3507690866496", 
"_rev" : "3507690866496", 
"@version" : "1", 
"host" : "kalk", 
"message" : "fingers crossed!", 
"@timestamp" : "2015-02-05T23:17:39.982Z" 
</code></pre>

<p>  }
]
```</p>

<h3>Querying log events</h3>

<p>So we&rsquo;re getting log events in from Logstash.</p>

<p>We can use AQL to query the received log events in ArangoDB. But before we run a query,
we probably want to index the <code>@timestamp</code> attribute of the events, so we can efficiently
find and filter them by date and time:</p>

<p><code>js
db.logstash.ensureSkiplist("@timestamp");
</code></p>

<p>Now we can run the following AQL query to find the latest 5 log events:</p>

<p><code>plain
FOR l IN logstash
  FILTER l.`@timestamp` &lt;= '2099' /* arbitrary max value */
  SORT l.`@timestamp` DESC
  LIMIT 5
  RETURN l
</code></p>

<p>Note: the <code>@timestamp</code> attribute name needs to be enclosed in backticks because a <code>@</code> prefix
is used to designate bind parameters in AQL. Enclosing the names in backticks will make AQL treat
them as attribute name literals.</p>

<p>For the simple types of events triggered by the <code>stdin</code> input plugin, this is already sufficient.
However, log events may look different, depending on the type of input plugins that are used. For
other inputs, other attributes may need to be indexed, too.</p>

<h3>Adjusting IP, port and authentication</h3>

<p>Above I have used the default configuration of ArangoDB, that is IP 127.0.0.1, port 8529, and no
authentication. You probably want to change this.</p>

<p>To make ArangoDB listen on any other IP address or port, change the <code>endpoint</code> setting in its
configuration file <code>/etc/arangod.conf</code>. You may also want to set the <code>disable-authentication</code>
flag to <code>false</code>, meaning authentication is turned on.</p>

<p><code>
[server]
endpoint = tcp://192.168.173.13:9999
disable-authentication = false
</code></p>

<p>Before activating the new configuration, let&rsquo;s create a dedicated ArangoDB user <code>logstash</code>.
I will also change the default password of the <code>root</code> user. The following ArangoShell commands
do this:</p>

<p><code>js
require("org/arangodb/users").save("logstash", "secret-logging", true);
require("org/arangodb/users").save("root", "nobody-will-ever-guess", true);
</code></p>

<p>To make logstash use the above settings, we have to adjust the command-line:</p>

<p><code>bash
bin/logstash -e 'input { stdin } } output { http { http_method =&gt; "post" url =&gt; "http://logstash:secret-logging@192.168.173.13:9999/_api/document?collection=logstash" format =&gt; "json" } }'
</code></p>

<h3>Pitfalls</h3>

<p>Though Logstash itself can write a logfile (<code>--log</code> option) and can provide debug information
(<code>--debug</code>), I did not get it log or print errors when misconfiguring the HTTP output plugin.
For example, specifying a wrong target URL will make all HTTP requests from Logstash to ArangoDB
silently fail, with the log events being lost if not stored elsewhere.</p>

<p>Maybe this is configurable somewhere, but then I didn&rsquo;t find it. It is also possible that this
will be fixed in some future release.</p>

<h3>Disclaimer</h3>

<p>Please feel free to use this blog as a starting point but not as an endorsement.</p>

<p>Though I think it will work perfectly, I am not at all an expert for Logstash or its plugins.
I didn&rsquo;t spend much time with it yet, and I may have overlooked important things. So should you
be interested in using it, please conduct your own tests first.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Dynamic Attribute Names in AQL]]></title>
    <link href="http://jsteemann.github.io/blog/2015/02/03/using-dynamic-attribute-names-in-aql/"/>
    <updated>2015-02-03T00:12:39+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/02/03/using-dynamic-attribute-names-in-aql</id>
    <content type="html"><![CDATA[<p>On our mailing list, there is quite often the question whether attribute names in objects
returned from AQL queries can be made dynamic.</p>

<p>Here&rsquo;s a (non-working) example query for this:</p>

<p><code>plain example query that does not work
FOR doc IN collection
  RETURN { doc.type : doc.value }
</code></p>

<p>The intention in the above query obviously is to use the dynamic value from <code>doc.type</code> as
an attribute name in the result object and not to have an attribute named <code>"doc.type"</code>. This
feature is probably in the top 20 of the most-often wished features.</p>

<!-- more -->


<p>However, the above query won&rsquo;t even parse. The AQL grammar only allows string values
left of the colon in an object definition. Non-quoted strings are allowed there too, and are
implicitly turned into quoted strings. It works similar to how object literals are defined
in JavaScript:</p>

<p><code>plain using unquoted and quoted string attribute names
RETURN {
  foo : "bar",
  "baz" : "qux"
}
</code></p>

<p>Why not allow arbitrary expression left of the colon? The reason is simple: this would cause
ambiguity and probably have side-effects. For an example, have a look at the following query:</p>

<p><code>plain which attribute name to use here?
FOR doc IN collection
  LET type = doc.type;
  RETURN { type : doc.value }
</code></p>

<p>If the <code>type</code> attribute name inside the object definition is interpreted as a string literal
as it currently is an AQL (and always was), then the resulting attribute name is just <code>"type"</code>.</p>

<p>If the <code>type</code> attribute name would now be intepreted as an expression, it would get the value
that was assigned to the variable <code>type</code> by the <code>LET</code> statement. Removing the <code>LET</code> from the
query would change the attribute name in the result back to the string literal <code>"type"</code>.</p>

<p>The ambiguity could be solved by telling the parser what to do in such cases. While technically
this could be working, I think it may have too many unintended side-effects. I already mentioned
that introducing a <code>LET</code> statement into the query would change the attribute name in the result.
The same could also happen if a collection named <code>type</code> was added to the query. And it would
break compatibility with existing queries.</p>

<p>JavaScript has the same problem, and it wasn&rsquo;t solved portably yet. However, there is a proposal
for ES6 that suggests enclosing attribute name expressions in <code>[</code> and <code>]</code>.</p>

<p>To me, this looks like a good solution for the problem. It&rsquo;s two bytes more when keying in
queries, but the syntax is easy and explicit. There are no ambiguities.</p>

<p>I prototyped this solution for AQL, so I could write:</p>

<p>```plain query using dynamic attribute names
FOR i IN 1..5
  RETURN {</p>

<pre><code>[ CONCAT('test', i) ] : i, 
[ SUBSTITUTE(CONCAT('i is ', (i &lt;= 3 ? 'small' : 'not small')), { ' ' :  '_' } ) ] : i 
</code></pre>

<p>  }</p>

<p>[
  {</p>

<pre><code>"test1" : 1, 
"i_is_small" : 1 
</code></pre>

<p>  },
  {</p>

<pre><code>"test2" : 2, 
"i_is_small" : 2 
</code></pre>

<p>  },
  {</p>

<pre><code>"test3" : 3, 
"i_is_small" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"test4" : 4, 
"i_is_not_small" : 4 
</code></pre>

<p>  },
  {</p>

<pre><code>"test5" : 5, 
"i_is_not_small" : 5 
</code></pre>

<p>  }
]
```</p>

<p>I ran a few queries with this, and they seemed to work. <del>However, I haven&rsquo;t
committed the feature yet. There might still be cases in which it doesn&rsquo;t work. Tests
for the feature are also still missing. I hope I can finalize the implementation soon
so it becomes available in some release.</del></p>

<p><strong>UPDATE</strong>: tests have been added now, and there has been committed in devel. It will
be included in AranoDB 2.5.</p>

<p>Everyone is welcome to try it out already!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[YAOR - Yet Another Optimizer Rule]]></title>
    <link href="http://jsteemann.github.io/blog/2015/01/31/yaor-yet-another-optimizer-rule/"/>
    <updated>2015-01-31T18:51:30+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/01/31/yaor-yet-another-optimizer-rule</id>
    <content type="html"><![CDATA[<p>A quick post that showcases the new optimizer rule <code>move-calculations-down</code> that was added
in ArangoDB 2.5 (current <code>devel</code> branch).</p>

<!-- more -->


<p>Consider the following simple query:</p>

<p><code>plain Example query
FOR doc IN test
  LET calculated = CONCAT('foo', doc.value)
  FILTER doc.value &lt; 100
  RETURN calculated
</code></p>

<p>If no indexes are present in collection <code>test</code>, the execution plan will look
like this in 2.4:</p>

<p><img src="/downloads/screenshots/explain-24.png"></p>

<p>The plan can be improved a bit. While there are no indexes to exploit, the calculation
for <code>calculated</code> can be pushed beyond the execution of the <code>FILTER</code>. This will be very
beneficial if the calculation is expensive and the <code>FILTER</code> can prune a lot of documents.</p>

<p>In 2.5, there is an optimizer rule <code>move-calculations-down</code> that will do this. It will
move all eligible calculations as far down in the plan as possible. A calculation obviously can
be moved down a step only if the successor step does not depend on its result.</p>

<p>Additionally, a calculation will not be moved beyond a <code>COLLECT</code> operation, because
<code>COLLECT</code> changes which variables are visible in a scope. Finally, a calculation will not
be moved down inside a <code>FOR</code> loop, in order to avoid repeated calculations.</p>

<p>In the example query, the step following the <code>LET</code> calculation was a <code>FILTER</code>.
The filter condition does not depend on the result of <code>calcuated</code>, so the calculation is
eligible for being moved down.</p>

<p>The resulting execution plan will look like this in 2.5:</p>

<p><img src="/downloads/screenshots/explain-25.png"></p>

<p>As we can see from the changed id sequence on the left, the calculation was moved down.</p>

<p>What does this buy us? For the simple query above, with the <code>test</code> collection containing
100.000 documents with <code>value</code> ranging from 0 to 99,999, the results are as follows:</p>

<ul>
<li>if the filter leaves only 0.1 % of the documents pass, execution time goes down from
0.87 seconds to 0.17 seconds thanks to the rule</li>
<li>if the filter lets 1 % of the documents pass, execution time is 0.21 seconds with the rule,
and 0.91 without</li>
<li>if the filter lets 10 % of the documents pass, execution time is 0.25 s, vs. 0.91 seconds
without.</li>
<li>if the filter lets all documents pss, there is no difference in execution time</li>
</ul>


<p>This is quite a nice speedup, especially when taking into account how simple the optimizer
rule is. The effects may be even greater for queries that contain multiple calculations
that can be pushed beyond filters, or for more expensive calculations.</p>

<p>Of course the best solution for the above query would be to use a skiplist index on
<code>value</code>, but that&rsquo;s a different story. The optimizer rule shown here is orthogonal to
using indexes, so queries already using indexes might still benefit from the rule if they
contain additional calculations or further filters which cannot be satifisfied by indexes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Custom Visitors in AQL Graph Traversals]]></title>
    <link href="http://jsteemann.github.io/blog/2015/01/28/using-custom-visitors-in-aql-graph-traversals/"/>
    <updated>2015-01-28T22:21:35+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/01/28/using-custom-visitors-in-aql-graph-traversals</id>
    <content type="html"><![CDATA[<p>This post is about some recent extensions for the AQL graph traversal functionality
in ArangoDB.</p>

<p>These extensions allow invoking user-defined JavaScript code for filtering
and results generation in AQL queries that contain traversals.</p>

<p>This should make AQL graph traversals much more powerful than before.
Additionally, AQL graph traversals get more configurable, allowing to write
traversal functions with control-flow logic and complex filtering. As a
side-effect, this change facilitates writing specialized traversal functions
with much higher efficiency than the general-purpose, cover-all-cases default
ones.</p>

<p>The extensions are currently available in the devel branch of ArangoDB on in the
2.4 branch (with 2.4.2 being the first release to include them).</p>

<!-- more -->


<h1>Example graph</h1>

<p>For all following examples, I&rsquo;ll be using a small example graph that can be set
up by running <a href="/downloads/code/world-graph-setup.js">this script</a> from the ArangoShell.</p>

<p>I have chosen this small graph because it is easy to understand and still complex
enough to demonstrate some common traversal use cases.</p>

<p>The example graph consists of the following two collections:</p>

<ul>
<li><code>v</code>: a collection with vertex documents</li>
<li><code>e</code>: an edge collection containing the connections between vertices in <code>v</code></li>
</ul>


<p>All vertices in the graph have a <code>type</code> attribute, with types being either <code>root</code>,
<code>continent</code>, <code>country</code> or <code>capital</code>. The graph is a tree, so it has only one vertex
with type <code>root</code>. The root vertex is named <em>world</em>. Below the root there are only
vertices of type <code>continent</code>. These are also connected to some <code>country</code> vertices.
Finally, <code>country</code> vertices are also connected to <code>capital</code> vertices:</p>

<p><code>plain
root &lt;--[is in]-- continent &lt;--[is in]-- country &lt;--[is in]-- capital
</code></p>

<p>In the examples, we&rsquo;ll only look at the vertices and ignore what the connections
look like.</p>

<h1>Custom visitors</h1>

<p>We know the graph is a tree, so let&rsquo;s print its structure in a textual format
using AQL. We&rsquo;ll employ a <strong>custom visitor function</strong> for this. A custom visitor is
a user-defined callback function that is called for every vertex that is encountered
during a graph traversal. Custom visitor functions need to be written in JavaScript
and be registered once before they can be used from an AQL query.</p>

<p>Custom visitors have the following function signature:
<code>js visitor function signature
function (config, result, vertex, path)
</code></p>

<p>The function parameters have the following meanings:</p>

<ul>
<li><code>config</code>: the traversal configuration</li>
<li><code>result</code>: the result already generated by the traversal. This is important only
if the visitor is designed to modify an existing result in-place</li>
<li><code>vertex</code>: the currently visited vertex document</li>
<li><code>path</code>: the path from the start vertex to the currently visited vertex document.
The path will contain an array <code>vertices</code> and an array <code>edges</code></li>
</ul>


<p>Let&rsquo;s register a custom visitor named <code>myfunctions::structurePrinter</code>. This can done
by running the following code from the ArangoShell:</p>

<p>```js registering a custom visitor to print the tree structure
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex, path) {
  var indentation = new Array(path.vertices.length).join(&ldquo;  &rdquo;);
  var label       = &ldquo;&ndash; &rdquo; + vertex.name + &ldquo; (&rdquo; + vertex.type + &ldquo;)&rdquo;;
  return indentation + label;
});
```</p>

<h2>Processing vertex data with a function</h2>

<p>The above function will be called for every vertex in the graph when we use it in
a traversal. Let&rsquo;s do it and run the AQL query to invoke the visitor function.</p>

<p>I suggest running the query from the web interface&rsquo;s <strong>AQL editor</strong>:</p>

<p><code>plain invoking the custom visitor
LET params = {
  visitor : "myfunctions::structurePrinter",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>The visitor will visit all vertices in the graph, starting at the vertex
<code>v/world</code> as specified. It will then follow incoming connections using a
depth-first search (this was not specified in the query as it is the default).</p>

<p>As we started with the root vertex of the graph, the query will visit all
vertices exactly once. Fortunately the example graph is a tree and does not
contain any cycles, so we do not have to care about how to make the traversal
terminate. The traversal will automatically terminate after it has visited all nodes.</p>

<p>The AQL query should produce something like this:</p>

<p><code>js query result
[
  "- World (root)",
  "  - North America (continent)",
  "    - Bahamas (country)",
  "      - Nassau (capital)",
  "    - Canada (country)",
  "      - Ottawa (capital)",
  "    - Antigua and Barbuda (country)",
  "      - Saint John's (capital)",
  "    - Barbados (country)",
  "      - Bridgetown (capital)",
  "  - Asia (continent)",
  "    - Afghanistan (country)",
  "      - Kabul (capital)",
  ...
]
</code></p>

<p>This should provide a good overview of the graph&rsquo;s contents.</p>

<h2>Referring to elements in the path</h2>

<p>To return the above result in a more structured manner, let&rsquo;s overwrite the
previous visitor function with one that returns the most interesting vertex
attributes individually. Let&rsquo;s include one that shows the nesting level of
each vertex in the tree:</p>

<p>```js registering another custom visitor to return the tree structure
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex, path) {
  return {</p>

<pre><code>name: vertex.name, 
type: vertex.type, 
level: path.vertices.length 
</code></pre>

<p>  };
});
```</p>

<p>Running the same AQL query will now return something like:</p>

<p>```js query result
[
  {</p>

<pre><code>"name" : "World", 
"type" : "root", 
"level" : 1 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "North America", 
"type" : "continent", 
"level" : 2 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Bahamas", 
"type" : "country", 
"level" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Nassau", 
"type" : "capital", 
"level" : 4 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Canada", 
"type" : "country", 
"level" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Ottawa", 
"type" : "capital", 
"level" : 4 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Antigua and Barbuda", 
"type" : "country", 
"level" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Saint John's", 
"type" : "capital", 
"level" : 4 
</code></pre>

<p>  },
  &hellip;
]
```</p>

<h2>Adding control flow</h2>

<p>Now let&rsquo;s add some control flow to the visitor function. The following visitor
function will also return information about each vertex' parent &ndash; except for the
root vertex, which does not have a parent:</p>

<p>```js a custom visitor with simple control flow
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex, path) {
  var res = {</p>

<pre><code>name: vertex.name, 
type: vertex.type, 
level: path.vertices.length
</code></pre>

<p>  };
  if (path.vertices.length > 1) {</p>

<pre><code>res.parent = { 
  name: path.vertices[path.vertices.length - 2].name, 
  type: path.vertices[path.vertices.length - 2].type
}; 
</code></pre>

<p>  }
  return res;
});
```</p>

<p>Running our AQL query will now produce a different type of result for the root vertex
than for all the other vertices:</p>

<p>```js query result
[
  {</p>

<pre><code>"name" : "World", 
"type" : "root", 
"level" : 1 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "North America", 
"type" : "continent", 
"level" : 2, 
"parent" : { 
  "name" : "World", 
  "type" : "root" 
} 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Bahamas", 
"type" : "country", 
"level" : 3, 
"parent" : { 
  "name" : "North America", 
  "type" : "continent" 
} 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Nassau", 
"type" : "capital", 
"level" : 4, 
"parent" : { 
  "name" : "Bahamas", 
  "type" : "country" 
} 
</code></pre>

<p>  },
  &hellip;
]
```</p>

<p>Of course much more things can be achieved by peeking the <em>path</em> variable.</p>

<h1>Filtering</h1>

<p>Now let&rsquo;s try to restrict the results of a graph traversal to just some vertices,
for example, all European countries. As we know the structure of the graph is quite
simple, the following naive approach will already do:</p>

<p>```js a custom visitor returning only European country names
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex, path) {
  if (path.vertices.length > 1 &amp;&amp;</p>

<pre><code>  path.vertices[path.vertices.length - 2].name === "Europe") {
return vertex.name; 
</code></pre>

<p>  }
});
```</p>

<p>But the above is clearly not ideal.</p>

<p>First of all, the traversal will still <strong>visit every vertex</strong> in the graph, even though
most vertices will not be returned. Ideally, one will want to restrict a traversal to
visit as few vertices as possible, especially in a big graph or in a graph that contains
cycles.</p>

<p>Second, the above visitor is looking into a vertex' direct parent for filtering. This
will work for graphs that have a rigid structure, but may not work in more complex setups.</p>

<p>We better use a dedicated function for filtering. Such function can control
if a given vertex is going to be visited (via calling the <em>visitor</em> function) and if its
connections should be followed. It can skip non-interesting vertices early, providing a
good way to make traversals more efficient.</p>

<p>A filter function can be specified in the <em>filterVertices</em> attribute of the traversal options.
If specified, <em>filterVertices</em> needs to contain the name of a custom AQL function. A filter
function again needs to be written in JavaScript and has the following signature:</p>

<p><code>js filter function signature
function (config, vertex, path)
</code></p>

<p>The filter function will be called for each vertex. It can return one of the
following values:</p>

<ul>
<li><code>"prune"</code>: visit the vertex, but do not descend into its connections</li>
<li><code>"exclude"</code>: do not visit the vertex, but do descend into its connections</li>
<li><code>[ "prune", "exclude" ]</code>: do not visit, and do not descend</li>
<li><code>undefined</code> (default): visit and descend</li>
</ul>


<p>The following filter function will return <code>"exclude"</code> for the root vertex, leading
to the visitor not being called for it. However, the traversal will still descend
into the connections of the root node.</p>

<p>On the next level, all continents will be enumerated. The filter will return
<code>[ "prune", "exclude" ]</code> for all continents but Europe, leading to the visitor not
being invoked for these continents, and their connections not being followed.
For the <em>Europe</em> vertex, it will return <code>"exclude"</code>,
meaning the visitor will not be called, but the traversal will descend into the
connections of <code>Europe</code>.</p>

<p>For all vertices of type <code>country</code>, the visitor will be
called. This is ok because the filter previously prevented the traversal from
descending into any other country but <em>Europe</em>.</p>

<p>Finally, the filter will return <code>"prune"</code> for all countries, meaning the traversal
will not descend into a country&rsquo;s connections (in this case that would be the captial vertices).
This will make the traversal end at the <code>country</code> level.</p>

<p>Here it is:</p>

<p>```js registering a filter for European countries
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::europeFilter&rdquo;, function (config, vertex, path) {
  if (vertex.type === &ldquo;country&rdquo;) {</p>

<pre><code>return "prune";
</code></pre>

<p>  }</p>

<p>  if (vertex.type === &ldquo;continent&rdquo;) {</p>

<pre><code>if (vertex.name !== "Europe") {
  return [ "prune", "exclude" ];
}
</code></pre>

<p>  }</p>

<p>  return &ldquo;exclude&rdquo;;
});
```</p>

<p>Putting the logic into the filter function allows using a very simple visitor:</p>

<p>```js a very simple visitor
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex) {
  return vertex.name;
});
```</p>

<p>We must also slightly extend our AQL query and tell it to use our custom filter function:
<code>plain invoking the custom visitor and the custom filter
LET params = {
  filterVertices : "myfunctions::europeFilter",
  visitor : "myfunctions::structurePrinter",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>Running the adjusted AQL query should produce something like:
<code>js query results
[
  "Austria",
  "Croatia",
  "Bosnia and Herzegovina",
  "Andorra",
  "Bulgaria",
  ...
]
</code></p>

<p>Custom filter functions are a very general approach. Obviously much more complex tasks
than shown here can be achieved with them. We have often been asked for ways to set up
complex filter conditions in AQL traversals, and I hope these custom filter functions
will cover most of that.</p>

<h1>Special visitors</h1>

<p>Traversal depths can be controlled with the general configuration parameters
<code>minDepth</code> and <code>maxDepth</code>. These parameters are helpful to make the traversal only
include vertices occurring after the specified distance from the start vertex, or
up to the specified distance away from the start vertex. This helps bounding
traversals, but is not flexible enough when handling graphs with very distinct
path lengths.</p>

<h2>Returning only leaf nodes</h2>

<p>For example, <strong>finding leaf nodes</strong> in a graph is quite hard using a default
traversal. The <em>filterVertices</em> function cannot be used to find leaf nodes, because
<em>filterVertices</em> is called before a vertex' connections are determined. The same is true
for visitor functions. There were not provided any information about whether the
currently visited vertex has connections or not. All a visitor could previously do
to find leaf nodes is to return each visited vertex along with the full path information.
Some post-processing of the traversal result with regular AQL was then required to
detect the leaf nodes in that result.</p>

<p>This could easily get inefficient, especially in a big graphs for which the intermediate
results created by the default traversal visitor grew beyond reasonable sizes.</p>

<p>We therefore added a mechanism that can pass information about the vertex' connections
to the visitor. This allows writing new types of visitor functions. For example, it
makes it easy to write visitors that can return only leaf nodes.</p>

<p>In order to have the traversal pass the currently visited vertex' connections to the
visitor function, the traversal parameter <code>order</code> must be set to a value of <code>"preorder-expander"</code>.
The traversal&rsquo;s visitor function will then be called with an additional fifth
parameter named <code>connected</code>, which is an array of the connections of the current
vertex. This array will be empty if the traversal&rsquo;s expander function did not
find any connections for the vertex.</p>

<p>Here&rsquo;s a simple visitor that will make a traversal return only all leaf nodes:</p>

<p>```js a visitor that receives information about connections, too
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::leafNodeVisitor&rdquo;, function (config, result, vertex, path, connected) {
  if (connected &amp;&amp; connected.length === 0) {</p>

<pre><code>return vertex.name + " (" + vertex.type + ")";
</code></pre>

<p>  }
});
```</p>

<p>And here&rsquo;s an AQL query that shows how to use this type of visitor:</p>

<p><code>plain invoking the leaf node visitor
LET params = {
  order : "preorder-expander",
  visitor : "myfunctions::leafNodeVisitor",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>As a result, the above query will only print vertices of type <code>capital</code>
(because those are the only leaf nodes in the graph).</p>

<p>The nice thing when looking at the custom visitor function is that it only
filters on the number of connections, but not on vertex type or anything else
specific for this type of graph.</p>

<p>So it seems like the above function is general purpose and can be reused for
other graphs, too.</p>

<h2>Counting vertices</h2>

<p>Let&rsquo;s say we wanted to count the number of vertices in the graph, or the number of
vertices that passed our <em>filterVertices</em> function.</p>

<h3>Counting globally</h3>

<p>This is easy to achieve with a custom visitor like this:</p>

<p>```js registering a visitor that counts the number of vertices visited
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::vertexCounter&rdquo;, function (config, result) {
  if (result.length === 0) {</p>

<pre><code>result.push(0);
</code></pre>

<p>  }
  result[0]++;
});
```</p>

<p>Note that the above visitor function does not return anything, but will modify an existing
result in place. As a result, it will produce one counter value, which will be increased
whenever the visitor is called for a vertex.</p>

<p>To invoke this visitor and retrieve the count value, we have to set the <em>visitorReturnsResults</em>
attribute in the AQL query to <em>false</em>. This will make the traversal code pass the existing
result into the visitor and does not expect it to return any results via a <code>return</code> instruction.
Here&rsquo;s how to run this visitor:</p>

<p><code>plain invoking the global vertex counter
LET params = {
  visitor : "myfunctions::vertexCounter",
  visitorReturnsResults : false
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>The result will simply be:
<code>js query result
[
  87
]
</code></p>

<h3>Counting by type</h3>

<p>Let&rsquo;s say we wanted to count vertices by type. This is similar, except that now one global
counter value is insufficient and we instead need an object to keep track of the different
counters. We can still get away with modifying an existing result in place:</p>

<p>```js registering a visitor that counts vertices by type
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::vertexCounter&rdquo;, function (config, result, vertex) {
  if (result.length === 0) {</p>

<pre><code>result.push({ });
</code></pre>

<p>  }
  var vertexType = vertex.type;
  if (! result[0].hasOwnProperty(vertexType)) {</p>

<pre><code>result[0][vertexType] = 1;
</code></pre>

<p>  }
  else {</p>

<pre><code>result[0][vertexType]++;
</code></pre>

<p>  }
});
```</p>

<p>Our invocation AQL query does not change. The result of this visitor for the example graph will be:
```js query result
[
  {</p>

<pre><code>"root" : 1, 
"continent" : 6, 
"country" : 40, 
"capital" : 40 
</code></pre>

<p>  }
]
```</p>

<p>Of course such visitors can be combined with custom filters.</p>

<p>You probably ask why writing custom code is required to achieve a simple task like counting.
The main reason for this is that the traversal functionality is very general purpose and
is not optimized for a specific use case like just counting. For example, the default traversal
visitor will copy the complete vertex and path information into the result.</p>

<p>This can produce very big intermediate results if the graph is big or vertices contain lots
of data. If all we want is to count the number of vertices globally or per type, we are better
off with something more specialized.</p>

<p>The good news is that the most simple use case &ldquo;count all vertices&rdquo; there is a predefined
visitor named <code>_AQL::COUNTINGVISITOR</code> that can directly be used from a query, without prior
registration of a custom function:</p>

<p><code>plain using the predefined countingvisitor function
LET params = {
  visitor : "_AQL::COUNTINGVISITOR"
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<h1>Accessing components from the path</h1>

<p>Visitors are allowed to peek into the <code>paths</code> variable to check how the currently visited
vertex is linked to others.</p>

<p>The paths variable is an object with a <code>vertices</code> sub-attribute and an <code>edges</code> sub-attribute.
<code>vertices</code> is an array including all vertices in the path from the start vertex up to the
currently visited vertex. The currently visited vertex is included in this array.
<code>edges</code> is an array including all connections (edges) between the start vertex and the
currently visited vertex. This array might be empty, in case the visitor is called for the
start vertex.</p>

<p>The following visitor function demonstrates how to peek into <code>paths</code>: it will produce a
stringified version of the path for all leaf vertices:</p>

<p>```js registering a visitor that accesses components from the path
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::leafNodePathVisitor&rdquo;, function (config, result, vertex, path, connected) {
  if (connected &amp;&amp; connected.length === 0) {</p>

<pre><code>var res = "";
path.vertices.forEach(function(v, i) {
  if (i &gt; 0 &amp;&amp; i &lt;= path.edges.length) {
    res += " &lt;--[" + path.edges[i - 1].type + "]-- ";
  }
  res += v.name;
});
return res;
</code></pre>

<p>  }
});
```</p>

<p>It can be invoked as follows:</p>

<p><code>plain using the visitor that accesses path components
LET params = {
  order : "preorder-expander",
  visitor : "myfunctions::leafNodePathVisitor",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>It will return something like the following:
<code>js query result
[
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Algeria &lt;--[is-in]-- Algiers",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Angola &lt;--[is-in]-- Luanda",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Botswana &lt;--[is-in]-- Gaborone",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Burkina Faso &lt;--[is-in]-- Ouagadougou",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Burundi &lt;--[is-in]-- Bujumbura",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Cameroon &lt;--[is-in]-- Yaounde",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Chad &lt;--[is-in]-- N'Djamena",
  ...
]
</code></p>

<p>Note: the contents of the <code>path</code> variable will change between calls to the
visitor function. Therefore is it not safe to reference arrays or objects from <code>path</code>
in the result for visitors that modify the <code>result</code> variable in place (i.e. when
<em>visitorReturnsResults</em> is set to <em>false</em>). The safe way to put path components
into the result of such visitors is to clone the parts of the path before putting
them into <code>result</code>.</p>

<h1>Passing parameters into visitors and filters</h1>

<p>It is often useful to pass own parameters into function to provide some sort
of invocation context. For example, the purpose of the following visitor function
is to return an object with only certain attributes of each visited vertex:</p>

<p>```js a visitor that can return arbitrary vertex attributes:
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::attributesPrinter&rdquo;, function (config, result, vertex) {
  var values = { };
  if (typeof config.data === &ldquo;object&rdquo; &amp;&amp; Array.isArray(config.data.attributes)) {</p>

<pre><code>config.data.attributes.forEach(function (attribute) {
  values[attribute] = vertex[attribute];
});
</code></pre>

<p>  }
  return values;
});
<code>``
Which attributes the function will return can be configured by passing in an
array of attribute names in the</code>config<code>parameter's</code>data<code>sub-attribute. Here's
an AQL query that will configure the visitor to return</code>_id<code>and</code>type`:</p>

<p>```plain invoking the attributes visitor
LET params = {
  visitor : &ldquo;myfunctions::attributesPrinter&rdquo;,
  visitorReturnsResults : true,
  data: {</p>

<pre><code>attributes: [ "_id", "type", "name" ] 
</code></pre>

<p>  }<br/>
}
FOR result IN TRAVERSAL(v, e, &ldquo;v/world&rdquo;, &ldquo;inbound&rdquo;, params)
  RETURN result
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Explaining AQL Queries the Fancier Way]]></title>
    <link href="http://jsteemann.github.io/blog/2015/01/23/explaining-aql-queries-the-fancy-way/"/>
    <updated>2015-01-23T01:00:03+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/01/23/explaining-aql-queries-the-fancy-way</id>
    <content type="html"><![CDATA[<p>I have been looking at many AQL queries during the last few weeks.</p>

<p>Looking back, I can say that the JSON query execution plans provided by
the <code>explain()</code> method have provided me with a lot of useful information
about how the AQL optimizer had transformed a given query. This has
helped testing and improving the query optimizer a great deal.</p>

<p>However, the JSON output produced by <code>explain()</code> is so detailed that even
for the simplest cases queries it will span multiple screens. This is far
too much for quicking assesing what a query will be doing and how it will
be executed.</p>

<p>I therefore quickly put together a function that provides a much more
compact explain output. Its input parameter is a query string, which it
will send to the ArangoDB server to have it explained.</p>

<p>But it doesn&rsquo;t print a voluminous JSON object. This one is for developers
with a full schedule.</p>

<p><img src="/downloads/screenshots/explainer.png"></p>

<!-- more -->


<p>It prints the original query, the generated query execution plan, the
applied optimizer rules plus the list of indexes that will be used. This
is often the key information that one is interested in.</p>

<p>It works best when the execution plan fits on a single screen and
the execution plan is not nested too much. Subqueries are supported though.
I have tried it with several queries this night and the results were quite
promising from my point of view.</p>

<p>For example, a poor man&rsquo;s graph query (using a subquery to join connected
edges) still prints nicely:</p>

<p><img src="/downloads/screenshots/explainer-inv.png"></p>

<p>As usual, your mileage may vary. If you&rsquo;re inspecting complex queries
with it, the lines printed may get too long and wrap. The output won&rsquo;t be
very legible then, but it may still be helpful.</p>

<p>I have added the feature to 2.4 and devel. Anyone compiling from source
can use it by pulling the latest changes, compiling, and then typing the
following on the ArangoShell or in the web interface:</p>

<p><code>js
var explain = require("org/arangodb/aql/explainer").explain;
explain("FOR doc IN myCollection FILTER doc.value &lt; 23 RETURN doc");
</code></p>

<p>The feature will also be included in the next 2.4 package.</p>

<p>Anyone on 2.3 or 2.4 users that can&rsquo;t wait until the next package can give
it a try, too. The code for the explain function is contained in a single file,
and it can be downloaded from
<a href="https://github.com/arangodb/arangodb/blob/2.4/js/common/modules/org/arangodb/aql/explainer.js">Github</a>.
and then be copied into the appropriate location inside ArangoDB&rsquo;s <code>js</code> directory.
This should make it work from the ArangoShell (but not from the web interface).</p>

<p>On a side note: I would also like to have some functionality like this in
the web interface, but as a backend developer, I am not able to do any
serious UI work. I also put this together in my leisure time, and have to
come to an end with it.</p>
]]></content>
  </entry>
  
</feed>
