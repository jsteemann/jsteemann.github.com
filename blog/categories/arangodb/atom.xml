<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ArangoDB | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/arangodb/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2015-07-27T11:46:18+02:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AQL Object Literal Simplification]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/27/aql-object-literal-simplification/"/>
    <updated>2015-07-27T11:33:09+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/27/aql-object-literal-simplification</id>
    <content type="html"><![CDATA[<p>ArangoDB&rsquo;s <code>devel</code> branch recently saw a change that makes writing
some AQL queries a bit simpler.</p>

<p>The change introduces an optional shorthand notation for object attributes
in the style of ES6&rsquo;s enhanced object literal notation.</p>

<!-- more -->


<p>For example, consider the following query that groups values by <code>age</code>
attribute and counts the number of documents per distinct <code>age</code> value:</p>

<p><code>plain example query
FOR doc IN collection
  COLLECT age = doc.age WITH COUNT INTO length
  RETURN { age: age, length: length }
</code></p>

<p>The object declaration in the last line of the query is somewhat redundant
because one has to type identical attribute names and values:</p>

<p><code>plain the long notation for object literals
RETURN { age: age, length: length }
</code></p>

<p>In this case, the new shorthand notation simplifies the <code>RETURN</code> to:</p>

<p><code>plain using shorthand notation for object literals
RETURN { age, length }
</code></p>

<p>In general, the shorthand notation can be used for all object literals when
there is an attribute name that refers to a query variable of the same name.</p>

<p>It can also be mixed with the longer notation, e.g.:</p>

<p><code>plain mixing long and shorthand notation
RETURN { age, length, dateCreated: DATE_NOW() }
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 Features in ArangoDB 2.7]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/14/es6-features-in-arangodb-27/"/>
    <updated>2015-07-14T20:33:55+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/14/es6-features-in-arangodb-27</id>
    <content type="html"><![CDATA[<p>ArangoDB 2.6 uses V8 engine version 3.31.74.1 for running its own and all user-defined
JavaScript code. In ArangoDB 2.7 (currently in development), we have upgraded V8 to
version 4.3.61.</p>

<p>The new V8 version in ArangoDB 2.7 provides several additional ES6 features that can
be used to improve JavaScript usability and code quality. This blog post showcases <em>strong
mode</em> and <em>rest parameters</em>, and also shows how to activate <em>TurboFan</em>, V8&rsquo;s new JIT compiler
for JavaScript.</p>

<p>ArangoDB 2.7 is in development right now, but it can be tried today by
<a href="/blog/2014/10/16/how-to-compile-arangodb-from-source/">compiling it from source</a>.</p>

<!-- more -->


<h2>JavaScript strong mode</h2>

<p>V8 v4 comes with an optional and experimental <em>strong mode</em>. This mode provides only a
subset of JavaScript, with the idea of intentionally deactivating some of
<a href="http://archive.oreilly.com/pub/a/javascript/excerpts/javascript-good-parts/bad-parts.html">JavaScript&rsquo;s bad parts</a>.
It is based on <em>strict mode</em>, but goes further.</p>

<p>Committing to <em>strong mode</em> may not only provide better and stronger semantics, but may
also enable more optimization opportunities for the JavaScript compiler. For example, the
strong mode disables JavaScript&rsquo;s <em>with</em> statement and <code>delete</code>! Additionally, <code>var</code> cannot
be used anymore but is deprecated in favor of <code>let</code> and <code>const</code>.</p>

<p>The proposal for the strong mode can be found
<a href="https://docs.google.com/document/d/1Qk0qC4s_XNCLemj42FqfsRLp49nDQMZ1y7fwf5YjaI4/view">here</a>,
and the V8 team also has a <a href="https://developers.google.com/v8/experiments">page about it</a>.</p>

<p>Strong mode must be turned on explicitly. This can be done by adding the <code>--strong-mode=true</code>
v8 option when starting <em>arangod</em> or <em>arangosh</em>:</p>

<p><code>bash enabling strong mode
arangosh  --javascript.v8-options="--strong_mode=true"
</code></p>

<p>Note that I am using <em>arangosh</em> above, but the same would work for <em>arangod</em>, too, so the feature
can be used for Foxx routes as well.</p>

<h2>Rest parameters</h2>

<p>How to pass a variable number of arguments to a function?</p>

<p>C and C++ programmers have been using and abusing the ellipsis (<code>...</code>) and <code>__VA_ARGS__</code> features
of the C preprocessor for a long time. Then came the macros of <code>stdarg.h</code> / <code>cstdarg</code>,
until C++11 really improved the situation with <code>std::initializer_list</code> and variadic templates.</p>

<p>In JavaScript, one can use the <code>arguments</code> object:
```js
function logSimple () {
  for (value of arguments) {</p>

<pre><code>console.log(value);
</code></pre>

<p>  }
}</p>

<p>logSimple(&ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;);
```</p>

<p>This does the job, and the above will print something like:
<code>plain
2015-07-14T19:01:51Z [5245] INFO foo
2015-07-14T19:01:51Z [5245] INFO bar
2015-07-14T19:01:51Z [5245] INFO baz
</code></p>

<p>This is fine as long as all arguments shall be treated the same way. But what if some
arguments have a designated meaning and should be treated specially?</p>

<p>The solution is to use <em>ES6 rest parameters</em>. The last parameter in an argument list can be
prefixed with <code>...</code> to capture any number of function parameters:</p>

<p>```js
function logWithContext (context, &hellip;values) {
  for (value of values) {</p>

<pre><code>console.log('[' + context + '] ' + value);
</code></pre>

<p>  }
}</p>

<p>logWithContext(&ldquo;es6&rdquo;, &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;);
```</p>

<p>As can be seen, the <code>logWithContext</code> function specially handles its <code>context</code> argument, while
we can still pass any number of further parameters into it. Here&rsquo;s what the above will print:</p>

<p><code>plain
2015-07-14T19:07:27Z [5245] INFO [es6]: foo
2015-07-14T19:07:27Z [5245] INFO [es6]: bar
2015-07-14T19:07:27Z [5245] INFO [es6]: baz
</code></p>

<p>Note that rest parameters cannot be used with the default configuration and must be turned on
explicitly in <em>arangosh</em> or <em>arangod</em>.</p>

<p>The startup option to turn them on is:</p>

<p><code>bash enabling rest parameters
arangosh --javascript.v8-options="--harmony_rest_parameters=true"
</code></p>

<h2>TurboFan</h2>

<p>The new V8 version comes with <em>TurboFan</em>, a new JIT compiler for JavaScript.
According to <a href="http://blog.chromium.org/2015/07/revving-up-javascript-performance-with.html">this post</a>
it is already used in Chrome for compiling certain types of JavaScript code.</p>

<p>As fas as I can see, it is turned off by default in our version of V8, and the compiler
also seems to be rather experimental. To get an idea of what it can already do and where
its limits are, it can already be tried in ArangoDB 2.7.</p>

<p>By default, it seems to be turned off. Using the following startup option, it can be turned on for
JavaScript functions with a certain name pattern (i.e. all function names starting with <em>testTurboFan</em>):</p>

<p><code>bash starting ArangoShell with TurboFan enabled
arangosh --javascript.v8-options="--turbo-filter=testTurboFan*"`
</code></p>

<p>Without turning on V8 tracing, one will not be able to tell which compiler is used to compile a
specific function. To turn it on and actually confirm V8 is using TurboFan, use these options:</p>

<p><code>bash starting ArangoShell with TurboFan and debug output
arangosh --javascript.v8-options="--always-opt --trace_opt --turbo-filter=testTurboFan*"
</code></p>

<p>This will be very verbose, but it is good to tell which internal compiler is used to compile a given
JavaScript function.</p>

<p>For example, after starting the ArangoShell with the above options, run the following test code
to see that V8 uses TurboFan for compiling the first two functions (which match the name pattern),
and Crankshaft for the third (which does not match the name pattern):</p>

<p>```js test code for invoking the TurboFan compiler
function testTurboFan1 () {
  console.log(&ldquo;turbo-fan 1&rdquo;);
}
testTurboFan1();</p>

<p>function testTurboFan2 () {
  console.log(&ldquo;turbo-fan 2&rdquo;);
}
testTurboFan2();</p>

<p>function testSomethingElse () {
  console.log(&ldquo;something else&rdquo;);
}
testSomethingElse();
```</p>

<p>Here&rsquo;s the confirmation that TurboFan is used:</p>

<p><code>plain debug output
...
[compiling method 0x31ca8804e351 &lt;JS Function testTurboFan1 (SharedFunctionInfo 0x31ca8804e171)&gt; using TurboFan]
...
[compiling method 0x31ca8804e7f9 &lt;JS Function testTurboFan2 (SharedFunctionInfo 0x31ca8804e619)&gt; using TurboFan]
...
[compiling method 0x31ca8804ec71 &lt;JS Function testSomethingElse (SharedFunctionInfo 0x31ca8804ea91)&gt; using Crankshaft]
...
</code></p>

<p>Have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AQL Improvements for 2.7]]></title>
    <link href="http://jsteemann.github.io/blog/2015/06/17/aql-improvements-for-27/"/>
    <updated>2015-06-17T12:35:16+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/06/17/aql-improvements-for-27</id>
    <content type="html"><![CDATA[<p>With ArangoDB 2.6 being in beta already, it&rsquo;s time to look at some
features scheduled for 2.7. Today I&rsquo;ll showcase a few AQL parser
improvements that are present in the <code>devel</code> branch already, which will
be the foundation for the 2.7 release.</p>

<!-- more -->


<h2>Star operator</h2>

<p>The already existing star operator (<code>[*]</code>) is much more flexible in 2.7
than in previous ArangoDB versions. It now allows filtering the values it
iterates over, and optional projections.</p>

<p>These features will be demonstrated using the following example member data:</p>

<p><code>json example data for queries
[
  { "name" : "sir alfred", "age" : 60, "likes" : [ "lettuce", "tortoises" ] },
  { "name" : "mozquito", "age" : 15, "likes" : [ "skateboards", "music" ] },
  { "name" : "murphy", "age" : 28, "likes" : [ "juice", "tarts", "cakes" ] },
  { "name" : "helga", "age" : 52, "likes" : [ "home", "garden", "tortoises", "cakes" ] }
]
</code></p>

<p>To return all members with an age of 40 or higher and that also like tortoises,
we can now combine the star operator with an inline <code>FILTER</code> expression:</p>

<p><code>plain star operator with inline FILTER
RETURN @members[* FILTER CURRENT.age &gt;= 40 &amp;&amp; "tortoises" IN CURRENT.likes]
</code></p>

<p>The inline <code>FILTER</code> expression has access to the current array element via the
pseudo-variable <code>CURRENT</code>. The <code>FILTER</code> expression can thus access the element&rsquo;s
attributes and sub-attributes, and also use them in function expressions.</p>

<p>The above query will return only two array members as expected:</p>

<p><code>json
[
  { "name" : "sir alfred", "age" : 60, "likes" : [ "lettuce", "tortoises" ] },
  { "name" : "helga", "age" : 52, "likes" : [ "home", "garden", "tortoises", "cakes" ] }
]
</code></p>

<p>It&rsquo;s also possible to extract just a specific sub-attribute of each result value:</p>

<p><code>plain extracting just a sub-attribute
RETURN @members[* FILTER CURRENT.age &gt;= 40 &amp;&amp; "tortoises" IN CURRENT.likes].name
</code></p>

<p>This will return:</p>

<p><code>json query result
[
  "sir alfred",
  "helga"
]
</code></p>

<p>If we don&rsquo;t want to return the whole match but a single attribute is not enough, the
star operator can be used in combination with arbitrary projections, too.</p>

<p>The following query extracts the matching members a <code>FILTER</code> as above, but now only
returns each member&rsquo;s <code>age</code> attribute and the number of values in the member&rsquo;s <code>likes</code>
attribute:</p>

<p><code>plain extracting with a FILTER and a projection
RETURN @members[* FILTER CURRENT.age &gt;= 40 &amp;&amp; "tortoises" IN CURRENT.likes RETURN {
  name: CURRENT.name,
  likes: LENGTH(CURRENT.likes)
}]
</code></p>

<p>This will produce the following result:</p>

<p><code>json query result
[
  { "name" : "sir alfred", "likes" : 2 },
  { "name" : "helga", "likes" : 4 }
]
</code></p>

<p>If only a certain number of values is required, the star operator can be combined
with a <code>LIMIT</code> clause, too. This is useful for testing whether at least one of the
array members satisfies a <code>FILTER</code> condition:</p>

<p><code>plain limiting the number of results
RETURN @members[* FILTER "garden" IN CURRENT.likes LIMIT 1]
</code></p>

<p>Overall, the star operator is now much more powerful than before, so in many queries
it can replace full-blown <code>FOR</code> loops and subqueries when the goal simply is to iterate
over sub-parts of a result.</p>

<h2>Multi-star operator</h2>

<p>In 2.7 there is now also a <em>multi-star</em> operator (<code>[**]</code>). This operator can be used to
iterate over an array, too. In addition it will also flatten its input, so it can be used
for collapsing nested array structures.</p>

<p>This is useful in cases where a flat result is required but the single star operator would
return a nested array.</p>

<p>Consider this query with the single star operator:</p>

<p><code>plain extracting nested arrays
RETURN @members[* FILTER CURRENT.age &gt;= 40].likes[*]
</code></p>

<p>This will produce:</p>

<p><code>json result of single star query
[
  [ "lettuce", "tortoises" ],
  [ "home", "garden", "tortoises", "cakes" ]
]
</code></p>

<p>To get a collapsed array, we can employ the double star operator:</p>

<p><code>plain extracting flattend arrays
RETURN @members[* FILTER CURRENT.age &gt;= 40].likes[**]
</code></p>

<p>Then we&rsquo;ll get:</p>

<p><code>json result of double star query
[
  "lettuce",
  "tortoises",
  "home",
  "garden",
  "tortoises",
  "cakes"
]
</code></p>

<p>Note: the result of this query can also be made unique using the standard AQL
function <code>UNIQUE()</code>.</p>

<p>The star operator in 2.7 can have any number of levels. Using it with a single
star will simply iterate over the input array, using it with two stars will
collapse one level of the input, using it with three stars will collapse two
levels of the input etc.</p>

<h2>Subquery result usage</h2>

<p>While working on the AQL parser anyway, the grammar has been modified so
it allows a few more types of expressions.</p>

<p>For example, the result of a subquery can now be used as an array and the
subquery results can be accessed by position directly:</p>

<p>```plain accessing subquery results by position</p>

<pre><code>RETURN (
  FOR i IN [ 1, 2, 3 ] 
    RETURN i
)[0]
</code></pre>

<p>```</p>

<p>The trailing <code>[0]</code> led to a parse error in previous versions. To make this
work in previous versions, the subquery result needs to be captured in an
extra variable using <code>LET</code> before accessing the 0th member of that variable:</p>

<p>```plain workaround for accessing subquery results by position</p>

<pre><code>LET temp = (
  FOR i IN [ 1, 2, 3 ] 
    RETURN i
)
RETURN temp[0]
</code></pre>

<p>```</p>

<p>The parser generalizations now also allow to use the star operator directly
on a subquery result and access its individual members:</p>

<p>```plain expanding subquery results using star operator</p>

<pre><code>RETURN (
  FOR member IN [ 
    { name: "sir alfred" }, 
    { name: "mozquito" }
  ]
   RETURN member
)[*].name
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Speeding Up Array/object Literal Access]]></title>
    <link href="http://jsteemann.github.io/blog/2015/06/15/speeding-up-array-slash-object-literal-access/"/>
    <updated>2015-06-15T15:56:27+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/06/15/speeding-up-array-slash-object-literal-access</id>
    <content type="html"><![CDATA[<p>Last week some further optimization slipped into 2.6. The optimization can
provide significant speedups in AQL queries using huge array/object bind parameters
and passing them into V8-based functions.</p>

<!-- more -->


<p>It started with an ArangoDB user reporting a specific query to run unexpectedly slow.
The part of the query that caused the problem was simple and looked like this:</p>

<p><code>plain problematic query
FOR doc IN collection
  FILTER doc.attribute == @value
  RETURN TRANSLATE(doc.from, translations, 0)
</code></p>

<p>In the original query, <code>translations</code> was a big, constant object literal. Think of
something like the following, but with a lot more values:</p>

<p><code>json example translations value
{
  "p1" : 1,
  "p2" : 2,
  "p3" : 40,
  "p4" : 9,
  "p5" : 12
}
</code></p>

<p>The translations were used for replacing an attribute value in existing documents
with a lookup table computed outside the AQL query.</p>

<p>The number of values in the <code>translations</code> object was varying from query to query,
with no upper bound on the number of values. It was possible that the query was
running with 50,000 lookup values in the <code>translations</code> object.</p>

<p>When trying to reproduce the problem, we expected that the query would get at worst
<em>linearly</em> slower with an increasing number of lookup values. But in reality, the
following <em>non-linear</em> execution times were observed when increasing the number of
lookup values:</p>

<p>```plain execution times for varying input sizes, without optimization</p>

<h1>of values |  execution time</h1>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<pre><code>      1 |        0.6111 s
      2 |        0.6078 s  
      4 |        0.6021 s
      8 |        0.6160 s
     16 |        0.6925 s
     32 |        0.7107 s
     64 |        0.7677 s
    128 |        0.8576 s
    256 |        1.0544 s
    512 |        1.4579 s
   1024 |        8.8303 s
   2048 |       17.3674 s
   4096 |       35.3109 s
   8192 |       74.9161 s
  16384 |      145.0837 s
  32768 |      361.9870 s
  65536 |      880.4995 s
</code></pre>

<p>```</p>

<p>(note: all values stated above are wall-clock times for running the query with a
FILTER condition matching 50,000 documents &ndash; i.e. the <code>TRANSLATE()</code> expression was
executed 50,000 times per query)</p>

<p>With small objects passed in <code>translate</code>, the execution times only increased slowly
even when object sizes were doubled. The <code>TRANSLATE()</code> expression&rsquo;s share of the
overall query execution time was still low for small objects, even when doubling
their sizes. However, it got pretty bad for objects with 1,024 members already, and
from that point on, execution times more than doubled if object sizes got doubled.</p>

<p>The <code>TRANSLATE()</code> function itself has O(1) complexity, so we could rule it out as
the problem cause. However, <code>TRANSLATE()</code> is V8-based, and it turned out that there
was a problem when the number of values in the <code>translations</code> object increased from
1022 to 1023. At that particular threshold, execution time quadrupled.</p>

<p>At 1023 object members, V8 seems to change the internal object format, which probably
requires rearranging the object data internally. V8 has several <em>internal</em> types for
representing JavaScript objects, and converting between them is not free.</p>

<p>The obvious optimization opportunity for this case was to create the <code>translations</code>
object value just once as a V8 object, and reuse the same object when calling the
<code>TRANSLATE()</code> function repeatedly. This avoids repeated creation and destruction of
the V8 objects used in function calls, and as a side effect may also lead to less garbage
values being accumulated when functions are called repeatedly.</p>

<p>The optimization is possible here because the <code>translations</code> object is an object literal
and thus constant. It will also work for array literals and bind parameters (which
are also treated as literals once their values are known).</p>

<p>Here are the execution time for running the <code>TRANSLATE()</code> on 50,000 documents with the
modification:</p>

<p>```plain execution times, with optimization</p>

<h1>of values |  execution time</h1>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<pre><code>      1 |        0.6251 s
      2 |        0.6302 s  
      4 |        0.6138 s
      8 |        0.6141 s
     16 |        0.6685 s
     32 |        0.6232 s
     64 |        0.6204 s
    128 |        0.6326 s
    256 |        0.6460 s
    512 |        0.6275 s
   1024 |        0.6639 s
   2048 |        0.6345 s
   4096 |        0.6554 s
   8192 |        0.6789 s
  16384 |        0.7569 s
  32768 |        0.7636 s
  65536 |        1.0173 s
</code></pre>

<p>```</p>

<p>Looks like this is going to scale way better.</p>

<p>The optimization is disabled for big array/objects which are non-constant (e.g. a variable
or the result of an expression), or for parameters passed into user-defined AQL functions.
Enabling it for user-defined AQL functions is not safe because in theory these might
modify their arguments (and function arguments are passed by reference &ndash; passing them
by value would also defeat the purpose of the optimization).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On Getting Unique Values]]></title>
    <link href="http://jsteemann.github.io/blog/2015/06/01/on-getting-unique-values/"/>
    <updated>2015-06-01T13:27:13+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/06/01/on-getting-unique-values</id>
    <content type="html"><![CDATA[<p>While paging through the issues in the <a href="https://github.com/arangodb/arangodb">ArangoDB issue tracker</a>
I came across <a href="https://github.com/arangodb/arangodb/issues/987">issue #987</a>, titled
<em>Trying to get distinct document attribute values from a large collection fails</em>.</p>

<p>The issue was opened around 10 months ago when ArangoDB 2.2 was around. We improved AQL performance
somewhat since then, so I was eager to see how the query would perform in ArangoDB 2.6, especially
when comparing it to 2.2.</p>

<!-- more -->


<p>For reproduction I quickly put together some example data to run the query on:
<code>js setting up example data
var db = require("org/arangodb").db;
var c = db._create("test");
for (var i = 0; i &lt; 4 * 1000 * 1000; ++i) {
  c.save({ _key: "test" + i, value: (i % 100) });
}
require("internal").wal.flush(true, true);
</code></p>

<p>This produces a collection named <code>test</code> with 4 million documents. Each document has a numeric <code>value</code>
attribute, which in total has 100 unique values. I remembered from a conversation with the guy that
opened the issue that the number of distinct values was 100 or even slightly lower. I didn&rsquo;t bother
to create an index on the <code>value</code> attribute, which might have sped up the query.</p>

<p>With data available, it was time to run the query and measure its execution time:
<code>js running the query
var time = require("internal").time;
var start = time();
db._query("FOR doc IN test COLLECT value = doc.value RETURN value");
time() - start;
</code></p>

<p>Running this in 2.2.7 took 3 minutes and 18 seconds before bursting with the following error message:</p>

<p>```plain 2.2.7 error message
#</p>

<h1>Fatal error in CALL_AND_RETRY_2</h1>

<h1>Allocation failed &ndash; process out of memory</h1>

<p>#
```</p>

<p>In the 2.2 branch AQL queries were fully transformed to JavaScript and executed using V8. Obviously
that didn&rsquo;t work well with large collections. That was one of the reasons why version 2.3 saw a major
rewrite of the AQL engine.</p>

<p>As a consequence, running the query in 2.3 (2.3.5) worked fine. Execution took around 28 seconds.
The same was true for 2.4 (2.4.8) and 2.5 (2.5.5).</p>

<p>Finally, running the query in 2.6.0 completed in just 3.2 seconds.</p>

<p>The reasons for the speedup are the optimizations done for <code>COLLECT</code> (see
<a href="/blog/2015/04/22/collecting-with-a-hash-table/">COLLECTing with a hash table</a>, the
<a href="/blog/2015/05/04/return-value-optimization-for-aql/">Return value optimization for AQL</a> and some
minor optimizations within AQL that didn&rsquo;t get a pretty working title.</p>

<p>Looks like in sum all the optimizations put into 2.6 really pay out.</p>
]]></content>
  </entry>
  
</feed>
