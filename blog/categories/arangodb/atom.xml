<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ArangoDB | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/arangodb/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2015-01-30T11:45:19+01:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Custom Visitors in AQL Graph Traversals]]></title>
    <link href="http://jsteemann.github.io/blog/2015/01/28/using-custom-visitors-in-aql-graph-traversals/"/>
    <updated>2015-01-28T22:21:35+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/01/28/using-custom-visitors-in-aql-graph-traversals</id>
    <content type="html"><![CDATA[<p>This post is about some recent extensions for the AQL graph traversal functionality
in ArangoDB.</p>

<p>These extensions allow invoking user-defined JavaScript code for filtering
and results generation in AQL queries that contain traversals.</p>

<p>This should make AQL graph traversals much more powerful than before.
Additionally, AQL graph traversals get more configurable, allowing to write
traversal functions with control-flow logic and complex filtering. As a
side-effect, this change facilitates writing specialized traversal functions
with much higher efficiency than the general-purpose, cover-all-cases default
ones.</p>

<p>The extensions are currently available in the devel branch of ArangoDB on in the
2.4 branch (with 2.4.2 being the first release to include them).</p>

<!-- more -->


<h1>Example graph</h1>

<p>For all following examples, I&rsquo;ll be using a small example graph that can be set
up by running <a href="/downloads/code/world-graph-setup.js">this script</a> from the ArangoShell.</p>

<p>I have chosen this small graph because it is easy to understand and still complex
enough to demonstrate some common traversal use cases.</p>

<p>The example graph consists of the following two collections:</p>

<ul>
<li><code>v</code>: a collection with vertex documents.</li>
<li><code>e</code>: an edge collection containing the connections between vertices in <code>v</code></li>
</ul>


<p>All vertices in the graph have a <code>type</code> attribute, with types being either <code>root</code>,
<code>continent</code>, <code>country</code> or <code>capital</code>. The graph is a tree, so it has only one vertex
with type <code>root</code>. The root vertex is named <em>world</em>. Below the root there are only
vertices of type <code>continent</code>. These are also connected to some <code>country</code> vertices.
Finally, <code>country</code> vertices are also connected to <code>capital</code> vertices:</p>

<p><code>plain
root &lt;--[is in]-- continent &lt;--[is in]-- country &lt;--[is in]-- captial
</code></p>

<p>In the examples, we&rsquo;ll only look at the vertices and ignore what the connections
look like.</p>

<h1>Custom visitors</h1>

<p>We know the graph is a tree, so let&rsquo;s print its structure in a textual format
using AQL. We&rsquo;ll employ a <strong>custom visitor function</strong> for this. A custom visitor is
a user-defined callback function that is called for every vertex that is encountered
during a graph traversal. Custom visitor functions need to be written in JavaScript
and be registered once before they can be used from an AQL query.</p>

<p>Custom visitors have the following function signature:
<code>js visitor function signature
function (config, result, vertex, path)
</code></p>

<p>The function parameters have the following meanings:</p>

<ul>
<li><code>config</code>: the traversal configuration</li>
<li><code>result</code>: the result already generated by the traversal. This is important only
if the visitor is designed to modify an existing result in-place</li>
<li><code>vertex</code>: the currently visited vertex document</li>
<li><code>path</code>: the path from the start vertex to the currently visited vertex document.
The path will contain an array <code>vertices</code> and an array <code>edges</code></li>
</ul>


<p>Let&rsquo;s register a custom visitor named <code>myfunctions::structurePrinter</code>. This can done
by running the following code from the ArangoShell:</p>

<p>```js registering a custom visitor to print the tree structure
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex, path) {
  var indentation = new Array(path.vertices.length).join(&ldquo;  &rdquo;);
  var label       = &ldquo;&ndash; &rdquo; + vertex.name + &ldquo; (&rdquo; + vertex.type + &ldquo;)&rdquo;;
  return indentation + label;
});
```</p>

<h2>Processing vertex data with a function</h2>

<p>The above function will be called for every vertex in the graph when we use it in
a traversal. Let&rsquo;s do it and run the AQL query to invoke the visitor function.</p>

<p>I suggest running the query from the web interface&rsquo;s <strong>AQL editor</strong>:</p>

<p><code>plain invoking the custom visitor
LET params = {
  visitor : "myfunctions::structurePrinter",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>The visitor will visit all vertices in the graph, starting at the vertex
<code>v/world</code> as specified. It will then follow incoming connections using a
depth-first search (this was not specified in the query as it is the default).</p>

<p>As we started with the root vertex of the graph, the query will visit all
vertices exactly once. Fortunately the example graph is a tree and does not
contain any cycles, so we do not have to care about how to make the traversal
terminate. The traversal will automatically terminate after it has visited all nodes.</p>

<p>The AQL query should produce something like this:</p>

<p><code>js query result
[
  "- World (root)",
  "  - North America (continent)",
  "    - Bahamas (country)",
  "      - Nassau (capital)",
  "    - Canada (country)",
  "      - Ottawa (capital)",
  "    - Antigua and Barbuda (country)",
  "      - Saint John's (capital)",
  "    - Barbados (country)",
  "      - Bridgetown (capital)",
  "  - Asia (continent)",
  "    - Afghanistan (country)",
  "      - Kabul (capital)",
  ...
]
</code></p>

<p>This should provide a good overview of the graph&rsquo;s contents.</p>

<h2>Referring to elements in the path</h2>

<p>To return the above result in a more structured manner, let&rsquo;s overwrite the
previous visitor function with one that returns the most interesting vertex
attributes individually. Let&rsquo;s include one that shows the nesting level of
each vertex in the tree:</p>

<p>```js registering another custom visitor to return the tree structure
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex, path) {
  return {</p>

<pre><code>name: vertex.name, 
type: vertex.type, 
level: path.vertices.length 
</code></pre>

<p>  };
});
```</p>

<p>Running the same AQL query will now return something like:</p>

<p>```js query result
[
  {</p>

<pre><code>"name" : "World", 
"type" : "root", 
"level" : 1 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "North America", 
"type" : "continent", 
"level" : 2 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Bahamas", 
"type" : "country", 
"level" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Nassau", 
"type" : "capital", 
"level" : 4 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Canada", 
"type" : "country", 
"level" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Ottawa", 
"type" : "capital", 
"level" : 4 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Antigua and Barbuda", 
"type" : "country", 
"level" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Saint John's", 
"type" : "capital", 
"level" : 4 
</code></pre>

<p>  },
  &hellip;
]
```</p>

<h2>Adding control flow</h2>

<p>Now let&rsquo;s add some control flow to the visitor function. The following visitor
function will also return information about each vertex' parent &ndash; except for the
root vertex, which does not have a parent:</p>

<p>```js a custom visitor with simple control flow
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex, path) {
  var res = {</p>

<pre><code>name: vertex.name, 
type: vertex.type, 
level: path.vertices.length
</code></pre>

<p>  };
  if (path.vertices.length > 1) {</p>

<pre><code>res.parent = { 
  name: path.vertices[path.vertices.length - 2].name, 
  type: path.vertices[path.vertices.length - 2].type
}; 
</code></pre>

<p>  }
  return res;
});
```</p>

<p>Running our AQL query will now produce a different type of result for the root vertex
than for all the other vertices:</p>

<p>```js query result
[
  {</p>

<pre><code>"name" : "World", 
"type" : "root", 
"level" : 1 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "North America", 
"type" : "continent", 
"level" : 2, 
"parent" : { 
  "name" : "World", 
  "type" : "root" 
} 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Bahamas", 
"type" : "country", 
"level" : 3, 
"parent" : { 
  "name" : "North America", 
  "type" : "continent" 
} 
</code></pre>

<p>  },
  {</p>

<pre><code>"name" : "Nassau", 
"type" : "capital", 
"level" : 4, 
"parent" : { 
  "name" : "Bahamas", 
  "type" : "country" 
} 
</code></pre>

<p>  },
  &hellip;
]
```</p>

<p>Of course much more things can be achieved by peeking the <em>path</em> variable.</p>

<h1>Filtering</h1>

<p>Now let&rsquo;s try to restrict the results of a graph traversal to just some vertices,
for example, all European countries. As we know the structure of the graph is quite
simple, the following naive approach will already do:</p>

<p>```js a custom visitor returning only European country names
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex, path) {
  if (path.vertices.length > 1 &amp;&amp;</p>

<pre><code>  path.vertices[path.vertices.length - 2].name === "Europe") {
return vertex.name; 
</code></pre>

<p>  }
});
```</p>

<p>But the above is clearly not ideal.</p>

<p>First of all, the traversal will still <strong>visit every vertex</strong> in the graph, even though
most vertices will not be returned. Ideally, one will want to restrict a traversal to
visit as few vertices as possible, especially in a big graph or in a graph that contains
cycles.</p>

<p>Second, the above visitor is looking into a vertex' direct parent for filtering. This
will work for graphs that have a rigid structure, but may not work in more complex setups.</p>

<p>We better use a dedicated function for filtering. Such function can control
if a given vertex is going to be visited (via calling the <em>visitor</em> function) and if its
connections should be followed. It can skip non-interesting vertices early, providing a
good way to make traversals more efficient.</p>

<p>A filter function can be specified in the <em>filterVertices</em> attribute of the traversal options.
If specified, <em>filterVertices</em> needs to contain the name of a custom AQL function. A filter
function again needs to be written in JavaScript and has the following signature:</p>

<p><code>js filter function signature
function (config, vertex, path)
</code></p>

<p>The filter function will be called for each vertex. It can return one of the
following values:</p>

<ul>
<li><code>"prune"</code>: visit the vertex, but do not descend into its connections</li>
<li><code>"exclude"</code>: do not visit the vertex, but do descend into its connections</li>
<li><code>[ "prune", "exclude" ]</code>: do not visit, and do not descend</li>
<li><code>undefined</code> (default): visit and descend</li>
</ul>


<p>The following filter function will return <code>"exclude"</code> for the root vertex, leading
to the visitor not being called for it. However, the traversal will still descend
into the connections of the root node.</p>

<p>On the next level, all continents will be enumerated. The filter will return
<code>[ "prune", "exclude" ]</code> for all continents but Europe, leading to the visitor not
being invoked for these continents, and their connections not being followed.
For the <em>Europe</em> vertex, it will return <code>"exclude"</code>,
meaning the visitor will not be called, but the traversal will descend into the
connections of <code>Europe</code>.</p>

<p>For all vertices of type <code>country</code>, the visitor will be
called. This is ok because the filter previously prevented the traversal from
descending into any other country but <em>Europe</em>.</p>

<p>Finally, the filter will return <code>"prune"</code> for all countries, meaning the traversal
will not descend into a country&rsquo;s connections (in this case that would be the captial vertices).
This will make the traversal end at the <code>country</code> level.</p>

<p>Here it is:</p>

<p>```js registering a filter for European countries
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::europeFilter&rdquo;, function (config, vertex, path) {
  if (vertex.type === &ldquo;country&rdquo;) {</p>

<pre><code>return "prune";
</code></pre>

<p>  }</p>

<p>  if (vertex.type === &ldquo;continent&rdquo;) {</p>

<pre><code>if (vertex.name !== "Europe") {
  return [ "prune", "exclude" ];
}
</code></pre>

<p>  }</p>

<p>  return &ldquo;exclude&rdquo;;
});
```</p>

<p>Putting the logic into the filter function allows using a very simple visitor:</p>

<p>```js a very simple visitor
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::structurePrinter&rdquo;, function (config, result, vertex) {
  return vertex.name;
});
```</p>

<p>We must also slightly extend our AQL query and tell it to use our custom filter function:
<code>plain invoking the custom visitor and the custom filter
LET params = {
  filterVertices : "myfunctions::europeFilter",
  visitor : "myfunctions::structurePrinter",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>Running the adjusted AQL query should produce something like:
<code>js query results
[
  "Austria",
  "Croatia",
  "Bosnia and Herzegovina",
  "Andorra",
  "Bulgaria",
  ...
]
</code></p>

<p>Custom filter functions are a very general approach. Obviously much more complex tasks
than shown here can be achieved with them. We have often been asked for ways to set up
complex filter conditions in AQL traversals, and I hope these custom filter functions
will cover most of that.</p>

<h1>Special visitors</h1>

<p>Traversal depths can be controlled with the general configuration parameters
<code>minDepth</code> and <code>maxDepth</code>. These parameters are helpful to make the traversal only
include vertices occurring after the specified distance from the start vertex, or
up to the specified distance away from the start vertex. This helps bounding
traversals, but is not flexible enough when handling graphs with very distinct
path lengths.</p>

<h2>Returning only leaf nodes</h2>

<p>For example, <strong>finding leaf nodes</strong> in a graph is quite hard using a default
traversal. The <em>filterVertices</em> function cannot be used to find leaf nodes, because
<em>filterVertices</em> is called before a vertex' connections are determined. The same is true
for visitor functions. There were not provided any information about whether the
currently visited vertex has connections or not. All a visitor could previously do
to find leaf nodes is to return each visited vertex along with the full path information.
Some post-processing of the traversal result with regular AQL was then required to
detect the leaf nodes in that result.</p>

<p>This could easily get inefficient, especially in a big graphs for which the intermediate
results created by the default traversal visitor grew beyond reasonable sizes.</p>

<p>We therefore added a mechanism that can pass information about the vertex' connections
to the visitor. This allows writing new types of visitor functions. For example, it
makes it easy to write visitors that can return only leaf nodes.</p>

<p>In order to have the traversal pass the currently visited vertex' connections to the
visitor function, the traversal parameter <code>order</code> must be set to a value of <code>"preorder-expander"</code>.
The traversal&rsquo;s visitor function will then be called with an additional fifth
parameter named <code>connected</code>, which is an array of the connections of the current
vertex. This array will be empty if the traversal&rsquo;s expander function did not
find any connections for the vertex.</p>

<p>Here&rsquo;s a simple visitor that will make a traversal return only all leaf nodes:</p>

<p>```js a visitor that receives information about connections, too
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::leafNodeVisitor&rdquo;, function (config, result, vertex, path, connected) {
  if (connected &amp;&amp; connected.length === 0) {</p>

<pre><code>return vertex.name + " (" + vertex.type + ")";
</code></pre>

<p>  }
});
```</p>

<p>And here&rsquo;s an AQL query that shows how to use this type of visitor:</p>

<p><code>plain invoking the leaf node visitor
LET params = {
  order : "preorder-expander",
  visitor : "myfunctions::leafNodeVisitor",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>As a result, the above query will only print vertices of type <code>capital</code>
(because those are the only leaf nodes in the graph).</p>

<p>The nice thing when looking at the custom visitor function is that it only
filters on the number of connections, but not on vertex type or anything else
specific for this type of graph.</p>

<p>So it seems like the above function is general purpose and can be reused for
other graphs, too.</p>

<h2>Counting vertices</h2>

<p>Let&rsquo;s say we wanted to count the number of vertices in the graph, or the number of
vertices that passed our <em>filterVertices</em> function.</p>

<h3>Counting globally</h3>

<p>This is easy to achieve with a custom visitor like this:</p>

<p>```js registering a visitor that counts the number of vertices visited
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::vertexCounter&rdquo;, function (config, result) {
  if (result.length === 0) {</p>

<pre><code>result.push(0);
</code></pre>

<p>  }
  result[0]++;
});
```</p>

<p>Note that the above visitor function does not return anything, but will modify an existing
result in place. As a result, it will produce one counter value, which will be increased
whenever the visitor is called for a vertex.</p>

<p>To invoke this visitor and retrieve the count value, we have to set the <em>visitorReturnsResults</em>
attribute in the AQL query to <em>false</em>. This will make the traversal code pass the existing
result into the visitor and does not expect it to return any results via a <code>return</code> instruction.
Here&rsquo;s how to run this visitor:</p>

<p><code>plain invoking the global vertex counter
LET params = {
  visitor : "myfunctions::vertexCounter",
  visitorReturnsResults : false
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>The result will simply be:
<code>js query result
[
  87
]
</code></p>

<h3>Counting by type</h3>

<p>Let&rsquo;s say we wanted to count vertices by type. This is similar, except that now one global
counter value is insufficient and we instead need an object to keep track of the different
counters. We can still get away with modifying an existing result in place:</p>

<p>```js registering a visitor that counts vertices by type
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::vertexCounter&rdquo;, function (config, result, vertex) {
  if (result.length === 0) {</p>

<pre><code>result.push({ });
</code></pre>

<p>  }
  var vertexType = vertex.type;
  if (! result[0].hasOwnProperty(vertexType)) {</p>

<pre><code>result[0][vertexType] = 1;
</code></pre>

<p>  }
  else {</p>

<pre><code>result[0][vertexType]++;
</code></pre>

<p>  }
});
```</p>

<p>Our invocation AQL query does not change. The result of this visitor for the example graph will be:
```js query result
[
  {</p>

<pre><code>"root" : 1, 
"continent" : 6, 
"country" : 40, 
"capital" : 40 
</code></pre>

<p>  }
]
```</p>

<p>Of course such visitors can be combined with custom filters.</p>

<p>You probably ask why writing custom code is required to achieve a simple task like counting.
The main reason for this is that the traversal functionality is very general purpose and
is not optimized for a specific use case like just counting. For example, the default traversal
visitor will copy the complete vertex and path information into the result.</p>

<p>This can produce very big intermediate results if the graph is big or vertices contain lots
of data. If all we want is to count the number of vertices globally or per type, we are better
off with something more specialized.</p>

<p>The good news is that the most simple use case &ldquo;count all vertices&rdquo; there is a predefined
visitor named <code>_AQL::COUNTINGVISITOR</code> that can directly be used from a query, without prior
registration of a custom function:</p>

<p><code>plain using the predefined countingvisitor function
LET params = {
  visitor : "_AQL::COUNTINGVISITOR"
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<h1>Accessing components from the path</h1>

<p>Visitors are allowed to peek into the <code>paths</code> variable to check how the currently visited
vertex is linked to others.</p>

<p>The paths variable is an object with a <code>vertices</code> sub-attribute and an <code>edges</code> sub-attribute.
<code>vertices</code> is an array including all vertices in the path from the start vertex up to the
currently visited vertex. The currently visited vertex is included in this array.
<code>edges</code> is an array including all connections (edges) between the start vertex and the
currently visited vertex. This array might be empty, in case the visitor is called for the
start vertex.</p>

<p>The following visitor function demonstrates how to peek into <code>paths</code>: it will produce a
stringified version of the path for all leaf vertices:</p>

<p>```js registering a visitor that accesses components from the path
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::leafNodePathVisitor&rdquo;, function (config, result, vertex, path, connected) {
  if (connected &amp;&amp; connected.length === 0) {</p>

<pre><code>var res = "";
path.vertices.forEach(function(v, i) {
  if (i &gt; 0 &amp;&amp; i &lt;= path.edges.length) {
    res += " &lt;--[" + path.edges[i - 1].type + "]-- ";
  }
  res += v.name;
});
return res;
</code></pre>

<p>  }
});
```</p>

<p>It can be invoked as follows:</p>

<p><code>plain using the visitor that accesses path components
LET params = {
  order : "preorder-expander",
  visitor : "myfunctions::leafNodePathVisitor",
  visitorReturnsResults : true
}
FOR result IN TRAVERSAL(v, e, "v/world", "inbound", params)
  RETURN result
</code></p>

<p>It will return something like the following:
<code>js query result
[
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Algeria &lt;--[is-in]-- Algiers",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Angola &lt;--[is-in]-- Luanda",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Botswana &lt;--[is-in]-- Gaborone",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Burkina Faso &lt;--[is-in]-- Ouagadougou",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Burundi &lt;--[is-in]-- Bujumbura",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Cameroon &lt;--[is-in]-- Yaounde",
  "World &lt;--[is-in]-- Africa &lt;--[is-in]-- Chad &lt;--[is-in]-- N'Djamena",
  ...
]
</code></p>

<p>Note: the contents of the <code>path</code> variable will change between calls to the
visitor function. Therefore is it not safe to reference arrays or objects from <code>path</code>
in the result for visitors that modify the <code>result</code> variable in place (i.e. when
<em>visitorReturnsResults</em> is set to <em>false</em>). The safe way to put path components
into the result of such visitors is to clone the parts of the path before putting
them into <code>result</code>.</p>

<h1>Passing parameters into visitors and filters</h1>

<p>It is often useful to pass own parameters into function to provide some sort
of invocation context. For example, the purpose of the following visitor function
is to return an object with only certain attributes of each visited vertex:</p>

<p>```js a visitor that can return arbitrary vertex attributes:
var aqlfunctions = require(&ldquo;org/arangodb/aql/functions&rdquo;);</p>

<p>aqlfunctions.register(&ldquo;myfunctions::attributesPrinter&rdquo;, function (config, result, vertex) {
  var values = { };
  if (typeof config.data === &ldquo;object&rdquo; &amp;&amp; Array.isArray(config.data.attributes)) {</p>

<pre><code>config.data.attributes.forEach(function (attribute) {
  values[attribute] = vertex[attribute];
});
</code></pre>

<p>  }
  return values;
});
<code>``
Which attributes the function will return can be configured by passing in an
array of attribute names in the</code>config<code>parameter's</code>data<code>sub-attribute. Here's
an AQL query that will configure the visitor to return</code>_id<code>and</code>type`:</p>

<p>```plain invoking the attributes visitor
LET params = {
  visitor : &ldquo;myfunctions::attributesPrinter&rdquo;,
  visitorReturnsResults : true,
  data: {</p>

<pre><code>attributes: [ "_id", "type", "name" ] 
</code></pre>

<p>  }<br/>
}
FOR result IN TRAVERSAL(v, e, &ldquo;v/world&rdquo;, &ldquo;inbound&rdquo;, params)
  RETURN result
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Explaining AQL Queries the Fancier Way]]></title>
    <link href="http://jsteemann.github.io/blog/2015/01/23/explaining-aql-queries-the-fancy-way/"/>
    <updated>2015-01-23T01:00:03+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/01/23/explaining-aql-queries-the-fancy-way</id>
    <content type="html"><![CDATA[<p>I have been looking at many AQL queries during the last few weeks.</p>

<p>Looking back, I can say that the JSON query execution plans provided by
the <code>explain()</code> method have provided me with a lot of useful information
about how the AQL optimizer had transformed a given query. This has
helped testing and improving the query optimizer a great deal.</p>

<p>However, the JSON output produced by <code>explain()</code> is so detailed that even
for the simplest cases queries it will span multiple screens. This is far
too much for quicking assesing what a query will be doing and how it will
be executed.</p>

<p>I therefore quickly put together a function that provides a much more
compact explain output. Its input parameter is a query string, which it
will send to the ArangoDB server to have it explained.</p>

<p>But it doesn&rsquo;t print a voluminous JSON object. This one is for developers
with a full schedule.</p>

<p>{% img /downloads/screenshots/explainer.png %}</p>

<!-- more -->


<p>It prints the original query, the generated query execution plan, the
applied optimizer rules plus the list of indexes that will be used. This
is often the key information that one is interested in.</p>

<p>It works best when the execution plan fits on a single screen and
the execution plan is not nested too much. Subqueries are supported though.
I have tried it with several queries this night and the results were quite
promising from my point of view.</p>

<p>For example, a poor man&rsquo;s graph query (using a subquery to join connected
edges) still prints nicely:</p>

<p>{% img /downloads/screenshots/explainer-inv.png %}</p>

<p>As usual, your mileage may vary. If you&rsquo;re inspecting complex queries
with it, the lines printed may get too long and wrap. The output won&rsquo;t be
very legible then, but it may still be helpful.</p>

<p>I have added the feature to 2.4 and devel. Anyone compiling from source
can use it by pulling the latest changes, compiling, and then typing the
following on the ArangoShell or in the web interface:</p>

<p><code>js
var explain = require("org/arangodb/aql/explainer").explain;
explain("FOR doc IN myCollection FILTER doc.value &lt; 23 RETURN doc");
</code></p>

<p>The feature will also be included in the next 2.4 package.</p>

<p>Anyone on 2.3 or 2.4 users that can&rsquo;t wait until the next package can give
it a try, too. The code for the explain function is contained in a single file,
and it can be downloaded from
<a href="https://github.com/arangodb/arangodb/blob/2.4/js/common/modules/org/arangodb/aql/explainer.js">Github</a>.
and then be copied into the appropriate location inside ArangoDB&rsquo;s <code>js</code> directory.
This should make it work from the ArangoShell (but not from the web interface).</p>

<p>On a side note: I would also like to have some functionality like this in
the web interface, but as a backend developer, I am not able to do any
serious UI work. I also put this together in my leisure time, and have to
come to an end with it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Returning Results From AQL INSERT/REMOVE/REPLACE Operations]]></title>
    <link href="http://jsteemann.github.io/blog/2015/01/13/returning-results-from-aql-insert-update-remove-operations/"/>
    <updated>2015-01-13T22:53:40+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/01/13/returning-results-from-aql-insert-update-remove-operations</id>
    <content type="html"><![CDATA[<p>ArangoDB provides many options for finding and modifying data. Though there are
several more specialized operation, data-modification AQL queries are the most
general solution in ArangoDB. They allow to find documents using arbitrary filter
criteria, and to modify or remove the documents once found.</p>

<p>Such <em>find-and-modify</em> operations can be executed with multiple queries (one for
the find step, one for the modification step), or with a single query. Putting
both steps into a single query will often save roundtrips between the application
and the database and thus may be preferred over executing the steps separately.
Putting both the find and the modify step into the same query also prevents other
operations from interfering in between and tampering with the underlying data.</p>

<p>Now what if the application not only requires the data to be updated, but also needs
to keep track of which documents were found and modified by a <em>find-and-modify</em>
query? This is often required when an application needs to keep database
data in sync with data in some other datastore (e.g. the filesystem or a remote
service).</p>

<p>The pattern I would dub <em>find-modify-return</em> would be useful for this.</p>

<!-- more -->


<p>Unfortunately it hasn&rsquo;t been supported in AQL until very recently.
We have been asked for this so many times that I stopped counting.</p>

<p>I am glad that this got better with ArangoDB 2.4. Finding, modifying and returning
documents is now possible from the same AQL query. The solution is not yet perfect,
but at least it provides basic <em>find-modify-return</em> functionality for a lot of
use cases, including multi-document, multi-collection queries.</p>

<h2>INSERT</h2>

<p>Let&rsquo;s start with an <code>INSERT</code> operation as it is the most simple to explain:</p>

<p><code>plain insert query, not returning anything
FOR i IN 1..10
  INSERT { name: CONCAT("user", i), someValue: RAND() } IN testAccounts
</code></p>

<p>The above query does not explicitly specify the <code>_key</code> attribute for the inserted
documents, meaning the database will create the documents keys automatically.
Additionally, the query assigns a random value to an attribute <code>someValue</code>.
Getting to know the created keys or random values required an extra lookup query
before 2.4. Extra queries are something one wants to avoid for efficiency
reasons.</p>

<p>With 2.4, adding two lines at the end of the query will solve the problem so
that everything can be done in one query:</p>

<p><code>plain insert query, returning the inserted documents
FOR i IN 1..10
  INSERT { name: CONCAT("user", i), someValue: RAND() } IN testAccounts
  LET inserted = NEW
  RETURN inserted
</code></p>

<p>Using a <code>LET</code> with the pseudo-value of <code>NEW</code> after the <code>INSERT</code> together with
a final <code>RETURN</code> statement will make the inserted documents appear in the query
result. Note that the full documents will be returned and not just the specified
attributes. This allows the application to track of all document attributes,
even the auto-generated ones.</p>

<h2>REMOVE</h2>

<p>The mechanism works for <code>REMOVE</code> statements, too.</p>

<p>Time to use a different example for this. Let&rsquo;s assume session metadata are
stored in the database, and some bigger session files are stored somewhere
in the filesystem. If the application needs to remove expired sessions, it
will need to clean up in both places. It will first query the database to
find the expired sessions, only to remove them from the filesystem (if the
filesystem sessions were organized by session id from the database) and to
finally remove the sessions from database itself.</p>

<p>The following query could be used to find removal candidates:</p>

<p><code>plain query for finding removal candidates
FOR session IN sessions
  FILTER session.dateExpires &lt; DATE_NOW()
  LIMIT 1000
  RETURN session._key
</code></p>

<p>The results of this query can be used for cleaning up sessions in the filesystem,
and for finally removing the sessions from the database. However, this would require
an extra <code>REMOVE</code> query. And didn&rsquo;t we say we would like to avoid extra queries?</p>

<p>The good news is that in 2.4 we can by putting at least the database part into a
single query:</p>

<p><code>plain query for removing and returning expired sessions
FOR session IN sessions
  FILTER session.dateExpires &lt; DATE_NOW()
  LIMIT 1000
  REMOVE session IN sessions
  LET removed = OLD
  RETURN removed
</code></p>

<p>The last two lines of the above query make sure the removed sessions are
returned to the application, so the application can perform any filesystem
cleanup using the session ids from the database.</p>

<p>Note that in case of <code>REMOVE</code> one has to use the pseudo-value <code>OLD</code> because
<code>REMOVE</code> can only return documents before removal. In the case of <code>INSERT</code>
we can only refer to the pseudo-value <code>NEW</code>.</p>

<h2>UPDATE and REPLACE</h2>

<p>So far we saw <code>INSERT</code> and <code>REMOVE</code>, but there are also <code>UPDATE</code> and <code>REPLACE</code>.
I will handle <code>UPDATE</code> and <code>REPLACE</code> in one go. All the following refers to
<code>UPDATE</code>, but does apply to <code>REPLACE</code> as well.</p>

<p>The mechanism to return documents from a query is the same as
already demonstrated: simply append the <code>LET ... RETURN</code> sequence to the end
of the original query.</p>

<p>In addition, <code>UPDATE</code> allows to return either the <em>old</em> document revisions
(before modification) or the <em>new</em> document revisions (after modification).
This can be expressed by using either <code>OLD</code> or <code>NEW</code> in the final <code>LET</code>
statement.</p>

<p>Following is a more complex example for an <code>UPDATE</code> query that aggregates data
from one collection (<code>phraseOccurrences</code>) in order to find and modify matching
documents in another collection (<code>phrases</code>). It will return the documents from
<code>phrases</code> before they got modified:</p>

<p><code>plain update query returning "old" documents
FOR po IN phraseOccurrences
  FILTER ! po.isSuspicious
  FILTER po.dateMentioned &gt;= '2015-01-01' &amp;&amp; po.dateMentioned &lt;= '2015-01-09'
  COLLECT phrase = po.phrase WITH COUNT INTO occurrences
  FILTER occurrences % 42 != 23
  LIMIT 13
  UPDATE phrase WITH { isSuspicious: true } IN phrases
  LET previous = OLD  /* returns document revisions before UPDATE */
  RETURN previous
</code></p>

<p>If we are interested in what the documents in <code>phrases</code> look like with the
<code>UPDATE</code> applied, we can use <code>NEW</code> instead:</p>

<p><code>plain update query returning "new" documents
FOR po IN phraseOccurrences
  FILTER ! po.isSuspicious
  FILTER po.dateMentioned &gt;= '2015-01-01' &amp;&amp; po.dateMentioned &lt;= '2015-01-09'
  COLLECT phrase = po.phrase WITH COUNT INTO occurrences
  FILTER occurrences % 42 != 23
  LIMIT 13
  UPDATE phrase WITH { isSuspicious: true } IN phrases
  LET modified = NEW  /* returns document revisions after UPDATE */
  RETURN modified
</code></p>

<p>Note that the full documents will be returned here, and not just the attributes
specified in or modified by the <code>UPDATE</code> operation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using ES6 Features in ArangoDB]]></title>
    <link href="http://jsteemann.github.io/blog/2014/12/19/using-es6-features-in-arangodb/"/>
    <updated>2014-12-19T19:12:06+01:00</updated>
    <id>http://jsteemann.github.io/blog/2014/12/19/using-es6-features-in-arangodb</id>
    <content type="html"><![CDATA[<p>ArangoDB 2.4 will be shipped with an <em>updated version of V8</em>.</p>

<p>The V8 version included in 2.4 will be 3.29.59. This version will replace the
almost two year old 3.16.14. A lot of things happened in V8 since then, and a lot
of ES6 features have been added to it.</p>

<p><strong>ES6 is not finalized yet</strong>, and support for it is a <a href="http://kangax.github.io/compat-table/es6/">work in progress on all
platforms</a>.</p>

<p>ES6 provides many cool features that can make JavaScript developer&rsquo;s life easier.
In this blog post, I&rsquo;ll summarize a few ES6 features that are available in
ArangoDB, either for scripting purposes in the ArangoShell, or in your server-side
Foxx actions inside the database.</p>

<p>I don&rsquo;t want to put you off until Doomsday. ArangoDB 2.4 should be released next
week. Time to play with some ES6 features!</p>

<!-- more -->


<h1>Summary for the impatient</h1>

<p>The following ES6 features are available in ArangoDB 2.4 by default:</p>

<ul>
<li>iterators</li>
<li>the <code>of</code> operator</li>
<li>symbols</li>
<li>predefined collections types (Map, Set etc.)</li>
<li>typed arrays</li>
</ul>


<p>Many other ES6 features are disabled by default, but can be made available by
starting arangod or arangosh with the appropriate options:</p>

<ul>
<li>arrow functions</li>
<li>proxies</li>
<li>generators</li>
<li>String, Array, and Number enhancements</li>
<li>constants</li>
<li>enhanced object and numeric literals</li>
</ul>


<p>To activate all these ES6 features, start arangod or arangosh with the following
options:</p>

<pre><code>arangosh --javascript.v8-options="--harmony --harmony_generators"
</code></pre>

<h1>Activating ES6 features</h1>

<p>Work on ES6, also dubbed <em>Harmony</em> or <em>ES.next</em>, is still in progress. At the time
of this writing, the ES6 specification was still in draft status.</p>

<p>Therefore no platform has implemented all ES6 features yet. And because ES6 is
still a moving target, the already implemented features should still be considered
experimental.</p>

<p>This is true for all environments that implement ES6 features. For example, Firefox
and other browsers contain lots of experimental ES6 features already, providing a
notice that these might change in future versions.</p>

<p>V8 is no exception here. It has turned most ES6 features off by default, but it
provides several command-line options to turn them on explicitly.</p>

<p>The V8 version used for ArangoDB 2.4 provides the following ES6-related switches:</p>

<ul>
<li><code>--harmony_scoping</code> (enable harmony block scoping)</li>
<li><code>--harmony_modules</code> (enable harmony modules (implies block scoping))</li>
<li><code>--harmony_proxies</code> (enable harmony proxies)</li>
<li><code>--harmony_generators</code> (enable harmony generators)</li>
<li><code>--harmony_numeric_literals</code> (enable harmony numeric literals (0o77, 0b11))</li>
<li><code>--harmony_strings</code> (enable harmony string)</li>
<li><code>--harmony_arrays</code> (enable harmony arrays)</li>
<li><code>--harmony_arrow_functions</code> (enable harmony arrow functions)</li>
<li><code>--harmony_classes</code> (enable harmony classes)</li>
<li><code>--harmony_object_literals</code> (enable harmony object literal extensions)</li>
<li><code>--harmony</code> (enable all harmony features (except proxies))</li>
</ul>


<p>These switches are all off by default. To turn on features for either arangod
or arangosh, start it with the V8 option(s) wrapped into the ArangoDB option
<code>--javascript.v8-options</code>, e.g.:</p>

<pre><code>arangosh --javascript.v8-options="--harmony_proxies --harmony_generators --harmony_array"
</code></pre>

<p>On a side note: node.js is also using V8. Turning on ES6 features in node.js almost
works the same way. Just omit the surrounding <code>--javascript.v8-options="..."</code>:</p>

<pre><code>node --harmony_proxies --harmony_generators --harmony_array
</code></pre>

<p>Note that the V8 options can only be set for the entire process (i.e. arangosh, arangod
or node.js), and not just for a specific script or application. In reality this shouldn&rsquo;t be
too problematic as the vast majority of ES6 features is downwards-compatible to ES5.1.</p>

<h1>ES6 features by example</h1>

<p>Following I have listed a few select ES6 features that are usable in ArangoDB 2.4,
in no particular order. I have omitted a few ES6 features that aren&rsquo;t supported in bundled
V8 version, and also omitted <em>classes</em> and <em>modules</em> due to lack of time.</p>

<h2>Arrow functions</h2>

<p>ES6 provides an optional arrow function syntax. The arrow function syntax is a shorthand for
writing a full-blown function declaration. Here&rsquo;s an example:</p>

<p>```js a simple arrow function
/<em> defines function pow </em>/
var pow = (value => value * value);</p>

<p>/<em> calls pow </em>/
pow(15);  /<em> 225 </em>/
```</p>

<p>Arrow functions can also take multiple parameters. The syntax then becomes:
```js arrow function with multiple parameters
/<em> defines function sum </em>/
var sum = (a, b) => a + b;</p>

<p>/<em> calls sum </em>/
sum(3, 7);  /<em> 10 </em>/
```</p>

<p>So far we have only seen arrow functions with simple expressions, but arrow function bodies
can also be more complex and can contain multiple statements:
```js more complex arrow functions
var translations = {
  &ldquo;en&rdquo; : &ldquo;English&rdquo;,
  &ldquo;fr&rdquo; : &ldquo;French&rdquo;,
  &ldquo;de&rdquo; : &ldquo;German&rdquo;
};</p>

<p>/<em> using multiple statements </em>/
[&ldquo;en&rdquo;, &ldquo;fr&rdquo;, &ldquo;xx&rdquo;].map(value => {
  if (translations.hasOwnProperty(value)) {</p>

<pre><code>return translations[value];
</code></pre>

<p>  }
  return &ldquo;unknown!&rdquo;;
});
```</p>

<p>Arrow functions are turned off by default. To enable them in arangod or arangosh, start them
with the option <code>--javascript.v8-options="--harmony_arrow_functions"</code>.</p>

<h2>Maps and sets</h2>

<p>ES6 maps provide a specialized alternative to regular objects in case a <em>lookup-by-key</em>
functionality is required.</p>

<p>When no maps are available, storing keys mapped to objects is normally done using a plain
object. With ES6, the same use case can be handled with using a <strong>Map</strong> object:
```js using an ES6 Map object
var m = new Map();</p>

<p>/<em> set 5M keys </em>/
for (var i = 0; i &lt; 5000000; ++i) {
  m.set(&ldquo;test&rdquo; + i, i);
}
```</p>

<p>ES6 maps can be more efficient than plain objects in some cases. For the above case of
storing 5M entries, an ES6 map is about twice as fast as a plain object on my laptop.
Though there might be cases we are plain objects are still faster.</p>

<p>There&rsquo;s more to ES6 Maps than just efficiency:</p>

<ul>
<li>ES6 maps provide a member <code>size</code> which keeps track of the number of objects in the map.
This is hard to achieve with a plain object.</li>
<li>Objects can only have string keys, whereas map keys can have different key types.</li>
<li>They don&rsquo;t inherit keys from the prototype, so there is no <code>hasOwnProperty</code> hassle with Maps.</li>
</ul>


<p>ES6 also comes with a specialized <strong>Set</strong> object. The Set object is a good alternative to
plain JavaScript objects when the use case is to track unique values. Using a Set is more
intuitive, potentially more efficient and may require even less memory than when implementing
the same functionality with a plain JavaScript object:</p>

<p>```js using an ES6 Set object
var s = new Set();</p>

<p>/<em> set 5M values </em>/
for (var i = 0; i &lt; 5000000; ++i) {
  s.add(&ldquo;test&rdquo; + i);
}
```</p>

<p>Maps and sets are enabled by default in arangod and arangosh. No special configuration is needed
to use them in your code.</p>

<h2>Proxy objects</h2>

<p>Proxy objects can be used to intercept object property accesses at runtime. This can be used
for meta-programming in many real-world situations, e.g.:</p>

<ul>
<li>preventing, auditing and logging property accesses</li>
<li>calculated / derived properties</li>
<li>adding a compatibility layer on top of an object</li>
</ul>


<p>Here&rsquo;s an example that logs property accesses on the proxied object:
```js using a Proxy object
var proxy = Proxy.create({
  get: function (obj, name) {</p>

<pre><code>console.log("read-accessing property '%s'", name);
</code></pre>

<p>  },
  set: function (obj, name) {</p>

<pre><code>console.log("write-accessing property '%s'", name);
</code></pre>

<p>  }
});</p>

<p>proxy.foo = &ldquo;bar&rdquo;;   /<em> write-accessing property &lsquo;foo&rsquo; </em>/
proxy.foo;           /<em> read-accessing property &lsquo;foo&rsquo; </em>/
```</p>

<p>Proxy objects are not available by default. To enable them in arangod or arangosh, start them
with the option <code>--javascript.v8-options="--harmony_proxies"</code>.</p>

<h2>Iterators and generators</h2>

<p>ES6 provides generators and iterators. They can be used individually or in combination.</p>

<p>Let&rsquo;s start with a simple example of a generator that will generate only two values:
```js a simple generator that generates two values
function* generate () {
  yield 23;
  yield 42;
}</p>

<p>var generator = generate();
console.log(generator.next());  /<em> { &ldquo;value&rdquo; : 23, &ldquo;done&rdquo; : false } </em>/
console.log(generator.next());  /<em> { &ldquo;value&rdquo; : 42, &ldquo;done&rdquo; : false } </em>/
console.log(generator.next());  /<em> { &ldquo;value&rdquo; : undefined, &ldquo;done&rdquo; : true } </em>/
<code>``
As can be seen above, the value yielded by the generator function will be returned
wrapped into an object with a</code>value<code>and a</code>done` attribute automatically.</p>

<p>The general pattern to consume all values from a generator function is to call
its <code>next()</code> method until its <code>done</code> value is <code>true</code>:
```js consuming all values from a generator function
var generator = generate();</p>

<p>while (true) {
  value = generator.next();
  if (value.done) {</p>

<pre><code>break;
</code></pre>

<p>  }
  console.log(value.value);
}
```</p>

<p>An alternative to that is to use an iterator (note the new <code>of</code> operator):
```js consuming all values from a generator function
var generator = generate();</p>

<p>for (var value of generator) {
  console.log(value);
}
```</p>

<p>Generator functions produce their values lazily. Therefore it is possible
and not inefficent to write generators that produce never-ending sequences.
Though one must be careful to abort iterating over the generator values
at some point if the sequence does not terminate:
```js a generator producing an endless sequence
function* generate () {
  var i = 0;
  while (true) {</p>

<pre><code>yield ++i;
</code></pre>

<p>  }
}</p>

<p>var generator = generate();</p>

<p>/<em> note: this will not terminate </em>/
for (var value of generator) {
  console.log(value);
}
```</p>

<p>We have now seen two uses of iterators as part of the previous examples.
As demoed, generator function values can be iterated with the <code>of</code> operator
without any further ado. Apart from generators, a few other built-in types
also provide ready-to-use iterators. The most prominent are <code>String</code> and <code>Array</code>:
```js iterating over the characters of a string
var text = &ldquo;this is a test string&rdquo;;</p>

<p>for (var value of text) {
  console.log(value);
}
```
The above example will iterate all the individual characters of the string.</p>

<p>The following example iterates the values of an Array:
```js iterating over the values of an array
var values = [ &ldquo;this&rdquo;, &ldquo;is&rdquo;, &ldquo;a&rdquo;, &ldquo;test&rdquo; ];</p>

<p>for (var value of values) {
  console.log(value);
}
<code>``
This will produce</code>&ldquo;this&rdquo;<code>,</code>&ldquo;is&rdquo;<code>,</code>&ldquo;a&rdquo;<code>,</code>&ldquo;test&rdquo;<code>. This is normally what is
desired when iterating over the values of an Array. Compare this to the</code>in<code>
operator which would produce</code>0<code>,</code>1<code>,</code>2<code>and</code>3` instead.</p>

<p>Map and Set objects also implement iterators:
```js iterating over the contents of a Map
var m = new Map();</p>

<p>m.set(&ldquo;Sweden&rdquo;, &ldquo;Europe&rdquo;);
m.set(&ldquo;China&rdquo;, &ldquo;Asia&rdquo;);
m.set(&ldquo;Bolivia&rdquo;, &ldquo;South America&rdquo;);
m.set(&ldquo;Australia&rdquo;, &ldquo;Australia&rdquo;);
m.set(&ldquo;South Africa&rdquo;, &ldquo;Africa&rdquo;);</p>

<p>for (var value of m) {
  console.log(value);
}
```</p>

<p>Note that Maps also provide dedicated iterators for just their keys or
their values:
```js iterating over keys and values of a Map
for (var country of m.keys()) {
  console.log(country);
}</p>

<p>for (var continent of m.values()) {
  console.log(continent);
}
```</p>

<p>Rolling an iterator for your own object is also possible by implementing the method
<code>Symbol.iterator</code> for it:
```js creating an iterator for an object
function Sentence (text) {
  this.text = text;
}</p>

<p>/<em> create the actual iterator method </em>/
/<em> note that the iterator is a generator function here </em>/
Sentence.prototype[Symbol.iterator] = function*() {
  var regex = /\S+/g;
  var text = this.text;
  var match;
  while (match = regex.exec(text)) {</p>

<pre><code>yield match[0]; 
</code></pre>

<p>  }
};</p>

<p>var sentence = new Sentence(&ldquo;The quick brown fox jumped over the lazy dog&rdquo;);
/<em> invoke the iterator </em>/
for (var word of sentence) {
  console.log(word);
}
```</p>

<p>Generators and iterators are not available by default. To enable them in arangod
or arangosh, start them with the option <code>--javascript.v8-options="--harmony_generators"</code>.</p>

<h2>String enhancements</h2>

<p>ES6 provides the following convenience string functions:</p>

<ul>
<li>string.startsWith(what)</li>
<li>string.endsWith(what)</li>
<li>string.contains(what)</li>
<li>string.repeat(count)</li>
<li>string.normalize(method)</li>
<li>string.codePointAt(position)</li>
<li>String.fromCodePoint(codePoint)</li>
</ul>


<p>These functions are mostly self-explaining, so I won&rsquo;t explain them in more
detail here. Apart from that, these functions are turned off by default.
To enable them in arangod or arangosh, start them with the option
<code>--javascript.v8-options="--harmony_strings"</code>.</p>

<h2>Array enhancements</h2>

<p>ES6 provides the following enhancements for the <code>Array</code> object:</p>

<ul>
<li>array.find(function)</li>
<li>array.findIndex(function)</li>
<li>array.keys()</li>
<li>array.values()</li>
<li>Array.observe(what, function)</li>
</ul>


<p>Here are a few examples demoing these functions:
```js Array enhancements
var values = [ 1, 2, 9, 23, 42 ];</p>

<p>/<em> returns the first Array element for which the function returns true </em>/
values.find(function (value) {
  return value === 23;
});</p>

<p>/<em> returns the first Array index for which the function returns true </em>/
values.findIndex(function (value) {
  return value === 23;
});</p>

<p>/<em> iterate over the keys of the Array </em>/
for (var key of values.keys()) {
  console.log(key);
}</p>

<p>/<em> iterate over the values of the Array </em>/
for (var key of values.values()) {
  console.log(key);
}</p>

<p>/<em> observe all changes to an Array </em>/
Array.observe(values, function (changes) {
  console.log(changes);
});</p>

<p>/<em> trigger a change to the observed Array </em>/
values.push(117);
```</p>

<p>The Array enhancements are turned off by default. To enable them in arangod or
arangosh, start them with the option <code>--javascript.v8-options="--harmony_arrays"</code>.</p>

<h2>Number enhancements</h2>

<p>The <code>Number</code> object is extended with the following ES6 functions:</p>

<ul>
<li>Number.isInteger(value)</li>
<li>Number.isSafeInteger(value)</li>
</ul>


<p>There are also <code>Number.MIN_SAFE_INTEGER</code> and <code>Number.MAX_SAFE_INTEGER</code> so applications
can programmatically check whether a numeric value can still be stored in the range of
-2<sup>53</sup> to +2<sup>53</sup> without potential precision loss.</p>

<h2>Constants</h2>

<p>The <code>const</code> keyword can be used to define a read-only constant. The constant must be
initialized and a variable with the same name should not be redeclared in the same scope.</p>

<p>Here is an example of using <code>const</code>:
<code>js using const to create a read-only variable
function calculate (value) {
  const magicPrime = 23;
  return magicPrime ^ value;
}
</code></p>

<p>In non-strict mode, <code>const</code> variables behave non-intuitively. Re-assigning a value
to a variable declared <code>const</code> does not throw an exception, but the assignment will
not be carried out either. Instead, the assignment will silently fail and the <code>const</code>
variable will keep its original value:</p>

<p><code>js re-assigning a value to a const variable
function mystery () {
  const life = 42;
  life = 23;        /* does not change value and does not throw! */
  return life;      /* will return 42 */
}
</code></p>

<p><code>js re-assigning a value to a const variable, using strict mode
function mystery () {
  "use strict";
  const life = 42;
  life = 23;        /* will throw SyntaxError "assignment to constant variable" */
}
</code></p>

<p>The <code>const</code> keyword is disabled by default. To enable it in arangod or arangosh,
start them with the option <code>--javascript.v8-options="--harmony_scoping"</code>.</p>

<h2>Enhanced object literals</h2>

<p>ES6 provides a shorthand for defining methods in object literals.</p>

<p>The following example creates a normal method named <code>save</code> in <code>myObject</code>:</p>

<p>```js shorthand method declaration
var myObject = {
  type: &ldquo;myType&rdquo;,
  save () {</p>

<pre><code>console.log("save");
</code></pre>

<p>  }
};
```</p>

<p>Interestingly, the object literals seem to work for method declarations only.
I did not get them to work for non-method object properties, though ES6 allows that.
It seems that this is not implemented in V8 yet.</p>

<p>Enhanced object literals are turned off by default. To enable them in arangod
or arangosh, start them with the option <code>--javascript.v8-options="--harmony_object_literals"</code>.</p>

<h2>Enhanced numeric literals</h2>

<p>For the ones that love working with binary- or octal-encoded numbers, ES6 has
support for this too:
<code>js numeric literals
var life = 0b101010;          /* binary, 42 in decimal */
var filePermissions = 0o777;  /* octal, 511 in decimal */
</code></p>

<p>Enhanced numeric literals are turned off by default. To enable them in arangod
or arangosh, start them with the option <code>--javascript.v8-options="--harmony_numeric_literals"</code>.</p>

<h2>Symbols</h2>

<p>ES6 also provides a Symbol type. Symbols are created using the global <code>Symbol()</code> function.
Each time this function is called, a new Symbol object will be created.
A Symbol can be given an optional name, but this name cannot be used to identify the
Symbol later. However, Symbols can be compared by identity.</p>

<p>What one normally wants is to use the same Symbol from different program parts. In this
case, a Symbol should not be created with the <code>Symbol()</code> function, but with <code>Symbol.for()</code>.
This will register the Symbol in a global symbol table if it is not there yet, and return
the Symbol if already created:</p>

<p>```js using named Symbols
var typeAttribute = Symbol.for(&ldquo;type&rdquo;);
var carType = Symbol.for(&ldquo;car&rdquo;);
var trainType = Symbol.for(&ldquo;train&rdquo;);</p>

<p>var object1 = { };
object1[typeAttribute] = carType;</p>

<p>var object2 = { };
object2[typeAttribute] = trainType;</p>

<p>/<em> check if the objects have the same type </em>/
object1[typeAttribute] === object2[typeAttribute];  /<em> false </em>/
object1[typeAttribute] === carType;                 /<em> true </em>/
object2[typeAttribute] === carType;                 /<em> false </em>/
object2[typeAttribute] === trainType;               /<em> true </em>/
```</p>

<p>Symbol object properties are not enumerated by default, so they can be used to implement
&ldquo;hidden&rdquo; or internal properties.</p>

<p>Symbols can be used by default in arangod and arangosh. No special configuration is required.</p>

<h2>TypedArrays</h2>

<p>TypedArrays are Arrays whose members all have the same type and size. They are more
specialized (read: limited but efficient) alternatives to the all-purpose <code>Array</code> type.</p>

<p>TypedArrays look and feel a bit like C arrays, and they are often used as an Array-like
view into binary data (for which JavaScript has no native support).</p>

<p>A TypedArray is created (and all of its memory is allocated) by invoking the appropriate
TypedArray constructor:</p>

<ul>
<li>Int8Array</li>
<li>Uint8Array</li>
<li>Uint8ClampedArray</li>
<li>Int16Array</li>
<li>Uint16Array</li>
<li>Int32Array</li>
<li>Uint32Array</li>
<li>Float32Array</li>
<li>Float64Array</li>
</ul>


<p>```js using an Array of unsigned 8 bit integers
var data = new Uint8Array(2);
data[0] = 0b00010101;  /<em> 23 </em>/
data[1] = 0b00101010;  /<em> 42 </em>/</p>

<p>console.log(data[0]);  /<em> 23 </em>/
console.log(data.length * data.BYTES_PER_ELEMENT); /<em> 2 bytes </em>/
```</p>

<p>```js using an Array of 64 bit floating point values
var data = new Float64Array(2);
data[0] = 23.23;</p>

<p>console.log(data[0]);  /<em> 23.23 </em>/
console.log(data[1]);  /<em> 0.0 </em>/
console.log(data.length * data.BYTES_PER_ELEMENT); /<em> 16 bytes </em>/
```</p>

<p>TypedArrays can be used in arangod and arangosh by default. No special
configuration is required to activate them.</p>

<h2>Unsupported ES6 features</h2>

<p>As mentioned before, V8 does not yet support every proposed ES6 feature.
For example, the following ES6 features are currently missing:</p>

<ul>
<li>template strings</li>
<li>function default parameters</li>
<li>rest function parameter</li>
<li>spread operator</li>
<li>destructuring</li>
<li>array comprehension</li>
<li><code>let</code></li>
</ul>


<p>I strongly hope these features will make it into the final version of ES6 and will be
implemented by the V8 team in future versions of V8.</p>

<p>Apart from that, a lot of nice ES6 features are there already and can be used
in ArangoDB applications.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AQL Improvements for 2.4]]></title>
    <link href="http://jsteemann.github.io/blog/2014/12/12/aql-improvements-for-24/"/>
    <updated>2014-12-12T23:35:08+01:00</updated>
    <id>http://jsteemann.github.io/blog/2014/12/12/aql-improvements-for-24</id>
    <content type="html"><![CDATA[<p>While on a retreat in Belgium, we found some spare time to
work on improvements for AQL. These will be shipped with
ArangoDB version 2.4, and are already available in the devel
version for testing from now on.</p>

<p>Here&rsquo;s a short overview of the improvements:</p>

<!-- more -->


<h1>COLLECT WITH COUNT</h1>

<p>A common use case in query languages is to count the number of
documents returned by a query. The AQL solution for this has been
to use the <code>LENGTH</code> function and a subquery:</p>

<p>```
RETURN LENGTH((
  FOR doc IN collection</p>

<pre><code>FILTER doc.someAttribute == someValue
RETURN doc
</code></pre>

<p>  )
)
```</p>

<p>This works but is probably unintuitive for people which have
used SQL for years.</p>

<p>We therefore now allow using the following alternative syntax,
using the new <code>COLLECT ... WITH COUNT INTO ...</code> clause:</p>

<p><code>
FOR doc IN collection
  FILTER doc.someAttribute == someValue
  COLLECT WITH COUNT INTO length
  RETURN length
</code></p>

<p>This query returns just the total number of matches, but not the
matches themselves. As this query is made for counting only, it
can be executed more efficiently than the original query.
In the query with the <code>COUNT INTO ...</code> clause, the documents found
by the filter condition will only be counted and then instantly
discarded. They will not be shipped around inside the query, from
the subquery to the top level into the <code>LENGTH()</code> function.</p>

<p>This new variant will be drastically faster than the old variant
if there is no filter condition at all. When there is a filter
condition, evaluating the filter condition might be the most computationally
expensive part of the query. But even then, the new variant should
be faster than the old one and use less memory.</p>

<p>As a bonus, there is no need to use a subquery anymore, though the
subquery variant is still fully supported and will be.</p>

<p><code>COLLECT ... WITH COUNT</code> also works for counting the number of items
per group:</p>

<p><code>
FOR doc IN collection
  COLLECT value = doc.someAttribute WITH COUNT INTO length
  RETURN { value: value, length : length }
</code></p>

<p>This returns the number of matches for each distinct <code>value</code>.</p>

<p>A quick unscientific benchmark reveals that the specialized
<code>WITH COUNT</code> clause seems to be faster than the old variant.
The following results show the differences for a collection with
500,000 small documents:</p>

<p>The old variant that counts the number of documents per age runs
in 4.75 seconds on my laptop:</p>

<p><code>
FOR doc IN collection
  FILTER doc.age &lt; 20
  COLLECT age = doc.age INTO g
  RETURN { age: age, length: LENGTH(g) }
</code></p>

<p>The new variant produces the same result, but runs in 0.6 seconds locally:</p>

<p><code>
FOR doc IN collection
  COLLECT age = doc.age WITH COUNT INTO length
  RETURN { age: age, length: length }
</code></p>

<p>A notable speedup can also be observed if only a fraction of the
groups is built (here: 1/8). The old variant for this runs in 0.6
seconds:</p>

<p><code>
FOR doc IN collection
  FILTER doc.age &lt; 20
  COLLECT age = doc.age INTO g
  RETURN { age: age, length: LENGTH(g) }
</code></p>

<p>The new variant runs in 0.12 seconds:</p>

<p><code>
FOR doc IN collection
  FILTER doc.age &lt; 20
  COLLECT age = doc.age WITH COUNT INTO length
  RETURN { age: age, length: length }
</code></p>

<p>The absolute times may vary greatly depending on the type of documents and
the hardware used, but in general the new variant should provide a
speedup.</p>

<h1>COLLECT with group expression</h1>

<p>Finally, <code>COLLECT ... INTO</code> has been extended to support just another variant
that can reduce the amount of copying inside a query.</p>

<p>Let&rsquo;s have a look at this example query:</p>

<p><code>
FOR doc IN collection
  COLLECT age = doc.age INTO g
  RETURN { age: age, maxDate: MAX(g[*].doc.dateRegistered) }
</code></p>

<p>In the above query, for each distinct <code>age</code> value, all documents are collected
into variable <code>g</code>. When the collecting phase is over, there will be an iteration
over all the collected documents again, to extract their <code>dateRegistered</code> value.
After that, the <code>dateRegistered</code> values will be passed into the <code>MAX()</code> function.</p>

<p>This query can be made more efficient now as follows:</p>

<p><code>
FOR doc IN collection
  COLLECT age = doc.age INTO g = doc.dateRegistered
  RETURN { age: age, maxDate: MAX(g) }
</code></p>

<p>The new thing about this variant is the expression following the <code>INTO</code>.
Having an expression there allows controlling what values are collected for
each group. Using a projection expression here can greatly reduce the
amount of copying afterwards, and thus make the query more efficient than if
it had to copy the entire documents.</p>

<h1>Removing filters covered by indexes</h1>

<p><code>FILTER</code> conditions which are completely covered by indexes will
now be removed from the execution plan if it is safe to do so.
Dropping the <code>FILTER</code> statements allows the optimizer to get rid
of not only the <em>FilterNode</em>, but also its corresponding <em>CalculationNode</em>.
This will save a lot of computation if the condition needs to be checked
for many documents.</p>

<p>For example, imagine the following query:</p>

<p><code>
FOR doc IN collection
  FILTER doc.value &lt; 10
  RETURN doc
</code></p>

<p>If there is a (skiplist) index on <code>doc.value</code>, the optimizer may
decide to use this index. It will replace the query&rsquo;s <em>EnumerateCollectionNode</em>
with an <em>IndexRangeNode</em> instead first. The <em>IndexRangeNode</em> will scan the index
on <code>doc.value</code> for the range [-inf, 10).</p>

<p>Following that, the optimizer rule <code>remove-filter-covered-by-index</code>
should fire and detect that the <code>FILTER</code> condition is already covered
by the <em>IndexRangeNode</em> alone. It can thus remove the <em>FilterNode</em>.
This also makes the <em>CalculationNode</em> of the <em>FilterNode</em> obsolete,
so these two nodes will be removed and computation is saved.</p>

<h1>Removing brackets for subquery function call parameters</h1>

<p>Since the beginning of AQL, the parser required the user the put
subqueries that were used as function parameters inside two pairs of
brackets.</p>

<p>For example, the following query did not parse in 2.3 and before:
<code>
RETURN LENGTH(FOR doc IN collection RETURN doc)
</code></p>

<p>Instead, it needed to be written as:
<code>
RETURN LENGTH((FOR doc IN collection RETURN doc))
</code></p>

<p>If you didn&rsquo;t notice the difference, the latter version of the query had
duplicate parentheses. The requirement to use duplicate parentheses has
caused several support questions over time, and this can be taken as a
proof that it was not intuitive.</p>

<p>The requirement for duplicate parentheses was an artifact required by the
AQL parser grammar in order to parse the query correctly.</p>

<p>For 2.4, the AQL grammar has been cleaned up in this respect.
Duplicate parentheses are still allowed and work fine in 2.4 but they are not
required anymore. This should make the first steps with AQL a bit easier
and more intuitive.</p>

<p>We&rsquo;re 1.5 days into our retreat now. Maybe there&rsquo;ll be some more
AQL-related improvements in the end. Let&rsquo;s see.</p>
]]></content>
  </entry>
  
</feed>
