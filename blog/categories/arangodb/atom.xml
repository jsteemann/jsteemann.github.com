<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ArangoDB | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/arangodb/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2015-07-30T14:57:27+02:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Throughput Enhancements]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/30/throughput-enhancements/"/>
    <updated>2015-07-30T12:54:12+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/30/throughput-enhancements</id>
    <content type="html"><![CDATA[<p>We&rsquo;ve recently been working on improving ArangoDB&rsquo;s throughput,
especially when using the ArangoDB&rsquo;s interface.</p>

<p>In this post, I will show some of the improvements already achieved,
though the work is not yet finished. Therefore, the results shown here
are still somewhat preliminary.</p>

<!-- more -->


<p>We wanted to measure improvements for ArangoDB&rsquo;s HTTP interface, and so we used
<a href="https://github.com/wg/wrk"><em>wrk</em></a> as an external HTTP load generator.</p>

<p>During the tests, <em>wrk</em> called some specific URLs on a local ArangoDB instance on
an otherwise idle machine. The test was run with ArangoDB 2.6 and <code>devel</code>. The
ArangoDB instances were started with their default configuration.</p>

<p><em>wrk</em> was invoked with varying amounts of client connections and threads, so the
tests cover serial and concurrent/parallel requests:</p>

<p><code>bash invoking wrk
wrk -c $CONNECTIONS -t $THREADS -d 10 $URL
</code></p>

<p>The number of connections (<code>$CONNECTIONS</code>) and theads (<code>$THREADS</code>) were both varied
from 1 to 8. <em>wrk</em> requires at least as many connections as threads.</p>

<p>The first URL tested was a route in a simple Foxx application that inserts the data
shipped in the HTTP request into a collection on the server. The internals of the
route should not matter here, as this post focuses on the throughput improvements.</p>

<p>Following are the results for calling the route with <em>wrk</em>, comparing the stable
ArangoDB version (2.6.3) with the current development version (head of <code>devel</code> branch
as of today). The table shows the number of documents that were inserted during the
10 seconds the <em>wrk</em> client ran:</p>

<p>```</p>

<h2>Threads      Connections        2.6       devel</h2>

<pre><code>  1                1      12569       20157 
  1                2      28094       36031   
  1                4      46310       66524 
  1                8      46798       80667
</code></pre>

<p>```</p>

<p>As can be seen above, <code>devel</code> was able to handle much more requests than 2.6 even
with a single connection (i.e. serial client requests). Throughput was about 60 %
higher for this case.</p>

<p>When increasing the number of client connections, the number of requests handled by
<code>devel</code> ws also higher than that of 2.6, with improvements between around 25 and 70 %.</p>

<p>When increasing the number of client load generation threads, the picture doesn&rsquo;t
change much. Here&rsquo;s the full table of results:</p>

<p>```</p>

<h2>Threads      Connections        2.6       devel</h2>

<pre><code>  1                1      12569       20157 
  1                2      28094       36031   
  1                4      46310       66524 
  1                8      46798       80667

  2                2      28931       36326    
  2                4      47181       67654    
  2                8      47594       88617 

  4                4      46553       67585   
  4                8      47531       86935 

  8                8      46431       91953 
</code></pre>

<p>```</p>

<p>The next test consisted of inserting documents into a collection again, but using the
built-in HTTP API for creating documents instead of a user-defined Foxx application.
Throughput is expected to be higher than in the Foxx case because the built-in method
is hard-wired and only serves a single purpose, whereas the Foxx route is user-definable
and capable of doing fancy things, such as validating data, restricting access etc.</p>

<p>Here are the results for calling the hard-wired insertion route, again for 2.6 and <code>devel</code>:</p>

<p>```</p>

<h2>Threads      Connections        2.6       devel</h2>

<pre><code>  1                1     102133      112843 
  1                2     185529      210795 
  1                4     335607      373070
  1                8     518354      576034

  2                2     181237      196482 
  2                4     345455      363255
  2                8     474558      550835

  4                4     318331      355328
  4                8     483388      516100

  8                8     482369      527395
</code></pre>

<p>```</p>

<p><code>devel</code> provides higher throughput than 2.6 for this route as well. Improvements fell
into the range of between 5 and 15 %. That&rsquo;s not as impressive as in the Foxx route
case above, but still a welcome improvement.</p>

<p>And of course we&rsquo;ll try to improve the throughput further.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Set Up Fish Completion for ArangoDB]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/28/how-to-set-up-fish-completion-for-arangodb/"/>
    <updated>2015-07-28T23:10:32+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/28/how-to-set-up-fish-completion-for-arangodb</id>
    <content type="html"><![CDATA[<p>While experimenting with the <a href="http://fishshell.com/">fish shell</a> on my laptop
I found <em>fish</em> has a slightly different (but much fancier) tab-completion mechanism
than <em>bash</em>.</p>

<p>Re-using the <a href="/blog/2014/10/22/how-to-set-up-bash-completion-for-arangodb/">existing completer for bash</a>
wouldn&rsquo;t work, so I put together some dedicated completions files for <em>fish</em>.</p>

<!-- more -->


<p>The files can be downloaded here:
<a href="/downloads/code/completions-fish-2.5">2.5</a> <a href="/downloads/code/completions-fish-2.6">2.6</a></p>

<p>To activate these completions, copy the appropriate file into <code>~/.arangodb-completions</code>
and source it from <em>fish</em>:
<code>bash
source ~/.arangodb-completions
</code></p>

<p>In order to permanently activate these completions, you may source the completions file
from your <code>config.fish</code> file, which is normally located in directory <code>~/.config/fish</code>.</p>

<h2>Full setup</h2>

<p>The following command, executed in <em>fish</em>, should install the completions for 2.6 and
activate them:
<code>bash activate completions for ArangoDB 2.6
wget -O ~/.arangodb-completions https://jsteemann.github.io/downloads/code/completions-fish-2.6
echo "source ~/.arangodb-completions" &gt;&gt; ~/.config/fish/config.fish
source ~/.arangodb-completions
</code></p>

<p>To install fish completions for ArangoDB 2.5, the command is:
<code>bash activate completions for ArangoDB 2.5
wget -O ~/.arangodb-completions https://jsteemann.github.io/downloads/code/completions-fish-2.5
echo "source ~/.arangodb-completions" &gt;&gt; ~/.config/fish/config.fish
source ~/.arangodb-completions
</code></p>

<p>To see it in action, type <code>arangosh --</code> in <em>fish</em> and then press <strong>TAB</strong>:</p>

<p><img src="/downloads/screenshots/fish-completion.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing RETURN DISTINCT]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/27/introducing-return-distinct/"/>
    <updated>2015-07-27T11:48:41+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/27/introducing-return-distinct</id>
    <content type="html"><![CDATA[<p>Last week saw the addition of the <code>RETURN DISTINCT</code> for AQL queries.
This is a new shortcut syntax for making result sets unique.</p>

<p>For this purpose it can be used as an easier-to-memorize alternative for
the already existing <code>COLLECT</code> statement. <code>COLLECT</code> is very flexible and
can be used for multiple purposes, but it is syntactic overkill for making
a result set unique.</p>

<p>The new <code>RETURN DISTINCT</code> syntax makes queries easier to write and understand.</p>

<!-- more -->


<p>Here&rsquo;s a non-scientific proof for this claim:</p>

<p>Compare the following queries, which both return each distinct <code>age</code> attribute
value from the collection:</p>

<p><code>plain making result set unique using COLLECT
FOR doc IN collection
  COLLECT age = doc.age
  RETURN age
</code></p>

<p><code>plain making result set unique using RETURN DISTINCT
FOR doc IN collection
  RETURN DISTINCT doc.age
</code></p>

<p>Clearly, the query using <code>RETURN DISTINCT</code> is more intuitive, especially for
AQL beginners. Apart from that, using <code>RETURN DISTINCT</code> will save a bit of typing
compared to the longer <code>COLLECT</code>-based query.</p>

<p>Internally both <code>COLLECT</code> and <code>RETURN DISTINCT</code> will work by creating an
<code>AggregateNode</code>. The optimizer will try the <em>sorted</em> and the <em>hashed</em> variants
for both, so they should perform about the same.</p>

<p>However, the result of a <code>RETURN DISTINCT</code> does not have any guaranteed order,
so the optimizer will not insert a post-<code>SORT</code> for it. It may do so for a regular
<code>COLLECT</code>.</p>

<p>As mentioned before, <code>COLLECT</code> is more flexible than <code>RETURN DISTINCT</code>.
Notably, <code>COLLECT</code> is superior to <code>RETURN DISTINCT</code> when the result set should
be made unique using more than one criterion, e.g.</p>

<p><code>plain using more than one criterion for uniqueness
FOR doc IN collection
  COLLECT status = doc.status, age = doc.age,
  RETURN { status, age }
</code></p>

<p>This is currently not achievable via <code>RETURN DISTINCT</code>, as it only works
with a single criterion.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AQL Object Literal Simplification]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/27/aql-object-literal-simplification/"/>
    <updated>2015-07-27T11:33:09+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/27/aql-object-literal-simplification</id>
    <content type="html"><![CDATA[<p>ArangoDB&rsquo;s <code>devel</code> branch recently saw a change that makes writing
some AQL queries a bit simpler.</p>

<p>The change introduces an optional shorthand notation for object attributes
in the style of ES6&rsquo;s enhanced object literal notation.</p>

<!-- more -->


<p>For example, consider the following query that groups values by <code>age</code>
attribute and counts the number of documents per distinct <code>age</code> value:</p>

<p><code>plain example query
FOR doc IN collection
  COLLECT age = doc.age WITH COUNT INTO length
  RETURN { age: age, length: length }
</code></p>

<p>The object declaration in the last line of the query is somewhat redundant
because one has to type identical attribute names and values:</p>

<p><code>plain the long notation for object literals
RETURN { age: age, length: length }
</code></p>

<p>In this case, the new shorthand notation simplifies the <code>RETURN</code> to:</p>

<p><code>plain using shorthand notation for object literals
RETURN { age, length }
</code></p>

<p>In general, the shorthand notation can be used for all object literals when
there is an attribute name that refers to a query variable of the same name.</p>

<p>It can also be mixed with the longer notation, e.g.:</p>

<p><code>plain mixing long and shorthand notation
RETURN { age, length, dateCreated: DATE_NOW() }
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 Features in ArangoDB 2.7]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/14/es6-features-in-arangodb-27/"/>
    <updated>2015-07-14T20:33:55+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/14/es6-features-in-arangodb-27</id>
    <content type="html"><![CDATA[<p>ArangoDB 2.6 uses V8 engine version 3.31.74.1 for running its own and all user-defined
JavaScript code. In ArangoDB 2.7 (currently in development), we have upgraded V8 to
version 4.3.61.</p>

<p>The new V8 version in ArangoDB 2.7 provides several additional ES6 features that can
be used to improve JavaScript usability and code quality. This blog post showcases <em>strong
mode</em> and <em>rest parameters</em>, and also shows how to activate <em>TurboFan</em>, V8&rsquo;s new JIT compiler
for JavaScript.</p>

<p>ArangoDB 2.7 is in development right now, but it can be tried today by
<a href="/blog/2014/10/16/how-to-compile-arangodb-from-source/">compiling it from source</a>.</p>

<!-- more -->


<h2>JavaScript strong mode</h2>

<p>V8 v4 comes with an optional and experimental <em>strong mode</em>. This mode provides only a
subset of JavaScript, with the idea of intentionally deactivating some of
<a href="http://archive.oreilly.com/pub/a/javascript/excerpts/javascript-good-parts/bad-parts.html">JavaScript&rsquo;s bad parts</a>.
It is based on <em>strict mode</em>, but goes further.</p>

<p>Committing to <em>strong mode</em> may not only provide better and stronger semantics, but may
also enable more optimization opportunities for the JavaScript compiler. For example, the
strong mode disables JavaScript&rsquo;s <em>with</em> statement and <code>delete</code>! Additionally, <code>var</code> cannot
be used anymore but is deprecated in favor of <code>let</code> and <code>const</code>.</p>

<p>The proposal for the strong mode can be found
<a href="https://docs.google.com/document/d/1Qk0qC4s_XNCLemj42FqfsRLp49nDQMZ1y7fwf5YjaI4/view">here</a>,
and the V8 team also has a <a href="https://developers.google.com/v8/experiments">page about it</a>.</p>

<p>Strong mode must be turned on explicitly. This can be done by adding the <code>--strong-mode=true</code>
v8 option when starting <em>arangod</em> or <em>arangosh</em>:</p>

<p><code>bash enabling strong mode
arangosh  --javascript.v8-options="--strong_mode=true"
</code></p>

<p>Note that I am using <em>arangosh</em> above, but the same would work for <em>arangod</em>, too, so the feature
can be used for Foxx routes as well.</p>

<h2>Rest parameters</h2>

<p>How to pass a variable number of arguments to a function?</p>

<p>C and C++ programmers have been using and abusing the ellipsis (<code>...</code>) and <code>__VA_ARGS__</code> features
of the C preprocessor for a long time. Then came the macros of <code>stdarg.h</code> / <code>cstdarg</code>,
until C++11 really improved the situation with <code>std::initializer_list</code> and variadic templates.</p>

<p>In JavaScript, one can use the <code>arguments</code> object:
```js
function logSimple () {
  for (value of arguments) {</p>

<pre><code>console.log(value);
</code></pre>

<p>  }
}</p>

<p>logSimple(&ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;);
```</p>

<p>This does the job, and the above will print something like:
<code>plain
2015-07-14T19:01:51Z [5245] INFO foo
2015-07-14T19:01:51Z [5245] INFO bar
2015-07-14T19:01:51Z [5245] INFO baz
</code></p>

<p>This is fine as long as all arguments shall be treated the same way. But what if some
arguments have a designated meaning and should be treated specially?</p>

<p>The solution is to use <em>ES6 rest parameters</em>. The last parameter in an argument list can be
prefixed with <code>...</code> to capture any number of function parameters:</p>

<p>```js
function logWithContext (context, &hellip;values) {
  for (value of values) {</p>

<pre><code>console.log('[' + context + '] ' + value);
</code></pre>

<p>  }
}</p>

<p>logWithContext(&ldquo;es6&rdquo;, &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;);
```</p>

<p>As can be seen, the <code>logWithContext</code> function specially handles its <code>context</code> argument, while
we can still pass any number of further parameters into it. Here&rsquo;s what the above will print:</p>

<p><code>plain
2015-07-14T19:07:27Z [5245] INFO [es6]: foo
2015-07-14T19:07:27Z [5245] INFO [es6]: bar
2015-07-14T19:07:27Z [5245] INFO [es6]: baz
</code></p>

<p>Note that rest parameters cannot be used with the default configuration and must be turned on
explicitly in <em>arangosh</em> or <em>arangod</em>.</p>

<p>The startup option to turn them on is:</p>

<p><code>bash enabling rest parameters
arangosh --javascript.v8-options="--harmony_rest_parameters=true"
</code></p>

<h2>TurboFan</h2>

<p>The new V8 version comes with <em>TurboFan</em>, a new JIT compiler for JavaScript.
According to <a href="http://blog.chromium.org/2015/07/revving-up-javascript-performance-with.html">this post</a>
it is already used in Chrome for compiling certain types of JavaScript code.</p>

<p>As fas as I can see, it is turned off by default in our version of V8, and the compiler
also seems to be rather experimental. To get an idea of what it can already do and where
its limits are, it can already be tried in ArangoDB 2.7.</p>

<p>By default, it seems to be turned off. Using the following startup option, it can be turned on for
JavaScript functions with a certain name pattern (i.e. all function names starting with <em>testTurboFan</em>):</p>

<p><code>bash starting ArangoShell with TurboFan enabled
arangosh --javascript.v8-options="--turbo-filter=testTurboFan*"`
</code></p>

<p>Without turning on V8 tracing, one will not be able to tell which compiler is used to compile a
specific function. To turn it on and actually confirm V8 is using TurboFan, use these options:</p>

<p><code>bash starting ArangoShell with TurboFan and debug output
arangosh --javascript.v8-options="--always-opt --trace_opt --turbo-filter=testTurboFan*"
</code></p>

<p>This will be very verbose, but it is good to tell which internal compiler is used to compile a given
JavaScript function.</p>

<p>For example, after starting the ArangoShell with the above options, run the following test code
to see that V8 uses TurboFan for compiling the first two functions (which match the name pattern),
and Crankshaft for the third (which does not match the name pattern):</p>

<p>```js test code for invoking the TurboFan compiler
function testTurboFan1 () {
  console.log(&ldquo;turbo-fan 1&rdquo;);
}
testTurboFan1();</p>

<p>function testTurboFan2 () {
  console.log(&ldquo;turbo-fan 2&rdquo;);
}
testTurboFan2();</p>

<p>function testSomethingElse () {
  console.log(&ldquo;something else&rdquo;);
}
testSomethingElse();
```</p>

<p>Here&rsquo;s the confirmation that TurboFan is used:</p>

<p><code>plain debug output
...
[compiling method 0x31ca8804e351 &lt;JS Function testTurboFan1 (SharedFunctionInfo 0x31ca8804e171)&gt; using TurboFan]
...
[compiling method 0x31ca8804e7f9 &lt;JS Function testTurboFan2 (SharedFunctionInfo 0x31ca8804e619)&gt; using TurboFan]
...
[compiling method 0x31ca8804ec71 &lt;JS Function testSomethingElse (SharedFunctionInfo 0x31ca8804ea91)&gt; using Crankshaft]
...
</code></p>

<p>Have fun!</p>
]]></content>
  </entry>
  
</feed>
