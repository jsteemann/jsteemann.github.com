<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: valgrind | blog4j]]></title>
  <link href="http://jsteemann.github.com/blog/categories/valgrind/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.com/"/>
  <updated>2013-01-11T00:46:49+01:00</updated>
  <id>http://jsteemann.github.com/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using callgrind_control on Ubuntu]]></title>
    <link href="http://jsteemann.github.com/blog/2012/12/25/using-callgrind-control-on-ubuntu/"/>
    <updated>2012-12-25T21:30:00+01:00</updated>
    <id>http://jsteemann.github.com/blog/2012/12/25/using-callgrind-control-on-ubuntu</id>
    <content type="html"><![CDATA[<p>Profiling a process with callgrind is very helpful as it provides valuable insights into how often certain functions are called and how long the program spends executing them. This helps identifying bottlenecks and potential optimisations.</p>

<p>Callgrind is contained in the Valgrind toolset, and it is easy to invoke by just prefxing the actual program command with <code>valgrind --tool=callgrind</code>, e.g.:
<code>bash
valgrind --tool=callgrind bin/arangod --console /tmp/test
</code></p>

<p>Callgrind will profile the complete run of the program, including program startup and shutdown.
This is often not what one wants. Often it is required to profile just a specific part or function of the overall program. But this information might get buried in the tons of profile data generated by callgrind.</p>

<p>I found the easiest way to get profile data for a specific part is to the start the program with callgrind and it get to the state just before it will execute the to-be-profiled function.
Then, in another terminal session, all event counters of callgrind should be cleared. This can be achieved by running the <code>callgrind_control -z</code> comand from another terminal, using the process id of the profiled program, e.g.
<code>
callgrind_control -z 4740
</code>
Then the interesting part of the program can be run. When done, a final <code>callgrind_control --dump</code> command with the process id of the profiled program forces callgrind to dump the collected profile data to a file:
<code>
callgrind_control --dump 4740
</code>
That's it, apart from the problem that <code>callgrind_control</code> does not work properly on Ubuntu 12.04.</p>

<p>Whenever invoking <code>callgrind_control</code> it could not find the process that callgrind was attached to:
```</p>

<blockquote><p>callgrind_control -z 4740
Error: Callgrind task with PID/name '4740' not detected.
callgrind_control -z arangod
Error: Callgrind task with PID/name 'arangod' not detected.
```
This sucks, especially as it works well with other Linux distributions. It's likely to be some Ubuntu-specific bug.</p></blockquote>

<p>I checked this and found that <code>callgrind_control</code> is just a Perl-script:
``` bash</p>

<blockquote><p>which callgrind_control
/usr/bin/callgrind_control
file /usr/bin/callgrind_control
/usr/bin/callgrind_control: a /usr/bin/perl -w script, ASCII text executable
```</p></blockquote>

<p>It will look for running Valgrind processes with the command <code>vgdb -l</code>, and from this list of processes try to find the one the user specified.</p>

<p>When running the above program with callgrind, <code>vgdb -l</code> will produce the following output on my machine:
<code>
use --pid=4740 for /usr/bin/valgrind.bin --tool=callgrind bin/arangod --console /tmp/test
</code>
This list with then processed is then processing with a Perl regex for matches. The interesting part looks like this:
``` perl
open LIST, "vgdb -l|";
while(<LIST>) {
  if (/<sup>use</sup> --pid=(\d+) for \S<em>?valgrind\s+(.</em>?)\s*$/) {</p>

<pre><code>...
</code></pre>

<p><code>``
Ok, now the reason is clear:</code>callgrind_control<code>will look for entries with the program</code>valgrind<code>, but</code>vgdb -l<code>will produce entries with the name</code>valgrind.bin<code>. The regex will not match</code>valgrind.bin`.</p>

<p>Finally, to make <code>callgrind_control</code> run on Ubuntu, the regex must be fixed to
<code>perl
  if (/^use --pid=(\d+) for \S*?valgrind\.bin\s+(.*?)\s*$/) {
</code>
or something similar.</p>
]]></content>
  </entry>
  
</feed>
