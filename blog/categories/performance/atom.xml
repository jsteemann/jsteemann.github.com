<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Performance | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/performance/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2015-05-07T18:31:26+02:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bulk Document Lookups]]></title>
    <link href="http://jsteemann.github.io/blog/2015/05/07/bulk-document-lookups/"/>
    <updated>2015-05-07T17:48:21+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/05/07/bulk-document-lookups</id>
    <content type="html"><![CDATA[<p>ArangoDB 2.6 comes with a specialized API for bulk document lookups.</p>

<p>The new API allows fetching multiple documents from the server using a single
request, making bulk document retrieval more efficient than when using
one request per document to fetch.</p>

<!-- more -->


<p>The straight-forward implementation of a client application that needs to
fetch several documents from an ArangoDB server looks like this:</p>

<p>```js fetching multiple documents from the server one by one
// list of document keys
var keys = [ &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;, &hellip;];</p>

<p>// sequentially fetch all documents from the server
var results = [ ];
for (var i = 0; i &lt; keys.length; ++i) {
  results.push(db.collection.document(keys[i]));
}
// now all documents are contained in variable &lsquo;results&rsquo;
```</p>

<p>This works fine but causes excessive HTTP communication between the client
application and the server when many documents need to be fetched. In fact,
the above code will issue as many HTTP requests as there are documents to fetch.</p>

<p>From the performance point of view, it would be much better to reduce the
number of HTTP requests, and retrieve multiple documents from the server in
one go, using a single request.</p>

<p>This is where the new document lookup function comes into play. Provided the
documents keys are known, all the client application needs to do is to call the
collection&rsquo;s <code>lookupByKeys</code> method:</p>

<p>```js bulk method: fetching multiple documents at once
// list of document keys
var keys = [ &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;, &hellip;];</p>

<p>var results = db.collection.lookupByKeys(keys);
// now all documents are contained in variable &lsquo;results&rsquo;
```</p>

<p>Following is a comparison of the execution times for the two different methds.
All test runs were conducted in the same ArangoDB 2.6 instance. The tests were
run from the ArangoShell. The ArangoShell and the ArangoDB server were located on
the same physical host.</p>

<p>```plain comparing single document requests and bulk requests</p>

<h2>Number of keys     Single documents        Bulk</h2>

<pre><code>     1,000               0.24 s      0.04 s
    10,000               1.23 s      0.31 s
   100,000              10.89 s      2.13 s
</code></pre>

<p>```</p>

<p>As can be seen, the bulk method can provide a substantial speedup in case lots
of documents need to be fetched by their keys at once. The actual speedups might be
even higher when using a remote ArangoDB server instead of a localhost connection.</p>

<p>In 2.6 there is currently an ArangoShell implementation for bulk document lookups.
Other drivers will follow.</p>

<p>Additionally, the server-side REST API method for bulk document lookups can be
invoked directly via HTTP as follows:</p>

<p><code>plain invoking bulk document lookups via HTTP
curl                                                  \
  -X PUT                                              \
  http://127.0.0.1:8529/_api/simple/lookup-by-keys    \
  --data '{"keys":["foo","bar","baz"]}'
</code></p>

<p>Restrictions: the bulk document API works only with document keys, not document ids.
Additionally, it works on a single collection at a time and cannot be leveraged to fetch
documents from multiple collections. Still, a client application can group document keys
by collection beforehand and send one bulk request per involved collection. Finally,
trying to fetch a document using a non-existing key will not produce an error with the
bulk API. Using the one-by-one method, trying to fetch a non-existing document will throw
an exception.</p>
]]></content>
  </entry>
  
</feed>
