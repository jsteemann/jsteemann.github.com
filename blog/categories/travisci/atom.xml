<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: TravisCI | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/travisci/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2015-06-15T18:38:09+02:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Less Intrusive Linking]]></title>
    <link href="http://jsteemann.github.io/blog/2015/05/07/less-intrusive-linking/"/>
    <updated>2015-05-07T19:52:53+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/05/07/less-intrusive-linking</id>
    <content type="html"><![CDATA[<p>A while ago our continuous integration builds on <a href="http://travis-ci.org">TravisCI</a>
began to fail seemingly randomly because the build worker was killed without
an apparent reason. Obviously the build process reached some resource limits
though we couldn&rsquo;t find any documented limit that the build obviously violated.</p>

<p>Some builds still succeeded without issues, but those builds that were killed
had one thing in common: they were all stuck waiting the linker to finish.</p>

<p>The default linker used on TravisCI is <em>GNU ld</em>. After some research, it turned
out that replacing <em>GNU ld</em> with <em>GNU gold</em> not only made the linking much
faster, but also less resource-intensive. Linking ArangoDB on my local machine
is almost twice as fast with <em>gold</em> as with <em>ld</em>. Even better, after reconfiguring
our TravisCI builds to also use <em>gold</em>, our builds weren&rsquo;t killed anymore by
TravisCI&rsquo;s build scheduling system.</p>

<p>To make TravisCI use <em>gold</em> instead of <em>ld</em>, add the following to your project&rsquo;s
<code>.travis.yml</code> in the <code>install</code> section (so it gets execute before the actual build
steps):</p>

<p><code>bash commands for wrapping gold
sudo apt-get -y install binutils-gold
mkdir -p ~/bin/gold
echo '#!/bin/bash' &gt; ~/bin/gold/ld
echo 'gold "$@"' &gt;&gt; ~/bin/gold/ld
chmod a+x ~/bin/gold/ld
export CFLAGS="-B$HOME/bin/gold $CFLAGS"
export CXXFLAGS="-B$HOME/bin/gold $CXXFLAGS"
</code></p>

<p>The script downloads and installs <em>gold</em> and creates a tiny wrapper script in a
file named <code>ld</code> in the user&rsquo;s home directory. The wrapper simply calls <em>gold</em>
with all the arguments passed to the wrapper. Finally, the script modifies the
environments <code>CFLAGS</code> and <code>CXXFLAGS</code> by setting the <code>-B</code> parameter to the
wrapper script&rsquo;s directory.</p>

<p><code>-B</code> is the option for the compiler&rsquo;s search path. The compiler (g++) at least
will look in this path for any helper tools it invokes. As we have a file named
<code>ld</code> in this directory, g++ will use our wrapper script instead of the original
<code>ld</code> binary. This way we can keep the original version of <code>ld</code> in <code>/usr/bin</code>,
and only override it using environment variables. This is also helpful in
other contexts, e.g. when <code>ld</code> shall remain as the system&rsquo;s default linker but
<code>gold</code>shall only be used for linking a few selected components.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Core Dumps of Failed TravisCI Builds]]></title>
    <link href="http://jsteemann.github.io/blog/2014/10/30/getting-core-dumps-of-failed-travisci-builds/"/>
    <updated>2014-10-30T23:05:48+01:00</updated>
    <id>http://jsteemann.github.io/blog/2014/10/30/getting-core-dumps-of-failed-travisci-builds</id>
    <content type="html"><![CDATA[<p>I recently wrote about <a href="/blog/2014/10/17/using-travis-ci-for-a-c-plus-plus-11-project/">using TravisCI for continuously testing C++11 projects</a>.</p>

<p><strong>Now, what if a build fails?</strong></p>

<p>Especially for C and C++ projects, build failures may mean crashed
programs. In a local setup, the usual way to analyze program crashes
is to manually inspect the core files that are written on crash.</p>

<p>With TravisCI, there is no way to log in to a build machine and
inspect a core dump interactively. There is no SSH access to
the build machines. TravisCI does not even persist any state of
builds but the result and the log output.</p>

<p>There is a way to get to the core dumps, but it was fiddly to find
out and set up.</p>

<!-- more -->


<p>The basic idea is to run <code>gdb</code> on the TravisCI build machine
automatically when a build fails. <code>gdb</code> can be scripted, so all
we need to do is to make it print a backtrace in all threads at
the time of the crash.</p>

<p>By default, no core dumps will be produced on TravisCI. To turn them
on, an appropriate ulimit value must be set. We also need to install
<code>gdb</code> so we can actually run it. Here is the <code>.travis.yml</code> adjustment
for these prerequisites:</p>

<p>```yaml adjustments for install and before_script hooks
install:
&ndash; sudo apt-get install -y gdb  # install gdb</p>

<p>before_script:
&ndash; ulimit -c unlimited -S       # enable core dumps
```</p>

<p>To get an idea of where the program crashed, we can finally install
an <code>after_failure</code> hook. This hook can check for a core file and use
<code>gdb</code> to print a nice backtrace.</p>

<p>The core file pattern on TravisCI seems to be <code>core-%p</code>, so core
filenames will include the executable&rsquo;s process id and change on
every run. We can use <code>find</code> to look for files named <code>core*</code> in the
cwd and pick the first one as there should only be at most one core
file per build:</p>

<p><code>yaml adjustments for after_failure hook
after_failure:
- COREFILE=$(find . -maxdepth 1 -name "core*" | head -n 1) # find core file
- if [[ -f "$COREFILE" ]]; then gdb -c "$COREFILE" example -ex "thread apply all bt" -ex "set pagination 0" -batch; fi
</code></p>

<p>A failed build might produce output like this:</p>

<p><img src="/downloads/screenshots/travis-ci-gdb.png"></p>

<p>I recommend compiling the executable to test with debug symbols on and
with all optimizations turned off (i.e. compiler options <code>-g -O0</code>).
Otherwise backtraces might reveal less useful information for debugging.</p>

<p>On a side note: the <a href="http://lint.travis-ci.org/">Travis WebLint</a> is a
handy tool for validating <code>.travis.yml</code> files <em>before</em> pushing them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Travis CI for a C++11 Project]]></title>
    <link href="http://jsteemann.github.io/blog/2014/10/17/using-travis-ci-for-a-c-plus-plus-11-project/"/>
    <updated>2014-10-17T19:36:57+02:00</updated>
    <id>http://jsteemann.github.io/blog/2014/10/17/using-travis-ci-for-a-c-plus-plus-11-project</id>
    <content type="html"><![CDATA[<p><a href="http://travis-ci.com">TravisCI</a> is a very useful cloud service
for continous integration. It can be integrated with Github, with each
commit triggering a new build and reporting back when it broke something.</p>

<p>Travis has support for many programming languages, among them C++.
But it lacks support for C++11 features.</p>

<!-- more -->


<p>Travis provides basic support for C++ projects. <a href="http://docs.travis-ci.com/user/languages/cpp/">It comes with gcc, clang,
the autotools, make, cmake and scons</a>.</p>

<p>While writing this post, Travis CI build machines run on Ubuntu 12.04
LTS 64 bit. This version of Ubuntu is rather old already, and does not bring
too many packages for C++11 development. For example, the default
C++ compiler installed on TravisCI is g++-4.6.3. This version
doesn&rsquo;t even understand the compile option <code>-std=c++11</code>.</p>

<p>Official C++11 support <a href="https://gcc.gnu.org/projects/cxx0x.html">started in g++ 4.7</a>,
though C++0x features were supported way earlier. But to get decent C++11 support
in g++, it is best to use g++4.8 or higher.</p>

<p>Fortunately TravisCI allows installing other software. To get
a more recent C++ compiler, it can simply be added from a PPA.
This can be achieved by putting the PPA in the <code>.travis.yml</code> file of your
Github repository, e.g.</p>

<p>```yaml
language: cpp
compiler: g++</p>

<p>before_install:
&ndash; sudo add-apt-repository -y ppa:ubuntu-toolchain-r/test
&ndash; sudo apt-get update -qq</p>

<p>install:
&ndash; sudo apt-get install -qq g++-4.8
&ndash; export CXX=&ldquo;g++-4.8&rdquo;
```</p>

<p>I have set up an <a href="https://github.com/jsteemann/travis-cxx11">example project on Github</a>
that demonstrates how to use it.</p>
]]></content>
  </entry>
  
</feed>
