<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Foxx | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/foxx/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2016-06-23T17:57:39+02:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Handling Binary Data in Foxx 3.0]]></title>
    <link href="http://jsteemann.github.io/blog/2016/06/22/handling-binary-data-in-foxx-3-0/"/>
    <updated>2016-06-22T17:57:30+02:00</updated>
    <id>http://jsteemann.github.io/blog/2016/06/22/handling-binary-data-in-foxx-3-0</id>
    <content type="html"><![CDATA[<p><em>Note: this post is about the ArangoDB 3.x series</em></p>

<p>A while ago I wrote a <a href="/blog/2014/10/15/handling-binary-data-in-foxx/">blog post</a>
about handling binary data in Foxx applications. That blog post provided a solution
for retrieving and serving non-UTF-8 data from a Foxx application. It was written
for the 2.x series of ArangoDB.</p>

<p>With the release of ArangoDB 3.0 that solution needs some adaption, and this
blog post provides the source code for the 3.0 version of the Foxx application.</p>

<!-- more -->


<p>The <code>rawBodyBuffer()</code> function of the <code>request</code> object is gone in 3.0, and to
retrieve the body as a blob we now need to use <code>req.rawBody</code>.
And as there are no controllers and applicationContexts in Foxx 3.0 anymore,
the original route code needs to be changed from</p>

<p>```js 2.8 Foxx action that can handle binary input
controller.post(&lsquo;/receive-binary&rsquo;, function (req, res) {
  // fetch request body into the buffer
  var body = req.rawBodyBuffer();
  // create an absolute filename, local to the Foxx application directory
  var filename = applicationContext.foxxFilename(&ldquo;body&rdquo;);</p>

<p>  require(&ldquo;fs&rdquo;).write(filename, body);
});
```</p>

<p>to the following code:</p>

<p>```js 3.0 Foxx action that can handle binary input
router.post(&lsquo;/receive-binary&rsquo;, function (req, res) {
  // fetch request body into a Buffer
  var body = req.rawBody;
  // create an absolute filename, local to the Foxx application directory
  var filename = module.context.filename(&ldquo;body&rdquo;);</p>

<p>  require(&ldquo;fs&rdquo;).write(filename, body);
});
```</p>

<p>To serve binary data from a Foxx action, the original route code needs to
be changed from</p>

<p><code>js 2.8 Foxx action that returns contents of a file
controller.get('/provide-binary-file', function (req, res) {
  // create an absolute filename, local to the Foxx application directory
  var filename = applicationContext.foxxFilename("body");
  // send the contents, this will also set mime type "application/octet-stream"
  res.sendFile(filename);
});
</code></p>

<p><code>js 3.0 Foxx action that returns contents of a file
router.get('/provide-binary-file', function (req, res) {
  // create an absolute filename, local to the Foxx application directory
  var filename = module.context.fileName("body");
  // send the contents, this will also set mime type "application/octet-stream"
  res.sendFile(filename);
});
</code></p>

<p>The adjusted Foxx application can be downloaded <a href="/downloads/code/filelist-30.zip">here</a>
with full source code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How V8 Is Used in ArangoDB]]></title>
    <link href="http://jsteemann.github.io/blog/2015/08/01/how-v8-is-used-in-arangodb/"/>
    <updated>2015-08-01T19:06:04+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/08/01/how-v8-is-used-in-arangodb</id>
    <content type="html"><![CDATA[<p>ArangoDB allows running user-defined JavaScript code in the database.
This can be used for more complex, <em>stored procedures</em>-like database operations.
Additionally, ArangoDB&rsquo;s <a href="https://www.arangodb.com/foxx/">Foxx framework</a> can
be used to make any database functionality available via an HTTP REST API.
It&rsquo;s easy to build microservices with it, using the scripting functionality
for tasks like access control, data validation, sanitation etc.</p>

<p>We often get asked how the scripting functionality is implemented under the hood.
Additionally, several people have asked how ArangoDB&rsquo;s JavaScript functionality
relates to node.js.</p>

<p>This post tries to explain that in detail.</p>

<!-- more -->


<h1>The C++ parts</h1>

<p><em>arangosh</em>, the ArangoShell, and <em>arangod</em>, the database server, are written in
C++ and they are shipped as native code executables. Some parts of both <em>arangosh</em>
and <em>arangod</em> itself are written in JavaScript (more on that later).</p>

<p>The I/O handling in <em>arangod</em> is written in C++ and uses libev (written in C)
for the low-level event handling. All the socket I/O, working scheduling and
queueing is written in C++, too. These are parts that require high parallelism,
so we want this to run in multiple threads.</p>

<p>All the indexes, the persistence layer and many of the fundamental operations,
like the ones for document inserts, updates, deletes, imports are written in C++ for
effective control of memory usage and parallelism. AQL&rsquo;s query parser is written
using the usual combination of Flex and Bison, which generate C files that are
compiled to native code. The AQL optimizer, AQL executor and many AQL functions are
writting in C++ as well.</p>

<p>Some AQL functions however, are written in JavaScript. And if an AQL query
invokes a user-defined function, this function will be a JavaScript function, too.</p>

<h1>How ArangoDB uses V8</h1>

<p>How is JavaScript code executed in ArangoDB?</p>

<p>Both <em>arangosh</em> and <em>arangod</em> are linked against the <a href="https://developers.google.com/v8/">V8 JavaScript engine</a>
library. V8 (itself written in C++) is the component that runs the JavaScript
code in ArangoDB.</p>

<p>V8 requires JavaScript code to run in a so-called <em>isolate</em> (note: I&rsquo;ll be
oversimplifying a bit here &ndash; in reality there are isolates and contexts).
As the name suggests, isolates are completely isolated from each other.
Especially, data cannot be shared or moved across isolates, and each isolate
can be used by only one thread at a time.</p>

<p>Let&rsquo;s look at how <em>arangosh</em>, the ArangoShell, uses V8. All JavaScript commands
entered in <em>arangosh</em> will be compiled and executing with V8 immediately.
In <em>arangosh</em>, this happens using a single V8 isolate.</p>

<p>On the server side, things are a bit different. In <em>arangod</em>, there are multiple
V8 isolates. The number of isolates to create is a startup configuration
option (<code>--javascript.v8-contexts</code>). Creating multiple isolates allows running
JavaScript code in multiple threads, truly parallel. Apart from that, <em>arangod</em>
has multiple I/O threads (<code>--scheduler.threads</code> configuration option) for handling
the communication with client applications.</p>

<p>As mentioned earlier, part of ArangoDB&rsquo;s codebase itself is written in JavaScript,
and this JavaScript code is executed the same way as any user-defined will be executed.</p>

<h1>Executing JavaScript code with V8</h1>

<p>For executing any JavaScript code (built-in or user-defined), ArangoDB will invoke
V8&rsquo;s JIT compiler to compile the script code into native code and run it.</p>

<p>The JIT compiler in V8 will not try extremely hard to optimize the code on the
first invocation. On initial compilation, it will aim for a good balance of
optimizations and fast compilation time. If it finds some code parts are called
often, it may re-try to optimize these parts more aggressively automatically.
To make things even more complex, there are different JIT compilers in V8
(i.e. Crankshaft and Turbofan) with different sweet spots. JavaScript modes
(i.e. <em>strict mode</em> and <em>strong mode</em>) can also affect the level of optimizations
the compilers will carry out.</p>

<p>Now, after the JavaScript code has been compiled to native code, V8 will run it
until it returns or fails with an uncaught exception.</p>

<p>But how can the JavaScript code access the database data and server internals?
In other words, what actually happens if a JavaScript command such as the following
is executed?</p>

<p><code>js example JavaScript command
db.myCollection.save({ _key: "test" });
</code></p>

<h2>Accessing server internals from JavaScript</h2>

<p>Inside <em>arangod</em>, each V8 isolate is equipped with a global variable named <code>db</code>.
This JavaScript variable is a wrapper around database functionality written in C++.
When the <code>db</code> object is created, we tell V8 that its methods are C++ callbacks.</p>

<p>Whenever the <code>db</code> object is accessed in JavaScript, the V8 engine will therefore
call C++ methods. These provide full access to the server internals, can do whatever
is required and return data in the format that V8 requires. V8 then makes the
return data accessible to the JavaScript code.</p>

<p>Executing <code>db.myCollection.save(...)</code> is effectively two operations: accessing the
property <code>myCollection</code> on the object <code>db</code> and then calling function <code>save</code> on that
property. For the first operation, V8 will invoke the object&rsquo;s <code>NamedPropertyHandler</code>,
which is a C++ function that is responsible for returning the value for the property
with the given name (<code>myCollection</code>). In the case of <code>db</code>, we have a C++ function
that collection object if it exists, or <code>undefined</code> if not.</p>

<p>The collection object again has C++ bindings in the background, so calling function
<code>save</code> on it will call another C++ function. The collection object also has a (hidden)
pointer to the C++ collection. When <code>save</code> is called, we will extract that pointer
from the <code>this</code> object so we know which C++ data structures to work on. The <code>save</code>
function will also get the to-be-inserted document data as its payload. V8 will
pass this to the C++ function as well so we can validate it and convert it into
our internal data format.</p>

<p>On the server side, there are several objects exposed to JavaScript that have C++
bindings. There are also non-object functions that have C++ bindings. Some of these
functions are also bolted on regular JavaScript objects.</p>

<h2>Accessing server internals from ArangoShell</h2>

<p>When running the same command in <em>arangosh</em>, things will be completely different.
The ArangoShell may run on the same host as the <em>arangod</em> server process, but it may
also run on a completely different one. Providing <em>arangosh</em> access to server internals
such as pointers will therefore not work in general. Even if <em>arangosh</em> and <em>arangod</em>
do run on the same host, they are independent processes with no access to the each
other&rsquo;s data. The latter problem could be solved by having a shared memory segment
that both <em>arangosh</em> and <em>arangod</em> can use, but why bother with that special case
which will provide no help in the general case when the shell can be located on
<strong>any</strong> host.</p>

<p>To make the shell work in all these situations, it uses the HTTP REST API provided
by the ArangoDB server to talk to it. For <em>arangod</em>, any ArangoShell client is just
another client, with no special treatments or protocols.</p>

<p>As a consequence, all operations on databases and collections run from the ArangoShell
are JavaScript wrappers that call their respective server-side HTTP APIs.</p>

<p>Recalling the command example again (<code>db.myCollection.save(...)</code>), the shell will first
access the property <code>myCollection</code> of the object <code>db</code>. In the shell <code>db</code> is a regular
JavaScript object with no C++ bindings. When the shell is started, it will make an
HTTP call to <em>arangod</em> to retrieve a list of all available collections, and register
them as properties in its <code>db</code> object. Calling the <code>save</code> method on one of these
objects will trigger an HTTP POST request to the server API at <code>/_api/document?collection=myCollection</code>,
with the to-be-inserted data in its request body. Eventually the server will respond
and the command will return with the data retrieved from the server.</p>

<h2>Considerations</h2>

<p>Consider running the following JavaScript code:</p>

<p><code>js code to insert 1000 documents
for (var i = 0; i &lt; 1000; ++i) {
  db.myCollection.save({ _key: "test" + i });
}
</code></p>

<p>When run from inside the ArangoShell, the code will be executed in there. The shell will
perform an HTTP request to <em>arangod</em> for each call to <code>save</code>. We&rsquo;ll end up with 1,000
HTTP requests.</p>

<p>Running the same code inside <em>arangod</em> will trigger no HTTP requests, as the server-side
functions are backed with C++ internals and can access the database data directly. It will
be a lot faster to run this loop on the server than in <em>arangosh</em>. A while ago I wrote
<a href="/blog/2014/08/30/understanding-where-operations-are-executed/">another article</a> about this.</p>

<p>When replacing the ArangoShell with another client application, things are no different.
A client application will not have access to the server internals, so all it can do is to
make requests to the server (by the way, the principle would be no different if we used
MySQL or other database servers, only the protocols would vary).</p>

<p>Fortunately, there is a fix for this: making the code run server-side. For example, the
above code can be put into a Foxx route. This way it is not only fast but will be made
accessible via an HTTP REST API so client applications can call it with a single HTTP request.</p>

<p>In reality, database operations will be more complex than in the above example. And this
is where having a full-featured scripting language like JavaScript helps. It provides all
the features that are needed for more complex tasks such as validating and sanitizing input
data, access control, executing database queries and postprocessing results.</p>

<h1>The differences to node.js</h1>

<p>To start with: ArangoDB is not node.js, and vice versa. ArangoDB is not a node.js module
either. ArangoDB and node.js are completely indepedent.</p>

<p>But there is a commonality: both ArangoDB and node.js use the V8 engine for running
JavaScript code.</p>

<h2>Threading</h2>

<p>AFAIK, standard node.js only has a single V8 isolate to run all code in.
While that made the implementation easier (no hassle with multi-threading) it
also limits node.js to using only a single CPU.</p>

<p>It&rsquo;s not unusual to see a multi-core server with a node.js instance maxing out
one CPU while the other CPUs are sitting idle. In order to max out a multi-core
server, people often start multiple node.js instances on a single server. That will
work fine, but the node.js instances will be independent, and sharing data between
them is not possible in plain JavaScript.</p>

<p>And because a node.js instance is single-threaded, it is also important that
code written for node.js is non-blocking. Code that blocks while waiting for
some I/O operation would block the only available CPU. Using non-blocking
I/O operations allows node.js to queue the operation, and execute other code
in the meantime, allowing overall progress. This also makes it look like it
would be executing multiple actions in parallel, while it is actually executing
them sequentially.</p>

<p>Contrary, <em>arangod</em> is a multi-threaded server. It can serve multiple requests in
parallel, using multiple CPUs. Because <em>arangod</em> has multiple V8 isolates that
each can execute JavaScript code, it can run JavaScript in multiple threads in parallel.</p>

<p><em>arangosh</em>, the ArangoShell, is single-threaded and provides only a single V8 isolate.</p>

<h2>Usage of modules</h2>

<p>Both node.js and ArangoDB can load code at runtime so it can be organized into
modules or libraries. In both, extra JavaScript modules can be loaded using the
<code>require</code> function.</p>

<p>There is often confusion about whether node.js modules can be used in ArangoDB.
This is probably because the answer is &ldquo;<em>it depends!</em>&rdquo;.</p>

<p>node.js packages can be written in JavaScript but they can also compile to native
code using C++. The latter can be used to extend the functionality of node.js with
features that JavaScript alone wouldn&rsquo;t be capable of. Such modules however often
heavily depend on a specific V8 version (so do not necessarily compile in a node.js
version with a different version of V8) and often rely on node.js internals.</p>

<p>ArangoDB can load modules that are written in pure JavaScript. Modules that
depend on non-JavaScript functionality (such as native modules for node.js) or modules
that rely on node.js internals cannot be loaded in ArangoDB. As a rule of thumb,
any module will run in ArangoDB that is implemented in pure JavaScript, does not
access global variables and only requires other modules that obey the same restrictions.</p>

<p>ArangoDB also uses several externally maintained JavaScript-only libraries, such as
underscore.js. This module will run everywhere because it conforms to the mentioned
restrictions.</p>

<p>ArangoDB also uses several other modules that are maintained on npm.js.
An example module is <a href="https://www.npmjs.com/package/aqb">AQB</a>, a query builder for AQL.
It is written in pure JavaScript too, so it can be used from a node.js application and
from within ArangoDB. If there is an updated version of this module, we use npm to
install it in a subdirectory of ArangoDB. As per npm convention, the node.js modules
shipped with ArangoDB reside in a directory named <code>node_modules</code>. Probably this is
what caused some of the confusion.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Throughput Enhancements]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/30/throughput-enhancements/"/>
    <updated>2015-07-30T12:54:12+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/30/throughput-enhancements</id>
    <content type="html"><![CDATA[<p>We&rsquo;ve recently been working on improving ArangoDB&rsquo;s throughput,
especially when using the ArangoDB&rsquo;s interface.</p>

<p>In this post, I will show some of the improvements already achieved,
though the work is not yet finished. Therefore, the results shown here
are still somewhat preliminary.</p>

<!-- more -->


<p>We wanted to measure improvements for ArangoDB&rsquo;s HTTP interface, and so we used
<a href="https://github.com/wg/wrk"><em>wrk</em></a> as an external HTTP load generator.</p>

<p>During the tests, <em>wrk</em> called some specific URLs on a local ArangoDB instance on
an otherwise idle machine. The test was run with ArangoDB 2.6 and <code>devel</code>. The
ArangoDB instances were started with their default configuration.</p>

<p><em>wrk</em> was invoked with varying amounts of client connections and threads, so the
tests cover serial and concurrent/parallel requests:</p>

<p><code>bash invoking wrk
wrk -c $CONNECTIONS -t $THREADS -d 10 $URL
</code></p>

<p>The number of connections (<code>$CONNECTIONS</code>) and theads (<code>$THREADS</code>) were both varied
from 1 to 8. <em>wrk</em> requires at least as many connections as threads.</p>

<p>The first URL tested was a route in a simple Foxx application that inserts the data
shipped in the HTTP request into a collection on the server. The internals of the
route should not matter here, as this post focuses on the throughput improvements.</p>

<p>Following are the results for calling the route with <em>wrk</em>, comparing the stable
ArangoDB version (2.6.3) with the current development version (head of <code>devel</code> branch
as of today). The table shows the number of documents that were inserted during the
10 seconds the <em>wrk</em> client ran:</p>

<p>```plain test results for 1 thread</p>

<h2>Threads      Connections        2.6       devel</h2>

<pre><code>  1                1      12569       20157 
  1                2      28094       36031   
  1                4      46310       66524 
  1                8      46798       80667
</code></pre>

<p>```</p>

<p>As can be seen above, <code>devel</code> was able to handle much more requests than 2.6 even
with a single connection (i.e. serial client requests). Throughput was about 60 %
higher for this case.</p>

<p>When increasing the number of client connections, the number of requests handled by
<code>devel</code> ws also higher than that of 2.6, with improvements between around 25 and 70 %.</p>

<p>When increasing the number of client load generation threads, the picture doesn&rsquo;t
change much. Here&rsquo;s the full table of results:</p>

<p>```plain full test results</p>

<h2>Threads      Connections        2.6       devel</h2>

<pre><code>  1                1      12569       20157 
  1                2      28094       36031   
  1                4      46310       66524 
  1                8      46798       80667

  2                2      28931       36326    
  2                4      47181       67654    
  2                8      47594       88617 

  4                4      46553       67585   
  4                8      47531       86935 

  8                8      46431       91953 
</code></pre>

<p>```</p>

<p>The next test consisted of inserting documents into a collection again, but using the
built-in HTTP API for creating documents instead of a user-defined Foxx application.
Throughput is expected to be higher than in the Foxx case because the built-in method
is hard-wired and only serves a single purpose, whereas the Foxx route is user-definable
and capable of doing fancy things, such as validating data, restricting access etc.</p>

<p>Here are the results for calling the hard-wired insertion route, again for 2.6 and <code>devel</code>:</p>

<p>```plain full test results</p>

<h2>Threads      Connections        2.6       devel</h2>

<pre><code>  1                1     102133      112843 
  1                2     185529      210795 
  1                4     335607      373070
  1                8     518354      576034

  2                2     181237      196482 
  2                4     345455      363255
  2                8     474558      550835

  4                4     318331      355328
  4                8     483388      516100

  8                8     482369      527395
</code></pre>

<p>```</p>

<p><code>devel</code> provides higher throughput than 2.6 for this route as well. Improvements fell
into the range of between 5 and 15 %. That&rsquo;s not as impressive as in the Foxx route
case above, but still a welcome improvement.</p>

<p>And of course we&rsquo;ll try to improve the throughput further.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 Features in ArangoDB 2.7]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/14/es6-features-in-arangodb-27/"/>
    <updated>2015-07-14T20:33:55+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/14/es6-features-in-arangodb-27</id>
    <content type="html"><![CDATA[<p>ArangoDB 2.6 uses V8 engine version 3.31.74.1 for running its own and all user-defined
JavaScript code. In ArangoDB 2.7 (currently in development), we have upgraded V8 to
version 4.3.61.</p>

<p>The new V8 version in ArangoDB 2.7 provides several additional ES6 features that can
be used to improve JavaScript usability and code quality. This blog post showcases <em>strong
mode</em> and <em>rest parameters</em>, and also shows how to activate <em>TurboFan</em>, V8&rsquo;s new JIT compiler
for JavaScript.</p>

<p>ArangoDB 2.7 is in development right now, but it can be tried today by
<a href="/blog/2014/10/16/how-to-compile-arangodb-from-source/">compiling it from source</a>.</p>

<!-- more -->


<h2>JavaScript strong mode</h2>

<p>V8 v4 comes with an optional and experimental <em>strong mode</em>. This mode provides only a
subset of JavaScript, with the idea of intentionally deactivating some of
<a href="http://archive.oreilly.com/pub/a/javascript/excerpts/javascript-good-parts/bad-parts.html">JavaScript&rsquo;s bad parts</a>.
It is based on <em>strict mode</em>, but goes further.</p>

<p>Committing to <em>strong mode</em> may not only provide better and stronger semantics, but may
also enable more optimization opportunities for the JavaScript compiler. For example, the
strong mode disables JavaScript&rsquo;s <em>with</em> statement and <code>delete</code>! Additionally, <code>var</code> cannot
be used anymore but is deprecated in favor of <code>let</code> and <code>const</code>.</p>

<p>The proposal for the strong mode can be found
<a href="https://docs.google.com/document/d/1Qk0qC4s_XNCLemj42FqfsRLp49nDQMZ1y7fwf5YjaI4/view">here</a>,
and the V8 team also has a <a href="https://developers.google.com/v8/experiments">page about it</a>.</p>

<p>Strong mode must be turned on explicitly. This can be done by adding the <code>--strong-mode=true</code>
v8 option when starting <em>arangod</em> or <em>arangosh</em>:</p>

<p><code>bash enabling strong mode
arangosh  --javascript.v8-options="--strong_mode=true"
</code></p>

<p>Note that I am using <em>arangosh</em> above, but the same would work for <em>arangod</em>, too, so the feature
can be used for Foxx routes as well.</p>

<h2>Rest parameters</h2>

<p>How to pass a variable number of arguments to a function?</p>

<p>C and C++ programmers have been using and abusing the ellipsis (<code>...</code>) and <code>__VA_ARGS__</code> features
of the C preprocessor for a long time. Then came the macros of <code>stdarg.h</code> / <code>cstdarg</code>,
until C++11 really improved the situation with <code>std::initializer_list</code> and variadic templates.</p>

<p>In JavaScript, one can use the <code>arguments</code> object:
```js
function logSimple () {
  for (value of arguments) {</p>

<pre><code>console.log(value);
</code></pre>

<p>  }
}</p>

<p>logSimple(&ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;);
```</p>

<p>This does the job, and the above will print something like:
<code>plain
2015-07-14T19:01:51Z [5245] INFO foo
2015-07-14T19:01:51Z [5245] INFO bar
2015-07-14T19:01:51Z [5245] INFO baz
</code></p>

<p>This is fine as long as all arguments shall be treated the same way. But what if some
arguments have a designated meaning and should be treated specially?</p>

<p>The solution is to use <em>ES6 rest parameters</em>. The last parameter in an argument list can be
prefixed with <code>...</code> to capture any number of function parameters:</p>

<p>```js
function logWithContext (context, &hellip;values) {
  for (value of values) {</p>

<pre><code>console.log('[' + context + '] ' + value);
</code></pre>

<p>  }
}</p>

<p>logWithContext(&ldquo;es6&rdquo;, &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;);
```</p>

<p>As can be seen, the <code>logWithContext</code> function specially handles its <code>context</code> argument, while
we can still pass any number of further parameters into it. Here&rsquo;s what the above will print:</p>

<p><code>plain
2015-07-14T19:07:27Z [5245] INFO [es6]: foo
2015-07-14T19:07:27Z [5245] INFO [es6]: bar
2015-07-14T19:07:27Z [5245] INFO [es6]: baz
</code></p>

<p>Note that rest parameters cannot be used with the default configuration and must be turned on
explicitly in <em>arangosh</em> or <em>arangod</em>.</p>

<p>The startup option to turn them on is:</p>

<p><code>bash enabling rest parameters
arangosh --javascript.v8-options="--harmony_rest_parameters=true"
</code></p>

<h2>TurboFan</h2>

<p>The new V8 version comes with <em>TurboFan</em>, a new JIT compiler for JavaScript.
According to <a href="http://blog.chromium.org/2015/07/revving-up-javascript-performance-with.html">this post</a>
it is already used in Chrome for compiling certain types of JavaScript code.</p>

<p>As fas as I can see, it is turned off by default in our version of V8, and the compiler
also seems to be rather experimental. To get an idea of what it can already do and where
its limits are, it can already be tried in ArangoDB 2.7.</p>

<p>By default, it seems to be turned off. Using the following startup option, it can be turned on for
JavaScript functions with a certain name pattern (i.e. all function names starting with <em>testTurboFan</em>):</p>

<p><code>bash starting ArangoShell with TurboFan enabled
arangosh --javascript.v8-options="--turbo-filter=testTurboFan*"`
</code></p>

<p>Without turning on V8 tracing, one will not be able to tell which compiler is used to compile a
specific function. To turn it on and actually confirm V8 is using TurboFan, use these options:</p>

<p><code>bash starting ArangoShell with TurboFan and debug output
arangosh --javascript.v8-options="--always-opt --trace_opt --turbo-filter=testTurboFan*"
</code></p>

<p>This will be very verbose, but it is good to tell which internal compiler is used to compile a given
JavaScript function.</p>

<p>For example, after starting the ArangoShell with the above options, run the following test code
to see that V8 uses TurboFan for compiling the first two functions (which match the name pattern),
and Crankshaft for the third (which does not match the name pattern):</p>

<p>```js test code for invoking the TurboFan compiler
function testTurboFan1 () {
  console.log(&ldquo;turbo-fan 1&rdquo;);
}
testTurboFan1();</p>

<p>function testTurboFan2 () {
  console.log(&ldquo;turbo-fan 2&rdquo;);
}
testTurboFan2();</p>

<p>function testSomethingElse () {
  console.log(&ldquo;something else&rdquo;);
}
testSomethingElse();
```</p>

<p>Here&rsquo;s the confirmation that TurboFan is used:</p>

<p><code>plain debug output
...
[compiling method 0x31ca8804e351 &lt;JS Function testTurboFan1 (SharedFunctionInfo 0x31ca8804e171)&gt; using TurboFan]
...
[compiling method 0x31ca8804e7f9 &lt;JS Function testTurboFan2 (SharedFunctionInfo 0x31ca8804e619)&gt; using TurboFan]
...
[compiling method 0x31ca8804ec71 &lt;JS Function testSomethingElse (SharedFunctionInfo 0x31ca8804ea91)&gt; using Crankshaft]
...
</code></p>

<p>Have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More ES6 Features]]></title>
    <link href="http://jsteemann.github.io/blog/2015/02/26/more-es6-features/"/>
    <updated>2015-02-26T12:00:46+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/02/26/more-es6-features</id>
    <content type="html"><![CDATA[<p>ArangoDB 2.5 comes with an upgraded version of V8, Google&rsquo;s open source JavaScript engine.</p>

<p>The built-in version of V8 has been upgraded from 3.29.54 to 3.31.74.1.</p>

<p>In addition to several already usable ES6 features (detailed in
<a href="https://jsteemann.github.io/blog/2014/12/19/using-es6-features-in-arangodb/">this blog</a>,
the following ES6 features are activated in ArangoDB 2.5 by default:</p>

<ul>
<li>iterators and generators</li>
<li>template strings</li>
<li>enhanced object literals</li>
<li>enhanced numeric literals</li>
<li>block scoping with <code>let</code> and constant variables using <code>const</code></li>
<li>additional String methods (such as <code>startsWith</code>, <code>repeat</code> etc.)</li>
</ul>


<p>The above features are available in ArangoDB 2.5, and can now be used for scripting purposes
in the ArangoShell and in server-side Foxx actions inside the database.</p>

<p>This blog post briefly explains the features provides some quick examples for using them.</p>

<!-- more -->


<h2>Iterators and generators</h2>

<p>Iterator and generator support was optional in 2.4, but is turned on by default since 2.5.</p>

<p>For everyone who is not familiar with generators in JavaScript, here&rsquo;s how they work:</p>

<p>Generators are special functions tagged with an asterisk (<code>*</code>). Values are returned to the
caller using the <code>yield</code> keyword:</p>

<p><code>js a simple generator that generates two values                                                            
function* generate () {                                                                                       
  yield 23;                                                                                                   
  yield 42;                                                                                                   
}                                                                                                            
</code></p>

<p>Calling the function with initialize/reset the generator. Calling the <code>next()</code> method on
the generator&rsquo;s initial call return value produces the next sequence element. The element
is returned in a <code>value</code> attribute. The <code>done</code> attribute indicates whether the sequence
has come to an end:</p>

<p><code>js invoking the generator
var generator = generate();                                                                                   
console.log(generator.next());  /* { "value" : 23, "done" : false } */                                        
console.log(generator.next());  /* { "value" : 42, "done" : false } */                                        
console.log(generator.next());  /* { "value" : undefined, "done" : true } */                                  
</code></p>

<p>Sequences produced by generators can also be consumed via a <code>for...of</code> loop:</p>

<p>```js consuming all values from a generator function
var generator = generate();</p>

<p>for (var value of generator) {
  console.log(value);
}
```</p>

<p>In general, every object that is iteratable can be consumed using the <code>of</code> operator.
Some built-in objects provide pre-defined iterators (e.g. <code>Map.keys()</code> or <code>Map.values()</code>),
but you can also create iterators for your own objects:</p>

<p>```js creating an iterator for an object
function Sentence (text) {
  this.text = text;
}</p>

<p>Sentence.prototype[Symbol.iterator] = function*() {
  var regex = /\S+/g;
  var text = this.text;
  var match;
  while (match = regex.exec(text)) {</p>

<pre><code>yield match[0]; 
</code></pre>

<p>  }
};</p>

<p>var sentence = new Sentence(&ldquo;The quick brown fox jumped over the lazy dog&rdquo;);
for (var word of sentence) {
  console.log(word);
}
```</p>

<h2>Template strings</h2>

<p>I know there are query string generators and such, but for the sake of the example, let&rsquo;s assume you
wanted to write a query string in JavaScript. You might end up with something like this:</p>

<p><code>js multi-line query string
var query =
  'FOR doc IN users\n' +
  '  FILTER doc.name == @name\n' +
  '  RETURN doc\n';
</code></p>

<p>This is hardly legible, and it is also very prone to errors.</p>

<p>ES6 template strings provide a way to define multi-line string literals in a much easier and simpler way.
Here&rsquo;s how to do it (note the backticks instead of the regular string quotes):</p>

<p><code>js using a multi-line template string
var query = `
FOR doc IN users
  FILTER doc.name == @name
  RETURN doc
`;
</code></p>

<p>Template strings also support value substitution, so you could even write something like this, too:
```js value substitution in template strings
var name = &ldquo;AQL injection attempt \&rdquo; OR true OR \&ldquo;&rdquo;;</p>

<p>var query = <code>
FOR doc IN users
  FILTER doc.name == ${JSON.stringify(name)}
  RETURN doc
</code>;
```</p>

<p>Note that while value substitution in template strings in convenient, you still have to be careful with
user-generated values. Otherwise you might be subject to value injection attacks, as you would be with
every other form of improper user value handling.</p>

<h2>Enhanced object literals</h2>

<p>Save some time when definining objects:</p>

<p>```js using enhanced object literals
var name = &ldquo;foobar&rdquo;;</p>

<p>myObject = {
  type : &ldquo;myType&rdquo;,   /<em> always worked </em>/
  name,              /<em> same as &ldquo;name&rdquo; : name </em>/
  save () {          /<em> same as &ldquo;save&rdquo; : function () &hellip; </em>/</p>

<pre><code>console.log("save called!"); 
</code></pre>

<p>  }
};</p>

<p>{
  &ldquo;type&rdquo; : &ldquo;myType&rdquo;,
  &ldquo;name&rdquo; : &ldquo;foobar&rdquo;,
  &ldquo;save&rdquo; : [Function &ldquo;console.log("save called!&rdquo;);&ldquo; &hellip;]
}
```</p>

<p>As can be seen above, enhanced object literal declarations can save some typing and reduce redundancies
in the code. Unfortunately we still cannot use object key names generated from expressions:</p>

<p><code>js does not work yet
myObject = {
  [ "foo" + bar" ] : "foobar"
};
</code></p>

<h2>Enhanced numeric literals</h2>

<p>Numeric values can now be specified in binary or octal if required:</p>

<p><code>js numeric literals                                                                                        
var life = 0b101010;          /* binary, 42 in decimal */                                                     
var filePermissions = 0o777;  /* octal, 511 in decimal */                                                     
</code></p>

<h2>Block scoping</h2>

<p>As a mostly C++ programmer, I am always puzzled about the scoping of JavaScript variables.
In the following example, variable <code>x</code> does not only live inside the curly brackets block in which
it was declared, but also afterwards:</p>

<p>```
function work () {
  {</p>

<pre><code>var x = 1;
</code></pre>

<p>  }
  return x;
}
```</p>

<p>The reason is that the curly brackets around <code>var x = 1;</code> are not a scope at all in traditional
JavaScript. This sucks, because variables can linger around in programs longer than necessary,
leading to unwanted side-effects.</p>

<p>With block-level scopes, this can be fixed. To use it, introduce variables not with the <code>var</code>
keyword, but with <code>let</code>. <code>let</code> only works in strict mode, so make sure your function or module
uses it.</p>

<p>Now, with block-level scoping, the above snippet looks like this:
```
function work () {
  &ldquo;use strict&rdquo;;
  {</p>

<pre><code>let x = 1; 
</code></pre>

<p>  }
  return x;
};
```</p>

<p>And it will actually produce an error when trying to access variable <code>x</code> in the <code>return</code> statement.
The reason is that the life of <code>x</code> was over as soon as its scope was left. The scope of variable <code>x</code> is
now only the one with the <code>let</code> declaration inside the curly brackets.</p>

<p>Someone else said &ldquo;<em>let is the new var</em>&rdquo;, and I think there&rsquo;s not much to add.</p>

<p>Additionally, the <code>const</code> keyword can be used to define a read-only variables. Trying to re-define a
constant will produce an error in strict mode (the desired behavior), and do nothing in non-strict mode.
Another reason to use the strict mode.</p>

<h2>Additional String methods</h2>

<p><code>String</code> objects now provide extra built-in methods:</p>

<ul>
<li><code>string.startsWith(what)</code></li>
<li><code>string.endsWith(what)</code></li>
<li><code>string.includes(what)</code></li>
<li><code>string.repeat(count)</code></li>
<li><code>string.normalize(method)</code></li>
<li><code>string.codePointAt(position)</code></li>
</ul>


<p>There is also an extra &ldquo;static&rdquo; method:</p>

<ul>
<li><code>String.fromCodePoint(codePoint)</code></li>
</ul>

]]></content>
  </entry>
  
</feed>
