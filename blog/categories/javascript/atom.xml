<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2015-03-10T16:10:06+01:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[More ES6 Features]]></title>
    <link href="http://jsteemann.github.io/blog/2015/02/26/more-es6-features/"/>
    <updated>2015-02-26T12:00:46+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/02/26/more-es6-features</id>
    <content type="html"><![CDATA[<p>ArangoDB 2.5 comes with an upgraded version of V8, Google&rsquo;s open source JavaScript engine.</p>

<p>The built-in version of V8 has been upgraded from 3.29.54 to 3.31.74.1.</p>

<p>In addition to several already usable ES6 features (detailed in
<a href="https://jsteemann.github.io/blog/2014/12/19/using-es6-features-in-arangodb/">this blog</a>,
the following ES6 features are activated in ArangoDB 2.5 by default:</p>

<ul>
<li>iterators and generators</li>
<li>template strings</li>
<li>enhanced object literals</li>
<li>enhanced numeric literals</li>
<li>block scoping with <code>let</code> and constant variables using <code>const</code></li>
<li>additional String methods (such as <code>startsWith</code>, <code>repeat</code> etc.)</li>
</ul>


<p>The above features are available in ArangoDB 2.5, and can now be used for scripting purposes
in the ArangoShell and in server-side Foxx actions inside the database.</p>

<p>This blog post briefly explains the features provides some quick examples for using them.</p>

<!-- more -->


<h2>Iterators and generators</h2>

<p>Iterator and generator support was optional in 2.4, but is turned on by default since 2.5.</p>

<p>For everyone who is not familiar with generators in JavaScript, here&rsquo;s how they work:</p>

<p>Generators are special functions tagged with an asterisk (<code>*</code>). Values are returned to the
caller using the <code>yield</code> keyword:</p>

<p><code>js a simple generator that generates two values                                                            
function* generate () {                                                                                       
  yield 23;                                                                                                   
  yield 42;                                                                                                   
}                                                                                                            
</code></p>

<p>Calling the function with initialize/reset the generator. Calling the <code>next()</code> method on
the generator&rsquo;s initial call return value produces the next sequence element. The element
is returned in a <code>value</code> attribute. The <code>done</code> attribute indicates whether the sequence
has come to an end:</p>

<p><code>js invoking the generator
var generator = generate();                                                                                   
console.log(generator.next());  /* { "value" : 23, "done" : false } */                                        
console.log(generator.next());  /* { "value" : 42, "done" : false } */                                        
console.log(generator.next());  /* { "value" : undefined, "done" : true } */                                  
</code></p>

<p>Sequences produced by generators can also be consumed via a <code>for...of</code> loop:</p>

<p>```js consuming all values from a generator function
var generator = generate();</p>

<p>for (var value of generator) {
  console.log(value);
}
```</p>

<p>In general, every object that is iteratable can be consumed using the <code>of</code> operator.
Some built-in objects provide pre-defined iterators (e.g. <code>Map.keys()</code> or <code>Map.values()</code>),
but you can also create iterators for your own objects:</p>

<p>```js creating an iterator for an object
function Sentence (text) {
  this.text = text;
}</p>

<p>Sentence.prototype[Symbol.iterator] = function*() {
  var regex = /\S+/g;
  var text = this.text;
  var match;
  while (match = regex.exec(text)) {</p>

<pre><code>yield match[0]; 
</code></pre>

<p>  }
};</p>

<p>var sentence = new Sentence(&ldquo;The quick brown fox jumped over the lazy dog&rdquo;);
for (var word of sentence) {
  console.log(word);
}
```</p>

<h2>Template strings</h2>

<p>I know there are query string generators and such, but for the sake of the example, let&rsquo;s assume you
wanted to write a query string in JavaScript. You might end up with something like this:</p>

<p><code>js multi-line query string
var query =
  'FOR doc IN users\n' +
  '  FILTER doc.name == @name\n' +
  '  RETURN doc\n';
</code></p>

<p>This is hardly legible, and it is also very prone to errors.</p>

<p>ES6 template strings provide a way to define multi-line string literals in a much easier and simpler way.
Here&rsquo;s how to do it (note the backticks instead of the regular string quotes):</p>

<p><code>js using a multi-line template string
var query = `
FOR doc IN users
  FILTER doc.name == @name
  RETURN doc
`;
</code></p>

<p>Template strings also support value substitution, so you could even write something like this, too:
```js value substitution in template strings
var name = &ldquo;AQL injection attempt \&rdquo; OR true OR \&ldquo;&rdquo;;</p>

<p>var query = <code>
FOR doc IN users
  FILTER doc.name == ${JSON.stringify(name)}
  RETURN doc
</code>;
```</p>

<p>Note that while value substitution in template strings in convenient, you still have to be careful with
user-generated values. Otherwise you might be subject to value injection attacks, as you would be with
every other form of improper user value handling.</p>

<h2>Enhanced object literals</h2>

<p>Save some time when definining objects:</p>

<p>```js using enhanced object literals
var name = &ldquo;foobar&rdquo;;</p>

<p>myObject = {
  type : &ldquo;myType&rdquo;,   /<em> always worked </em>/
  name,              /<em> same as &ldquo;name&rdquo; : name </em>/
  save () {          /<em> same as &ldquo;save&rdquo; : function () &hellip; </em>/</p>

<pre><code>console.log("save called!"); 
</code></pre>

<p>  }
};</p>

<p>{
  &ldquo;type&rdquo; : &ldquo;myType&rdquo;,
  &ldquo;name&rdquo; : &ldquo;foobar&rdquo;,
  &ldquo;save&rdquo; : [Function &ldquo;console.log("save called!&rdquo;);&ldquo; &hellip;]
}
```</p>

<p>As can be seen above, enhanced object literal declarations can save some typing and reduce redundancies
in the code. Unfortunately we still cannot use object key names generated from expressions:</p>

<p><code>js does not work yet
myObject = {
  [ "foo" + bar" ] : "foobar"
};
</code></p>

<h2>Enhanced numeric literals</h2>

<p>Numeric values can now be specified in binary or octal if required:</p>

<p><code>js numeric literals                                                                                        
var life = 0b101010;          /* binary, 42 in decimal */                                                     
var filePermissions = 0o777;  /* octal, 511 in decimal */                                                     
</code></p>

<h2>Block scoping</h2>

<p>As a mostly C++ programmer, I am always puzzled about the scoping of JavaScript variables.
In the following example, variable <code>x</code> does not only live inside the curly brackets block in which
it was declared, but also afterwards:</p>

<p>```
function work () {
  {</p>

<pre><code>var x = 1;
</code></pre>

<p>  }
  return x;
}
```</p>

<p>The reason is that the curly brackets around <code>var x = 1;</code> are not a scope at all in traditional
JavaScript. This sucks, because variables can linger around in programs longer than necessary,
leading to unwanted side-effects.</p>

<p>With block-level scopes, this can be fixed. To use it, introduce variables not with the <code>var</code>
keyword, but with <code>let</code>. <code>let</code> only works in strict mode, so make sure your function or module
uses it.</p>

<p>Now, with block-level scoping, the above snippet looks like this:
```
function work () {
  &ldquo;use strict&rdquo;;
  {</p>

<pre><code>let x = 1; 
</code></pre>

<p>  }
  return x;
};
```</p>

<p>And it will actually produce an error when trying to access variable <code>x</code> in the <code>return</code> statement.
The reason is that the life of <code>x</code> was over as soon as its scope was left. The scope of variable <code>x</code> is
now only the one with the <code>let</code> declaration inside the curly brackets.</p>

<p>Someone else said &ldquo;<em>let is the new var</em>&rdquo;, and I think there&rsquo;s not much to add.</p>

<p>Additionally, the <code>const</code> keyword can be used to define a read-only variables. Trying to re-define a
constant will produce an error in strict mode (the desired behavior), and do nothing in non-strict mode.
Another reason to use the strict mode.</p>

<h2>Additional String methods</h2>

<p><code>String</code> objects now provide extra built-in methods:</p>

<ul>
<li><code>string.startsWith(what)</code></li>
<li><code>string.endsWith(what)</code></li>
<li><code>string.includes(what)</code></li>
<li><code>string.repeat(count)</code></li>
<li><code>string.normalize(method)</code></li>
<li><code>string.codePointAt(position)</code></li>
</ul>


<p>There is also an extra &ldquo;static&rdquo; method:</p>

<ul>
<li><code>String.fromCodePoint(codePoint)</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Dynamic Attribute Names in AQL]]></title>
    <link href="http://jsteemann.github.io/blog/2015/02/03/using-dynamic-attribute-names-in-aql/"/>
    <updated>2015-02-03T00:12:39+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/02/03/using-dynamic-attribute-names-in-aql</id>
    <content type="html"><![CDATA[<p>On our mailing list, there is quite often the question whether attribute names in objects
returned from AQL queries can be made dynamic.</p>

<p>Here&rsquo;s a (non-working) example query for this:</p>

<p><code>plain example query that does not work
FOR doc IN collection
  RETURN { doc.type : doc.value }
</code></p>

<p>The intention in the above query obviously is to use the dynamic value from <code>doc.type</code> as
an attribute name in the result object and not to have an attribute named <code>"doc.type"</code>. This
feature is probably in the top 20 of the most-often wished features.</p>

<!-- more -->


<p>However, the above query won&rsquo;t even parse. The AQL grammar only allows string values
left of the colon in an object definition. Non-quoted strings are allowed there too, and are
implicitly turned into quoted strings. It works similar to how object literals are defined
in JavaScript:</p>

<p><code>plain using unquoted and quoted string attribute names
RETURN {
  foo : "bar",
  "baz" : "qux"
}
</code></p>

<p>Why not allow arbitrary expression left of the colon? The reason is simple: this would cause
ambiguity and probably have side-effects. For an example, have a look at the following query:</p>

<p><code>plain which attribute name to use here?
FOR doc IN collection
  LET type = doc.type;
  RETURN { type : doc.value }
</code></p>

<p>If the <code>type</code> attribute name inside the object definition is interpreted as a string literal
as it currently is an AQL (and always was), then the resulting attribute name is just <code>"type"</code>.</p>

<p>If the <code>type</code> attribute name would now be intepreted as an expression, it would get the value
that was assigned to the variable <code>type</code> by the <code>LET</code> statement. Removing the <code>LET</code> from the
query would change the attribute name in the result back to the string literal <code>"type"</code>.</p>

<p>The ambiguity could be solved by telling the parser what to do in such cases. While technically
this could be working, I think it may have too many unintended side-effects. I already mentioned
that introducing a <code>LET</code> statement into the query would change the attribute name in the result.
The same could also happen if a collection named <code>type</code> was added to the query. And it would
break compatibility with existing queries.</p>

<p>JavaScript has the same problem, and it wasn&rsquo;t solved portably yet. However, there is a proposal
for ES6 that suggests enclosing attribute name expressions in <code>[</code> and <code>]</code>.</p>

<p>To me, this looks like a good solution for the problem. It&rsquo;s two bytes more when keying in
queries, but the syntax is easy and explicit. There are no ambiguities.</p>

<p>I prototyped this solution for AQL, so I could write:</p>

<p>```plain query using dynamic attribute names
FOR i IN 1..5
  RETURN {</p>

<pre><code>[ CONCAT('test', i) ] : i, 
[ SUBSTITUTE(CONCAT('i is ', (i &lt;= 3 ? 'small' : 'not small')), { ' ' :  '_' } ) ] : i 
</code></pre>

<p>  }</p>

<p>[
  {</p>

<pre><code>"test1" : 1, 
"i_is_small" : 1 
</code></pre>

<p>  },
  {</p>

<pre><code>"test2" : 2, 
"i_is_small" : 2 
</code></pre>

<p>  },
  {</p>

<pre><code>"test3" : 3, 
"i_is_small" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"test4" : 4, 
"i_is_not_small" : 4 
</code></pre>

<p>  },
  {</p>

<pre><code>"test5" : 5, 
"i_is_not_small" : 5 
</code></pre>

<p>  }
]
```</p>

<p>I ran a few queries with this, and they seemed to work. <del>However, I haven&rsquo;t
committed the feature yet. There might still be cases in which it doesn&rsquo;t work. Tests
for the feature are also still missing. I hope I can finalize the implementation soon
so it becomes available in some release.</del></p>

<p><strong>UPDATE</strong>: tests have been added, and the feature has been committed in devel. It is
included in ArangoDB since version 2.5.</p>

<p>Everyone is welcome to try it out already!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using ES6 Features in ArangoDB]]></title>
    <link href="http://jsteemann.github.io/blog/2014/12/19/using-es6-features-in-arangodb/"/>
    <updated>2014-12-19T19:12:06+01:00</updated>
    <id>http://jsteemann.github.io/blog/2014/12/19/using-es6-features-in-arangodb</id>
    <content type="html"><![CDATA[<p>ArangoDB 2.4 will be shipped with an <em>updated version of V8</em>.</p>

<p>The V8 version included in 2.4 will be 3.29.59. This version will replace the
almost two year old 3.16.14. A lot of things happened in V8 since then, and a lot
of ES6 features have been added to it.</p>

<p><strong>ES6 is not finalized yet</strong>, and support for it is a <a href="http://kangax.github.io/compat-table/es6/">work in progress on all
platforms</a>.</p>

<p>ES6 provides many cool features that can make JavaScript developer&rsquo;s life easier.
In this blog post, I&rsquo;ll summarize a few ES6 features that are available in
ArangoDB, either for scripting purposes in the ArangoShell, or in your server-side
Foxx actions inside the database.</p>

<p>I don&rsquo;t want to put you off until Doomsday. ArangoDB 2.4 should be released next
week. Time to play with some ES6 features!</p>

<!-- more -->


<h1>Summary for the impatient</h1>

<p>The following ES6 features are available in ArangoDB 2.4 by default:</p>

<ul>
<li>iterators</li>
<li>the <code>of</code> operator</li>
<li>symbols</li>
<li>predefined collections types (Map, Set etc.)</li>
<li>typed arrays</li>
</ul>


<p>Many other ES6 features are disabled by default, but can be made available by
starting arangod or arangosh with the appropriate options:</p>

<ul>
<li>arrow functions</li>
<li>proxies</li>
<li>generators</li>
<li>String, Array, and Number enhancements</li>
<li>constants</li>
<li>enhanced object and numeric literals</li>
</ul>


<p>To activate all these ES6 features, start arangod or arangosh with the following
options:</p>

<pre><code>arangosh --javascript.v8-options="--harmony --harmony_generators"
</code></pre>

<h1>Activating ES6 features</h1>

<p>Work on ES6, also dubbed <em>Harmony</em> or <em>ES.next</em>, is still in progress. At the time
of this writing, the ES6 specification was still in draft status.</p>

<p>Therefore no platform has implemented all ES6 features yet. And because ES6 is
still a moving target, the already implemented features should still be considered
experimental.</p>

<p>This is true for all environments that implement ES6 features. For example, Firefox
and other browsers contain lots of experimental ES6 features already, providing a
notice that these might change in future versions.</p>

<p>V8 is no exception here. It has turned most ES6 features off by default, but it
provides several command-line options to turn them on explicitly.</p>

<p>The V8 version used for ArangoDB 2.4 provides the following ES6-related switches:</p>

<ul>
<li><code>--harmony_scoping</code> (enable harmony block scoping)</li>
<li><code>--harmony_modules</code> (enable harmony modules (implies block scoping))</li>
<li><code>--harmony_proxies</code> (enable harmony proxies)</li>
<li><code>--harmony_generators</code> (enable harmony generators)</li>
<li><code>--harmony_numeric_literals</code> (enable harmony numeric literals (0o77, 0b11))</li>
<li><code>--harmony_strings</code> (enable harmony string)</li>
<li><code>--harmony_arrays</code> (enable harmony arrays)</li>
<li><code>--harmony_arrow_functions</code> (enable harmony arrow functions)</li>
<li><code>--harmony_classes</code> (enable harmony classes)</li>
<li><code>--harmony_object_literals</code> (enable harmony object literal extensions)</li>
<li><code>--harmony</code> (enable all harmony features (except proxies))</li>
</ul>


<p>These switches are all off by default. To turn on features for either arangod
or arangosh, start it with the V8 option(s) wrapped into the ArangoDB option
<code>--javascript.v8-options</code>, e.g.:</p>

<pre><code>arangosh --javascript.v8-options="--harmony_proxies --harmony_generators --harmony_array"
</code></pre>

<p>On a side note: node.js is also using V8. Turning on ES6 features in node.js almost
works the same way. Just omit the surrounding <code>--javascript.v8-options="..."</code>:</p>

<pre><code>node --harmony_proxies --harmony_generators --harmony_array
</code></pre>

<p>Note that the V8 options can only be set for the entire process (i.e. arangosh, arangod
or node.js), and not just for a specific script or application. In reality this shouldn&rsquo;t be
too problematic as the vast majority of ES6 features is downwards-compatible to ES5.1.</p>

<h1>ES6 features by example</h1>

<p>Following I have listed a few select ES6 features that are usable in ArangoDB 2.4,
in no particular order. I have omitted a few ES6 features that aren&rsquo;t supported in bundled
V8 version, and also omitted <em>classes</em> and <em>modules</em> due to lack of time.</p>

<h2>Arrow functions</h2>

<p>ES6 provides an optional arrow function syntax. The arrow function syntax is a shorthand for
writing a full-blown function declaration. Here&rsquo;s an example:</p>

<p>```js a simple arrow function
/<em> defines function pow </em>/
var pow = (value => value * value);</p>

<p>/<em> calls pow </em>/
pow(15);  /<em> 225 </em>/
```</p>

<p>Arrow functions can also take multiple parameters. The syntax then becomes:
```js arrow function with multiple parameters
/<em> defines function sum </em>/
var sum = (a, b) => a + b;</p>

<p>/<em> calls sum </em>/
sum(3, 7);  /<em> 10 </em>/
```</p>

<p>So far we have only seen arrow functions with simple expressions, but arrow function bodies
can also be more complex and can contain multiple statements:
```js more complex arrow functions
var translations = {
  &ldquo;en&rdquo; : &ldquo;English&rdquo;,
  &ldquo;fr&rdquo; : &ldquo;French&rdquo;,
  &ldquo;de&rdquo; : &ldquo;German&rdquo;
};</p>

<p>/<em> using multiple statements </em>/
[&ldquo;en&rdquo;, &ldquo;fr&rdquo;, &ldquo;xx&rdquo;].map(value => {
  if (translations.hasOwnProperty(value)) {</p>

<pre><code>return translations[value];
</code></pre>

<p>  }
  return &ldquo;unknown!&rdquo;;
});
```</p>

<p>Arrow functions are turned off by default. To enable them in arangod or arangosh, start them
with the option <code>--javascript.v8-options="--harmony_arrow_functions"</code>.</p>

<h2>Maps and sets</h2>

<p>ES6 maps provide a specialized alternative to regular objects in case a <em>lookup-by-key</em>
functionality is required.</p>

<p>When no maps are available, storing keys mapped to objects is normally done using a plain
object. With ES6, the same use case can be handled with using a <strong>Map</strong> object:
```js using an ES6 Map object
var m = new Map();</p>

<p>/<em> set 5M keys </em>/
for (var i = 0; i &lt; 5000000; ++i) {
  m.set(&ldquo;test&rdquo; + i, i);
}
```</p>

<p>ES6 maps can be more efficient than plain objects in some cases. For the above case of
storing 5M entries, an ES6 map is about twice as fast as a plain object on my laptop.
Though there might be cases we are plain objects are still faster.</p>

<p>There&rsquo;s more to ES6 Maps than just efficiency:</p>

<ul>
<li>ES6 maps provide a member <code>size</code> which keeps track of the number of objects in the map.
This is hard to achieve with a plain object.</li>
<li>Objects can only have string keys, whereas map keys can have different key types.</li>
<li>They don&rsquo;t inherit keys from the prototype, so there is no <code>hasOwnProperty</code> hassle with Maps.</li>
</ul>


<p>ES6 also comes with a specialized <strong>Set</strong> object. The Set object is a good alternative to
plain JavaScript objects when the use case is to track unique values. Using a Set is more
intuitive, potentially more efficient and may require even less memory than when implementing
the same functionality with a plain JavaScript object:</p>

<p>```js using an ES6 Set object
var s = new Set();</p>

<p>/<em> set 5M values </em>/
for (var i = 0; i &lt; 5000000; ++i) {
  s.add(&ldquo;test&rdquo; + i);
}
```</p>

<p>Maps and sets are enabled by default in arangod and arangosh. No special configuration is needed
to use them in your code.</p>

<h2>Proxy objects</h2>

<p>Proxy objects can be used to intercept object property accesses at runtime. This can be used
for meta-programming in many real-world situations, e.g.:</p>

<ul>
<li>preventing, auditing and logging property accesses</li>
<li>calculated / derived properties</li>
<li>adding a compatibility layer on top of an object</li>
</ul>


<p>Here&rsquo;s an example that logs property accesses on the proxied object:
```js using a Proxy object
var proxy = Proxy.create({
  get: function (obj, name) {</p>

<pre><code>console.log("read-accessing property '%s'", name);
</code></pre>

<p>  },
  set: function (obj, name) {</p>

<pre><code>console.log("write-accessing property '%s'", name);
</code></pre>

<p>  }
});</p>

<p>proxy.foo = &ldquo;bar&rdquo;;   /<em> write-accessing property &lsquo;foo&rsquo; </em>/
proxy.foo;           /<em> read-accessing property &lsquo;foo&rsquo; </em>/
```</p>

<p>Proxy objects are not available by default. To enable them in arangod or arangosh, start them
with the option <code>--javascript.v8-options="--harmony_proxies"</code>.</p>

<h2>Iterators and generators</h2>

<p>ES6 provides generators and iterators. They can be used individually or in combination.</p>

<p>Let&rsquo;s start with a simple example of a generator that will generate only two values:
```js a simple generator that generates two values
function* generate () {
  yield 23;
  yield 42;
}</p>

<p>var generator = generate();
console.log(generator.next());  /<em> { &ldquo;value&rdquo; : 23, &ldquo;done&rdquo; : false } </em>/
console.log(generator.next());  /<em> { &ldquo;value&rdquo; : 42, &ldquo;done&rdquo; : false } </em>/
console.log(generator.next());  /<em> { &ldquo;value&rdquo; : undefined, &ldquo;done&rdquo; : true } </em>/
<code>``
As can be seen above, the value yielded by the generator function will be returned
wrapped into an object with a</code>value<code>and a</code>done` attribute automatically.</p>

<p>The general pattern to consume all values from a generator function is to call
its <code>next()</code> method until its <code>done</code> value is <code>true</code>:
```js consuming all values from a generator function
var generator = generate();</p>

<p>while (true) {
  value = generator.next();
  if (value.done) {</p>

<pre><code>break;
</code></pre>

<p>  }
  console.log(value.value);
}
```</p>

<p>An alternative to that is to use an iterator (note the new <code>of</code> operator):
```js consuming all values from a generator function
var generator = generate();</p>

<p>for (var value of generator) {
  console.log(value);
}
```</p>

<p>Generator functions produce their values lazily. Therefore it is possible
and not inefficent to write generators that produce never-ending sequences.
Though one must be careful to abort iterating over the generator values
at some point if the sequence does not terminate:
```js a generator producing an endless sequence
function* generate () {
  var i = 0;
  while (true) {</p>

<pre><code>yield ++i;
</code></pre>

<p>  }
}</p>

<p>var generator = generate();</p>

<p>/<em> note: this will not terminate </em>/
for (var value of generator) {
  console.log(value);
}
```</p>

<p>We have now seen two uses of iterators as part of the previous examples.
As demoed, generator function values can be iterated with the <code>of</code> operator
without any further ado. Apart from generators, a few other built-in types
also provide ready-to-use iterators. The most prominent are <code>String</code> and <code>Array</code>:
```js iterating over the characters of a string
var text = &ldquo;this is a test string&rdquo;;</p>

<p>for (var value of text) {
  console.log(value);
}
```
The above example will iterate all the individual characters of the string.</p>

<p>The following example iterates the values of an Array:
```js iterating over the values of an array
var values = [ &ldquo;this&rdquo;, &ldquo;is&rdquo;, &ldquo;a&rdquo;, &ldquo;test&rdquo; ];</p>

<p>for (var value of values) {
  console.log(value);
}
<code>``
This will produce</code>&ldquo;this&rdquo;<code>,</code>&ldquo;is&rdquo;<code>,</code>&ldquo;a&rdquo;<code>,</code>&ldquo;test&rdquo;<code>. This is normally what is
desired when iterating over the values of an Array. Compare this to the</code>in<code>
operator which would produce</code>0<code>,</code>1<code>,</code>2<code>and</code>3` instead.</p>

<p>Map and Set objects also implement iterators:
```js iterating over the contents of a Map
var m = new Map();</p>

<p>m.set(&ldquo;Sweden&rdquo;, &ldquo;Europe&rdquo;);
m.set(&ldquo;China&rdquo;, &ldquo;Asia&rdquo;);
m.set(&ldquo;Bolivia&rdquo;, &ldquo;South America&rdquo;);
m.set(&ldquo;Australia&rdquo;, &ldquo;Australia&rdquo;);
m.set(&ldquo;South Africa&rdquo;, &ldquo;Africa&rdquo;);</p>

<p>for (var value of m) {
  console.log(value);
}
```</p>

<p>Note that Maps also provide dedicated iterators for just their keys or
their values:
```js iterating over keys and values of a Map
for (var country of m.keys()) {
  console.log(country);
}</p>

<p>for (var continent of m.values()) {
  console.log(continent);
}
```</p>

<p>Rolling an iterator for your own object is also possible by implementing the method
<code>Symbol.iterator</code> for it:
```js creating an iterator for an object
function Sentence (text) {
  this.text = text;
}</p>

<p>/<em> create the actual iterator method </em>/
/<em> note that the iterator is a generator function here </em>/
Sentence.prototype[Symbol.iterator] = function*() {
  var regex = /\S+/g;
  var text = this.text;
  var match;
  while (match = regex.exec(text)) {</p>

<pre><code>yield match[0]; 
</code></pre>

<p>  }
};</p>

<p>var sentence = new Sentence(&ldquo;The quick brown fox jumped over the lazy dog&rdquo;);
/<em> invoke the iterator </em>/
for (var word of sentence) {
  console.log(word);
}
```</p>

<p>Generators and iterators are not available by default. To enable them in arangod
or arangosh, start them with the option <code>--javascript.v8-options="--harmony_generators"</code>.</p>

<h2>String enhancements</h2>

<p>ES6 provides the following convenience string functions:</p>

<ul>
<li>string.startsWith(what)</li>
<li>string.endsWith(what)</li>
<li>string.includes(what)</li>
<li>string.repeat(count)</li>
<li>string.normalize(method)</li>
<li>string.codePointAt(position)</li>
<li>String.fromCodePoint(codePoint)</li>
</ul>


<p>These functions are mostly self-explaining, so I won&rsquo;t explain them in more
detail here. Apart from that, these functions are turned off by default.
To enable them in arangod or arangosh, start them with the option
<code>--javascript.v8-options="--harmony_strings"</code>.</p>

<h2>Array enhancements</h2>

<p>ES6 provides the following enhancements for the <code>Array</code> object:</p>

<ul>
<li>array.find(function)</li>
<li>array.findIndex(function)</li>
<li>array.keys()</li>
<li>array.values()</li>
<li>Array.observe(what, function)</li>
</ul>


<p>Here are a few examples demoing these functions:
```js Array enhancements
var values = [ 1, 2, 9, 23, 42 ];</p>

<p>/<em> returns the first Array element for which the function returns true </em>/
values.find(function (value) {
  return value === 23;
});</p>

<p>/<em> returns the first Array index for which the function returns true </em>/
values.findIndex(function (value) {
  return value === 23;
});</p>

<p>/<em> iterate over the keys of the Array </em>/
for (var key of values.keys()) {
  console.log(key);
}</p>

<p>/<em> iterate over the values of the Array </em>/
for (var key of values.values()) {
  console.log(key);
}</p>

<p>/<em> observe all changes to an Array </em>/
Array.observe(values, function (changes) {
  console.log(changes);
});</p>

<p>/<em> trigger a change to the observed Array </em>/
values.push(117);
```</p>

<p>The Array enhancements are turned off by default. To enable them in arangod or
arangosh, start them with the option <code>--javascript.v8-options="--harmony_arrays"</code>.</p>

<h2>Number enhancements</h2>

<p>The <code>Number</code> object is extended with the following ES6 functions:</p>

<ul>
<li>Number.isInteger(value)</li>
<li>Number.isSafeInteger(value)</li>
</ul>


<p>There are also <code>Number.MIN_SAFE_INTEGER</code> and <code>Number.MAX_SAFE_INTEGER</code> so applications
can programmatically check whether a numeric value can still be stored in the range of
-2<sup>53</sup> to +2<sup>53</sup> without potential precision loss.</p>

<h2>Constants</h2>

<p>The <code>const</code> keyword can be used to define a read-only constant. The constant must be
initialized and a variable with the same name should not be redeclared in the same scope.</p>

<p>Here is an example of using <code>const</code>:
<code>js using const to create a read-only variable
function calculate (value) {
  const magicPrime = 23;
  return magicPrime ^ value;
}
</code></p>

<p>In non-strict mode, <code>const</code> variables behave non-intuitively. Re-assigning a value
to a variable declared <code>const</code> does not throw an exception, but the assignment will
not be carried out either. Instead, the assignment will silently fail and the <code>const</code>
variable will keep its original value:</p>

<p><code>js re-assigning a value to a const variable
function mystery () {
  const life = 42;
  life = 23;        /* does not change value and does not throw! */
  return life;      /* will return 42 */
}
</code></p>

<p><code>js re-assigning a value to a const variable, using strict mode
function mystery () {
  "use strict";
  const life = 42;
  life = 23;        /* will throw SyntaxError "assignment to constant variable" */
}
</code></p>

<p>The <code>const</code> keyword is disabled by default. To enable it in arangod or arangosh,
start them with the option <code>--javascript.v8-options="--harmony_scoping"</code>.</p>

<h2>Enhanced object literals</h2>

<p>ES6 provides a shorthand for defining methods in object literals.</p>

<p>The following example creates a normal method named <code>save</code> in <code>myObject</code>:</p>

<p>```js shorthand method declaration
var myObject = {
  type: &ldquo;myType&rdquo;,
  save () {</p>

<pre><code>console.log("save");
</code></pre>

<p>  }
};
```</p>

<p>Interestingly, the object literals seem to work for method declarations only.
I did not get them to work for non-method object properties, though ES6 allows that.
It seems that this is not implemented in V8 yet.</p>

<p>Enhanced object literals are turned off by default. To enable them in arangod
or arangosh, start them with the option <code>--javascript.v8-options="--harmony_object_literals"</code>.</p>

<h2>Enhanced numeric literals</h2>

<p>For the ones that love working with binary- or octal-encoded numbers, ES6 has
support for this too:
<code>js numeric literals
var life = 0b101010;          /* binary, 42 in decimal */
var filePermissions = 0o777;  /* octal, 511 in decimal */
</code></p>

<p>Enhanced numeric literals are turned off by default. To enable them in arangod
or arangosh, start them with the option <code>--javascript.v8-options="--harmony_numeric_literals"</code>.</p>

<h2>Symbols</h2>

<p>ES6 also provides a Symbol type. Symbols are created using the global <code>Symbol()</code> function.
Each time this function is called, a new Symbol object will be created.
A Symbol can be given an optional name, but this name cannot be used to identify the
Symbol later. However, Symbols can be compared by identity.</p>

<p>What one normally wants is to use the same Symbol from different program parts. In this
case, a Symbol should not be created with the <code>Symbol()</code> function, but with <code>Symbol.for()</code>.
This will register the Symbol in a global symbol table if it is not there yet, and return
the Symbol if already created:</p>

<p>```js using named Symbols
var typeAttribute = Symbol.for(&ldquo;type&rdquo;);
var carType = Symbol.for(&ldquo;car&rdquo;);
var trainType = Symbol.for(&ldquo;train&rdquo;);</p>

<p>var object1 = { };
object1[typeAttribute] = carType;</p>

<p>var object2 = { };
object2[typeAttribute] = trainType;</p>

<p>/<em> check if the objects have the same type </em>/
object1[typeAttribute] === object2[typeAttribute];  /<em> false </em>/
object1[typeAttribute] === carType;                 /<em> true </em>/
object2[typeAttribute] === carType;                 /<em> false </em>/
object2[typeAttribute] === trainType;               /<em> true </em>/
```</p>

<p>Symbol object properties are not enumerated by default, so they can be used to implement
&ldquo;hidden&rdquo; or internal properties.</p>

<p>Symbols can be used by default in arangod and arangosh. No special configuration is required.</p>

<h2>TypedArrays</h2>

<p>TypedArrays are Arrays whose members all have the same type and size. They are more
specialized (read: limited but efficient) alternatives to the all-purpose <code>Array</code> type.</p>

<p>TypedArrays look and feel a bit like C arrays, and they are often used as an Array-like
view into binary data (for which JavaScript has no native support).</p>

<p>A TypedArray is created (and all of its memory is allocated) by invoking the appropriate
TypedArray constructor:</p>

<ul>
<li>Int8Array</li>
<li>Uint8Array</li>
<li>Uint8ClampedArray</li>
<li>Int16Array</li>
<li>Uint16Array</li>
<li>Int32Array</li>
<li>Uint32Array</li>
<li>Float32Array</li>
<li>Float64Array</li>
</ul>


<p>```js using an Array of unsigned 8 bit integers
var data = new Uint8Array(2);
data[0] = 0b00010101;  /<em> 23 </em>/
data[1] = 0b00101010;  /<em> 42 </em>/</p>

<p>console.log(data[0]);  /<em> 23 </em>/
console.log(data.length * data.BYTES_PER_ELEMENT); /<em> 2 bytes </em>/
```</p>

<p>```js using an Array of 64 bit floating point values
var data = new Float64Array(2);
data[0] = 23.23;</p>

<p>console.log(data[0]);  /<em> 23.23 </em>/
console.log(data[1]);  /<em> 0.0 </em>/
console.log(data.length * data.BYTES_PER_ELEMENT); /<em> 16 bytes </em>/
```</p>

<p>TypedArrays can be used in arangod and arangosh by default. No special
configuration is required to activate them.</p>

<h2>Unsupported ES6 features</h2>

<p>As mentioned before, V8 does not yet support every proposed ES6 feature.
For example, the following ES6 features are currently missing:</p>

<ul>
<li>template strings</li>
<li>function default parameters</li>
<li>rest function parameter</li>
<li>spread operator</li>
<li>destructuring</li>
<li>array comprehension</li>
<li><code>let</code></li>
</ul>


<p>I strongly hope these features will make it into the final version of ES6 and will be
implemented by the V8 team in future versions of V8.</p>

<p>Apart from that, a lot of nice ES6 features are there already and can be used
in ArangoDB applications.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Handling Binary Data in Foxx]]></title>
    <link href="http://jsteemann.github.io/blog/2014/10/15/handling-binary-data-in-foxx/"/>
    <updated>2014-10-15T20:41:30+02:00</updated>
    <id>http://jsteemann.github.io/blog/2014/10/15/handling-binary-data-in-foxx</id>
    <content type="html"><![CDATA[<p>Handling binary data in JavaScript applications is a bit
tricky because JavaScript does not provide a data type for
binary data. This post explains how to use binary data in
JavaScript actions written using ArangoDB&rsquo;s <a href="http://docs.arangodb.org/Foxx/README.html">Foxx</a>.</p>

<!-- more -->


<h1>Strings vs. binary data</h1>

<p>Internally, JavaScript strings are <a href="http://ecma-international.org/ecma-262/5.1/#sec-4.3.16">sequences of 16 bit integer values</a>.
Furthermore, the ECMAScript standard requires that a JavaScript
implementation should interpret characters in conformance with the
Unicode standard, using either UCS-2 or UTF-16 encoding.</p>

<p>While this is fine for handling natural language, it becomes problematic
when trying to work with arbitrary binary data. Binary data cannot be
used safely in a JavaScript string because it may not be valid UTF-16
data.</p>

<p>To make it work anyway, binary data needs to be stored in a wrapper
object. I won&rsquo;t go into details about ES6 typed arrays here, but will
focus on <code>Buffer</code> objects.</p>

<h1>Binary data in Foxx actions</h1>

<p>A Foxx route that shall handle HTTP POST requests containing arbitrary
(binary) body in the request body should not use <code>req.body()</code>. The
reason is that <code>req.body()</code> will return the body as a JavaScript string,
and this isn&rsquo;t going to work with arbitrary binary data.</p>

<p>Instead, the <code>req.rawBodyBuffer()</code> should be used. This will return the
request body inside a buffer.
Here&rsquo;s an example that stores the received data in a file on the server:</p>

<p>```js Foxx action that can handle binary input
controller.post(&lsquo;/receive-binary&rsquo;, function (req, res) {
  // fetch request body into the buffer
  var body = req.rawBodyBuffer();
  // create an absolute filename, local to the Foxx application directory
  var filename = applicationContext.foxxFilename(&ldquo;body&rdquo;);</p>

<p>  require(&ldquo;fs&rdquo;).write(filename, body);
});
```</p>

<p>This action can be invoked as follows if the app is mounted with name <code>app</code>:</p>

<pre><code>curl -X POST http://localhost:8529/app/receive-binary --data-binary @filename
</code></pre>

<p>This will send the contents of the file <code>filename</code> to the server. The Foxx
action will then store the received data as is in a file name <code>body</code> in the
application directory.</p>

<p>Returning binary data from a Foxx action is simple, too. Here&rsquo;s a way that
returns the contents of the file named <code>body</code> in the application&rsquo;s directory:
<code>js Foxx action that returns contents of a file
controller.get('/provide-binary-file', function (req, res) {
  // create an absolute filename, local to the Foxx application directory
  var filename = applicationContext.foxxFilename("body");
  // send the contents, this will also set mime type "application/octet-stream"
  res.sendFile(filename);
});
</code></p>

<p>It is also possible to return data from an arbitrary buffer:
```js Foxx action that returns data in a buffer
controller.get(&lsquo;/provide-binary-buffer&rsquo;, function (req, res) {
  // create an absolute filename, local to the Foxx application directory
  var filename = applicationContext.foxxFilename(&ldquo;body&rdquo;);
  // read the file content into a buffer
  var fileContent = require(&ldquo;fs&rdquo;).readBuffer(filename);</p>

<p>  // TODO: modify the contents of buffer here&hellip;</p>

<p>  // send the contents, this will also set mime type &ldquo;application/octet-stream&rdquo;
  res.send(fileContent);
});
```</p>

<h1>Example application</h1>

<p>I quickly put together an example application that shows how to handle arbitrary
binary data in Foxx actions. The example app allows uploading files to the server.
The server will then list these files and allows downloading them again.</p>

<p>The application has no CSS at all. Its only purpose is to demo the server-side code.
The application can be downloaded <a href="/downloads/code/filelist-app.tar.gz">here</a>.</p>

<p>Please note that the example application requires ArangoDB 2.3, which is currently
in development.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Where Operations Are Executed]]></title>
    <link href="http://jsteemann.github.io/blog/2014/08/30/understanding-where-operations-are-executed/"/>
    <updated>2014-08-30T22:38:42+02:00</updated>
    <id>http://jsteemann.github.io/blog/2014/08/30/understanding-where-operations-are-executed</id>
    <content type="html"><![CDATA[<p>I recently had to deal with some data processing operation that took
about 20 minutes to complete. When looking into this, I found that the
easiest and most beneficial change to the whole setup was to make the
operation a <em>server-side</em> operation instead of executing it <em>client-side</em>.</p>

<p>This change reduced the operation&rsquo;s total execution time to a few seconds.</p>

<!-- more -->


<p>I can&rsquo;t show the original processing task here, so I&rsquo;ll start with a
contrived example. Imagine the following <em>for</em> loop inserting 100K documents
into a collection named <code>test</code>:
<code>js inserting 100k documents
for (i = 0; i &lt; 100000; ++i) {
  db.test.save({ value: i });
}
</code>
Now we only need a client application to execute the operation. As I don&rsquo;t
have a presentable client application right now, I will use the ArangoShell as
my client application.</p>

<h2>What&rsquo;s in a for loop?</h2>

<p>Running the above <em>for</em> loop inside the ArangoShell will lead to the loop being
executed inside the <em>arangosh</em> process.</p>

<p>In order to save a document in the collection, arangosh (our client) must make a
call to the ArangoDB server. This means issuing an HTTP POST request
to the server&rsquo;s REST API at <code>/_api/document/?collection=test</code>.
The server process will receive this request, insert the document, and
respond with an HTTP status code 201 or 202 to our client.
The client will then continue the loop until all documents have been inserted.</p>

<p>Now it&rsquo;s easy to see that the simple 3-line loop will issue 100,000 HTTP requests
in total. This means lots of data being pushed through the network stack(s).
It is pretty easy to imagine that this will come at a cost.</p>

<p>If we instead execute the above loop directly inside the ArangoDB server, we
can get rid of all the network overhead. The server has no need to send HTTP
calls to itself. It can simply execute the 100K inserts and is then done.
We therefore assume the loop to run somewhat faster when executed server-side.</p>

<p>A quick test on a crap laptop produced the following execution times for running
the loops:</p>

<ul>
<li>server-side execution (arangod): 1.34 seconds</li>
<li>client-side execution (arangosh): 17.32 seconds</li>
</ul>


<p><strong>Ouch</strong>. It looks like the client-server request-response overhead matters.</p>

<p>The following sections deal with how to get rid of some or even all the
client-server ping pong.</p>

<h2>Graph traversals</h2>

<p>The above <em>for</em> loop example was contrived, but imagine running
a client-side graph traversal instead. In fact, the original problem mentioned
in the introduction has been a graph traversal.</p>

<p>The problem of a graph traversal is that is often iterative and highly
dynamic. Decisions are made during the traversal as nodes are encountered,
leading to dynamic inclusion or exclusion etc. This means that it makes sense to
process nodes and edges only when needed, at the point when they are visited.</p>

<p>Even if the client can employ some sort of caching for already visited
nodes, the client still needs to ask the server about each visited
node&rsquo;s connections at least once. Otherwise it could not follow them.</p>

<p>This normally means lots of requests and responses. Compare this to the
<em>single</em> request-response alternative in which a client kicks off a server-side
traversal, and finally receives the overal result once it is assembled.</p>

<p><strong>Conclusion</strong>: traversals on anything but very small graphs should be run server-side.
A server-side action (see below) is a good way to do this. Please note that
running a server-side traversal does not mean giving up flexibility and
control flow functionality. Server-side traversals remain highly configurable
through custom JavaScript functions that allow implementation of user-defined
business logic.</p>

<h2>AQL queries</h2>

<p>We won&rsquo;t have your application send a series of 100,000 individual
insert statements to the relational database of our choice. We already
know from the past that this is going to be rather slow, so we have
learned to avoid this. In the relational context, we rather use SQL queries
that create or modify many rows in one go, e.g. an <code>INSERT INTO ... SELECT ...</code>,
bulk inserts etc.</p>

<p>ArangoDB is no different. In general, you should try to avoid issuing lots
of individual queries to the database from a client application. Instead and if
the queries look alike, try converting multiple individual operations into a
single AQL query. This will already save a lot of network overhead.</p>

<p>AQL provides multi-document operations to insert, update, and remove data. An
overview is given <a href="http://docs.arangodb.org/Aql/DataModification.html">here</a>.</p>

<p>The above 100K inserts from the contrived example can easily be transformed
into this single AQL query:
<code>
FOR i IN 1..100000 INSERT { value: i } INTO test
</code></p>

<h2>Bulk imports</h2>

<p>For importing larger amounts of documents from files, there is the specialized
<a href="http://docs.arangodb.org/Arangoimp/README.html">arangoimp</a> import tool. It can
load data from JSON and CSV files into ArangoDB. The tool is shipped with
ArangoDB.</p>

<p>ArangoDB also provides a REST API for <a href="http://docs.arangodb.org/HttpBulkImports/README.html">bulk imports</a>
of documents.</p>

<h2>Joins</h2>

<p>A special note about <em>joins</em>: the fact that several NoSQL databases do not
provide join functionality has driven some people to emulate join functionality
on the client-side, in their applications.</p>

<p>This can be a recipe for disaster: client-side join implementation might lead
to horrendous amounts of queries that might need to be sent to the database for
fetching all the records. More than that, if data are queried individually,
the overall result may lack consistency. By the way, the same is true for
fetching referenced or linked documents.</p>

<p>ArangoDB provides join functionality via AQL queries. Additionally, AQL queries
can be used to fetch other documents with the original documents. Note that
ArangoDB has no way of defining references or links between documents, but
still AQL allows combining arbitrary documents in one query.</p>

<p>In almost all cases it make more sense to use an AQL query that performs
joins or reference-fetching server-side and close to the data than having to
deal with that on the application-side of things.</p>

<p>AQL joins are described <a href="http://docs.arangodb.org/AqlExamples/Join.html">here</a>.</p>

<h2>Server-side actions</h2>

<p>With <em>stored procedures</em>, relational databases provide another way for an
application to trigger the execution of a large amount of queries. Stored
procedures are executed server-side, too, so they allow avoiding a lot of
request-response ping pong between the application and the database, at least
for defined tasks. Additionally, stored procedures provide control flow
functionality, which can also be handy when operations depend on each other.</p>

<p>Coming back to ArangoDB: complex data-processing tasks that need to execute
multiple operations or need control flow functionality might benefit if
converted from multiple application-side operations into a single server-side
action.</p>

<p>Server-side actions run inside the ArangoDB server, closer to the data, and
can be much faster than a series of client-side operations.
A server-side action is called with just one HTTP request from the application,
so it may lead to saving lots of request-response cycles and reduction in
network overhead. Apart from that, server-side actions in ArangoDB can employ
transactions and provide the necessary control over isolation and atomicity
when executing a series of operations.</p>

<p>Business logic and control flow functionality can be integrated
easily because server-side actions in ArangoDB are JavaScript functions,
with all of the language&rsquo;s programming features being available.</p>

<p>But there&rsquo;s even more to it: a single server-side operation can be written
to put together its result in a format most convenient for the client
application. This can also lead to better encapsulation, because all an
application needs to know about a server-side action is its API or contract.
Any internals of the action can be hidden from the client application. Overall,
this supports a service-oriented approach.</p>

<p>To learn more about how to write server-side actions, please have a look
at ArangoDB&rsquo;s <a href="http://docs.arangodb.org/Foxx/README.html">Foxx</a>. It is all
about making server-side actions available via REST APIs.</p>
]]></content>
  </entry>
  
</feed>
