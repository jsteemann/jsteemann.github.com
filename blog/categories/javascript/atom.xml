<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2016-06-22T18:19:35+02:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Handling Binary Data in Foxx 3.0]]></title>
    <link href="http://jsteemann.github.io/blog/2016/06/22/handling-binary-data-in-foxx-3-0/"/>
    <updated>2016-06-22T17:57:30+02:00</updated>
    <id>http://jsteemann.github.io/blog/2016/06/22/handling-binary-data-in-foxx-3-0</id>
    <content type="html"><![CDATA[<p><em>Note: this post is about the ArangoDB 3.x series</em></p>

<p>A while ago I wrote a <a href="/blog/2014/10/15/handling-binary-data-in-foxx/">blog post</a>
about handling binary data in Foxx applications. That blog post provided a solution
for retrieving and serving non-UTF-8 data from a Foxx application. It was written
for the 2.x series of ArangoDB.</p>

<p>With the release of ArangoDB 3.0 that solution needs some adaption, and this
blog post provides the source code for the 3.0 version of the Foxx application.</p>

<!-- more -->


<p>The <code>rawBodyBuffer()</code> function of the <code>request</code> object is gone in 3.0, and to
retrieve the body as a blob we now need to use <code>internal.rawRequestBody()</code>.
And as there are no controllers and applicationContexts in Foxx 3.0 anymore,
the original route code needs to be changed from</p>

<p>```js 2.8 Foxx action that can handle binary input
controller.post(&lsquo;/receive-binary&rsquo;, function (req, res) {
  // fetch request body into the buffer
  var body = req.rawBodyBuffer();
  // create an absolute filename, local to the Foxx application directory
  var filename = applicationContext.foxxFilename(&ldquo;body&rdquo;);</p>

<p>  require(&ldquo;fs&rdquo;).write(filename, body);
});
```</p>

<p>to the following code:</p>

<p>```js 3.0 Foxx action that can handle binary input
router.post(&lsquo;/receive-binary&rsquo;, function (req, res) {
  // fetch request body into the buffer
  var body = require(&lsquo;internal&rsquo;).rawRequestBody(req._raw);
  // create an absolute filename, local to the Foxx application directory
  var filename = module.context.filename(&ldquo;body&rdquo;);</p>

<p>  require(&ldquo;fs&rdquo;).write(filename, body);
});
```</p>

<p>To serve binary data from a Foxx action, the original route code needs to
be changed from</p>

<p><code>js 2.8 Foxx action that returns contents of a file
controller.get('/provide-binary-file', function (req, res) {
  // create an absolute filename, local to the Foxx application directory
  var filename = applicationContext.foxxFilename("body");
  // send the contents, this will also set mime type "application/octet-stream"
  res.sendFile(filename);
});
</code></p>

<p><code>js 3.0 Foxx action that returns contents of a file
router.get('/provide-binary-file', function (req, res) {
  // create an absolute filename, local to the Foxx application directory
  var filename = module.context.fileName("body");
  // send the contents, this will also set mime type "application/octet-stream"
  res.sendFile(filename);
});
</code></p>

<p>The adjusted Foxx application can be downloaded <a href="/downloads/code/filelist-30.zip">here</a>
with full source code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 Features in ArangoDB 2.7]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/14/es6-features-in-arangodb-27/"/>
    <updated>2015-07-14T20:33:55+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/14/es6-features-in-arangodb-27</id>
    <content type="html"><![CDATA[<p>ArangoDB 2.6 uses V8 engine version 3.31.74.1 for running its own and all user-defined
JavaScript code. In ArangoDB 2.7 (currently in development), we have upgraded V8 to
version 4.3.61.</p>

<p>The new V8 version in ArangoDB 2.7 provides several additional ES6 features that can
be used to improve JavaScript usability and code quality. This blog post showcases <em>strong
mode</em> and <em>rest parameters</em>, and also shows how to activate <em>TurboFan</em>, V8&rsquo;s new JIT compiler
for JavaScript.</p>

<p>ArangoDB 2.7 is in development right now, but it can be tried today by
<a href="/blog/2014/10/16/how-to-compile-arangodb-from-source/">compiling it from source</a>.</p>

<!-- more -->


<h2>JavaScript strong mode</h2>

<p>V8 v4 comes with an optional and experimental <em>strong mode</em>. This mode provides only a
subset of JavaScript, with the idea of intentionally deactivating some of
<a href="http://archive.oreilly.com/pub/a/javascript/excerpts/javascript-good-parts/bad-parts.html">JavaScript&rsquo;s bad parts</a>.
It is based on <em>strict mode</em>, but goes further.</p>

<p>Committing to <em>strong mode</em> may not only provide better and stronger semantics, but may
also enable more optimization opportunities for the JavaScript compiler. For example, the
strong mode disables JavaScript&rsquo;s <em>with</em> statement and <code>delete</code>! Additionally, <code>var</code> cannot
be used anymore but is deprecated in favor of <code>let</code> and <code>const</code>.</p>

<p>The proposal for the strong mode can be found
<a href="https://docs.google.com/document/d/1Qk0qC4s_XNCLemj42FqfsRLp49nDQMZ1y7fwf5YjaI4/view">here</a>,
and the V8 team also has a <a href="https://developers.google.com/v8/experiments">page about it</a>.</p>

<p>Strong mode must be turned on explicitly. This can be done by adding the <code>--strong-mode=true</code>
v8 option when starting <em>arangod</em> or <em>arangosh</em>:</p>

<p><code>bash enabling strong mode
arangosh  --javascript.v8-options="--strong_mode=true"
</code></p>

<p>Note that I am using <em>arangosh</em> above, but the same would work for <em>arangod</em>, too, so the feature
can be used for Foxx routes as well.</p>

<h2>Rest parameters</h2>

<p>How to pass a variable number of arguments to a function?</p>

<p>C and C++ programmers have been using and abusing the ellipsis (<code>...</code>) and <code>__VA_ARGS__</code> features
of the C preprocessor for a long time. Then came the macros of <code>stdarg.h</code> / <code>cstdarg</code>,
until C++11 really improved the situation with <code>std::initializer_list</code> and variadic templates.</p>

<p>In JavaScript, one can use the <code>arguments</code> object:
```js
function logSimple () {
  for (value of arguments) {</p>

<pre><code>console.log(value);
</code></pre>

<p>  }
}</p>

<p>logSimple(&ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;);
```</p>

<p>This does the job, and the above will print something like:
<code>plain
2015-07-14T19:01:51Z [5245] INFO foo
2015-07-14T19:01:51Z [5245] INFO bar
2015-07-14T19:01:51Z [5245] INFO baz
</code></p>

<p>This is fine as long as all arguments shall be treated the same way. But what if some
arguments have a designated meaning and should be treated specially?</p>

<p>The solution is to use <em>ES6 rest parameters</em>. The last parameter in an argument list can be
prefixed with <code>...</code> to capture any number of function parameters:</p>

<p>```js
function logWithContext (context, &hellip;values) {
  for (value of values) {</p>

<pre><code>console.log('[' + context + '] ' + value);
</code></pre>

<p>  }
}</p>

<p>logWithContext(&ldquo;es6&rdquo;, &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;);
```</p>

<p>As can be seen, the <code>logWithContext</code> function specially handles its <code>context</code> argument, while
we can still pass any number of further parameters into it. Here&rsquo;s what the above will print:</p>

<p><code>plain
2015-07-14T19:07:27Z [5245] INFO [es6]: foo
2015-07-14T19:07:27Z [5245] INFO [es6]: bar
2015-07-14T19:07:27Z [5245] INFO [es6]: baz
</code></p>

<p>Note that rest parameters cannot be used with the default configuration and must be turned on
explicitly in <em>arangosh</em> or <em>arangod</em>.</p>

<p>The startup option to turn them on is:</p>

<p><code>bash enabling rest parameters
arangosh --javascript.v8-options="--harmony_rest_parameters=true"
</code></p>

<h2>TurboFan</h2>

<p>The new V8 version comes with <em>TurboFan</em>, a new JIT compiler for JavaScript.
According to <a href="http://blog.chromium.org/2015/07/revving-up-javascript-performance-with.html">this post</a>
it is already used in Chrome for compiling certain types of JavaScript code.</p>

<p>As fas as I can see, it is turned off by default in our version of V8, and the compiler
also seems to be rather experimental. To get an idea of what it can already do and where
its limits are, it can already be tried in ArangoDB 2.7.</p>

<p>By default, it seems to be turned off. Using the following startup option, it can be turned on for
JavaScript functions with a certain name pattern (i.e. all function names starting with <em>testTurboFan</em>):</p>

<p><code>bash starting ArangoShell with TurboFan enabled
arangosh --javascript.v8-options="--turbo-filter=testTurboFan*"`
</code></p>

<p>Without turning on V8 tracing, one will not be able to tell which compiler is used to compile a
specific function. To turn it on and actually confirm V8 is using TurboFan, use these options:</p>

<p><code>bash starting ArangoShell with TurboFan and debug output
arangosh --javascript.v8-options="--always-opt --trace_opt --turbo-filter=testTurboFan*"
</code></p>

<p>This will be very verbose, but it is good to tell which internal compiler is used to compile a given
JavaScript function.</p>

<p>For example, after starting the ArangoShell with the above options, run the following test code
to see that V8 uses TurboFan for compiling the first two functions (which match the name pattern),
and Crankshaft for the third (which does not match the name pattern):</p>

<p>```js test code for invoking the TurboFan compiler
function testTurboFan1 () {
  console.log(&ldquo;turbo-fan 1&rdquo;);
}
testTurboFan1();</p>

<p>function testTurboFan2 () {
  console.log(&ldquo;turbo-fan 2&rdquo;);
}
testTurboFan2();</p>

<p>function testSomethingElse () {
  console.log(&ldquo;something else&rdquo;);
}
testSomethingElse();
```</p>

<p>Here&rsquo;s the confirmation that TurboFan is used:</p>

<p><code>plain debug output
...
[compiling method 0x31ca8804e351 &lt;JS Function testTurboFan1 (SharedFunctionInfo 0x31ca8804e171)&gt; using TurboFan]
...
[compiling method 0x31ca8804e7f9 &lt;JS Function testTurboFan2 (SharedFunctionInfo 0x31ca8804e619)&gt; using TurboFan]
...
[compiling method 0x31ca8804ec71 &lt;JS Function testSomethingElse (SharedFunctionInfo 0x31ca8804ea91)&gt; using Crankshaft]
...
</code></p>

<p>Have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Speeding Up Array/object Literal Access]]></title>
    <link href="http://jsteemann.github.io/blog/2015/06/15/speeding-up-array-slash-object-literal-access/"/>
    <updated>2015-06-15T15:56:27+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/06/15/speeding-up-array-slash-object-literal-access</id>
    <content type="html"><![CDATA[<p>Last week some further optimization slipped into 2.6. The optimization can
provide significant speedups in AQL queries using huge array/object bind parameters
and passing them into V8-based functions.</p>

<!-- more -->


<p>It started with an ArangoDB user reporting a specific query to run unexpectedly slow.
The part of the query that caused the problem was simple and looked like this:</p>

<p><code>plain problematic query
FOR doc IN collection
  FILTER doc.attribute == @value
  RETURN TRANSLATE(doc.from, translations, 0)
</code></p>

<p>In the original query, <code>translations</code> was a big, constant object literal. Think of
something like the following, but with a lot more values:</p>

<p><code>json example translations value
{
  "p1" : 1,
  "p2" : 2,
  "p3" : 40,
  "p4" : 9,
  "p5" : 12
}
</code></p>

<p>The translations were used for replacing an attribute value in existing documents
with a lookup table computed outside the AQL query.</p>

<p>The number of values in the <code>translations</code> object was varying from query to query,
with no upper bound on the number of values. It was possible that the query was
running with 50,000 lookup values in the <code>translations</code> object.</p>

<p>When trying to reproduce the problem, we expected that the query would get at worst
<em>linearly</em> slower with an increasing number of lookup values. But in reality, the
following <em>non-linear</em> execution times were observed when increasing the number of
lookup values:</p>

<p>```plain execution times for varying input sizes, without optimization</p>

<h1>of values |  execution time</h1>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<pre><code>      1 |        0.6111 s
      2 |        0.6078 s  
      4 |        0.6021 s
      8 |        0.6160 s
     16 |        0.6925 s
     32 |        0.7107 s
     64 |        0.7677 s
    128 |        0.8576 s
    256 |        1.0544 s
    512 |        1.4579 s
   1024 |        8.8303 s
   2048 |       17.3674 s
   4096 |       35.3109 s
   8192 |       74.9161 s
  16384 |      145.0837 s
  32768 |      361.9870 s
  65536 |      880.4995 s
</code></pre>

<p>```</p>

<p>(note: all values stated above are wall-clock times for running the query with a
FILTER condition matching 50,000 documents &ndash; i.e. the <code>TRANSLATE()</code> expression was
executed 50,000 times per query)</p>

<p>With small objects passed in <code>translate</code>, the execution times only increased slowly
even when object sizes were doubled. The <code>TRANSLATE()</code> expression&rsquo;s share of the
overall query execution time was still low for small objects, even when doubling
their sizes. However, it got pretty bad for objects with 1,024 members already, and
from that point on, execution times more than doubled if object sizes got doubled.</p>

<p>The <code>TRANSLATE()</code> function itself has O(1) complexity, so we could rule it out as
the problem cause. However, <code>TRANSLATE()</code> is V8-based, and it turned out that there
was a problem when the number of values in the <code>translations</code> object increased from
1022 to 1023. At that particular threshold, execution time quadrupled.</p>

<p>At 1023 object members, V8 seems to change the internal object format, which probably
requires rearranging the object data internally. V8 has several <em>internal</em> types for
representing JavaScript objects, and converting between them is not free.</p>

<p>The obvious optimization opportunity for this case was to create the <code>translations</code>
object value just once as a V8 object, and reuse the same object when calling the
<code>TRANSLATE()</code> function repeatedly. This avoids repeated creation and destruction of
the V8 objects used in function calls, and as a side effect may also lead to less garbage
values being accumulated when functions are called repeatedly.</p>

<p>The optimization is possible here because the <code>translations</code> object is an object literal
and thus constant. It will also work for array literals and bind parameters (which
are also treated as literals once their values are known).</p>

<p>Here are the execution time for running the <code>TRANSLATE()</code> on 50,000 documents with the
modification:</p>

<p>```plain execution times, with optimization</p>

<h1>of values |  execution time</h1>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<pre><code>      1 |        0.6251 s
      2 |        0.6302 s  
      4 |        0.6138 s
      8 |        0.6141 s
     16 |        0.6685 s
     32 |        0.6232 s
     64 |        0.6204 s
    128 |        0.6326 s
    256 |        0.6460 s
    512 |        0.6275 s
   1024 |        0.6639 s
   2048 |        0.6345 s
   4096 |        0.6554 s
   8192 |        0.6789 s
  16384 |        0.7569 s
  32768 |        0.7636 s
  65536 |        1.0173 s
</code></pre>

<p>```</p>

<p>Looks like this is going to scale way better.</p>

<p>The optimization is disabled for big array/objects which are non-constant (e.g. a variable
or the result of an expression), or for parameters passed into user-defined AQL functions.
Enabling it for user-defined AQL functions is not safe because in theory these might
modify their arguments (and function arguments are passed by reference &ndash; passing them
by value would also defeat the purpose of the optimization).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More ES6 Features]]></title>
    <link href="http://jsteemann.github.io/blog/2015/02/26/more-es6-features/"/>
    <updated>2015-02-26T12:00:46+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/02/26/more-es6-features</id>
    <content type="html"><![CDATA[<p>ArangoDB 2.5 comes with an upgraded version of V8, Google&rsquo;s open source JavaScript engine.</p>

<p>The built-in version of V8 has been upgraded from 3.29.54 to 3.31.74.1.</p>

<p>In addition to several already usable ES6 features (detailed in
<a href="https://jsteemann.github.io/blog/2014/12/19/using-es6-features-in-arangodb/">this blog</a>,
the following ES6 features are activated in ArangoDB 2.5 by default:</p>

<ul>
<li>iterators and generators</li>
<li>template strings</li>
<li>enhanced object literals</li>
<li>enhanced numeric literals</li>
<li>block scoping with <code>let</code> and constant variables using <code>const</code></li>
<li>additional String methods (such as <code>startsWith</code>, <code>repeat</code> etc.)</li>
</ul>


<p>The above features are available in ArangoDB 2.5, and can now be used for scripting purposes
in the ArangoShell and in server-side Foxx actions inside the database.</p>

<p>This blog post briefly explains the features provides some quick examples for using them.</p>

<!-- more -->


<h2>Iterators and generators</h2>

<p>Iterator and generator support was optional in 2.4, but is turned on by default since 2.5.</p>

<p>For everyone who is not familiar with generators in JavaScript, here&rsquo;s how they work:</p>

<p>Generators are special functions tagged with an asterisk (<code>*</code>). Values are returned to the
caller using the <code>yield</code> keyword:</p>

<p><code>js a simple generator that generates two values                                                            
function* generate () {                                                                                       
  yield 23;                                                                                                   
  yield 42;                                                                                                   
}                                                                                                            
</code></p>

<p>Calling the function with initialize/reset the generator. Calling the <code>next()</code> method on
the generator&rsquo;s initial call return value produces the next sequence element. The element
is returned in a <code>value</code> attribute. The <code>done</code> attribute indicates whether the sequence
has come to an end:</p>

<p><code>js invoking the generator
var generator = generate();                                                                                   
console.log(generator.next());  /* { "value" : 23, "done" : false } */                                        
console.log(generator.next());  /* { "value" : 42, "done" : false } */                                        
console.log(generator.next());  /* { "value" : undefined, "done" : true } */                                  
</code></p>

<p>Sequences produced by generators can also be consumed via a <code>for...of</code> loop:</p>

<p>```js consuming all values from a generator function
var generator = generate();</p>

<p>for (var value of generator) {
  console.log(value);
}
```</p>

<p>In general, every object that is iteratable can be consumed using the <code>of</code> operator.
Some built-in objects provide pre-defined iterators (e.g. <code>Map.keys()</code> or <code>Map.values()</code>),
but you can also create iterators for your own objects:</p>

<p>```js creating an iterator for an object
function Sentence (text) {
  this.text = text;
}</p>

<p>Sentence.prototype[Symbol.iterator] = function*() {
  var regex = /\S+/g;
  var text = this.text;
  var match;
  while (match = regex.exec(text)) {</p>

<pre><code>yield match[0]; 
</code></pre>

<p>  }
};</p>

<p>var sentence = new Sentence(&ldquo;The quick brown fox jumped over the lazy dog&rdquo;);
for (var word of sentence) {
  console.log(word);
}
```</p>

<h2>Template strings</h2>

<p>I know there are query string generators and such, but for the sake of the example, let&rsquo;s assume you
wanted to write a query string in JavaScript. You might end up with something like this:</p>

<p><code>js multi-line query string
var query =
  'FOR doc IN users\n' +
  '  FILTER doc.name == @name\n' +
  '  RETURN doc\n';
</code></p>

<p>This is hardly legible, and it is also very prone to errors.</p>

<p>ES6 template strings provide a way to define multi-line string literals in a much easier and simpler way.
Here&rsquo;s how to do it (note the backticks instead of the regular string quotes):</p>

<p><code>js using a multi-line template string
var query = `
FOR doc IN users
  FILTER doc.name == @name
  RETURN doc
`;
</code></p>

<p>Template strings also support value substitution, so you could even write something like this, too:
```js value substitution in template strings
var name = &ldquo;AQL injection attempt \&rdquo; OR true OR \&ldquo;&rdquo;;</p>

<p>var query = <code>
FOR doc IN users
  FILTER doc.name == ${JSON.stringify(name)}
  RETURN doc
</code>;
```</p>

<p>Note that while value substitution in template strings in convenient, you still have to be careful with
user-generated values. Otherwise you might be subject to value injection attacks, as you would be with
every other form of improper user value handling.</p>

<h2>Enhanced object literals</h2>

<p>Save some time when definining objects:</p>

<p>```js using enhanced object literals
var name = &ldquo;foobar&rdquo;;</p>

<p>myObject = {
  type : &ldquo;myType&rdquo;,   /<em> always worked </em>/
  name,              /<em> same as &ldquo;name&rdquo; : name </em>/
  save () {          /<em> same as &ldquo;save&rdquo; : function () &hellip; </em>/</p>

<pre><code>console.log("save called!"); 
</code></pre>

<p>  }
};</p>

<p>{
  &ldquo;type&rdquo; : &ldquo;myType&rdquo;,
  &ldquo;name&rdquo; : &ldquo;foobar&rdquo;,
  &ldquo;save&rdquo; : [Function &ldquo;console.log("save called!&rdquo;);&ldquo; &hellip;]
}
```</p>

<p>As can be seen above, enhanced object literal declarations can save some typing and reduce redundancies
in the code. Unfortunately we still cannot use object key names generated from expressions:</p>

<p><code>js does not work yet
myObject = {
  [ "foo" + bar" ] : "foobar"
};
</code></p>

<h2>Enhanced numeric literals</h2>

<p>Numeric values can now be specified in binary or octal if required:</p>

<p><code>js numeric literals                                                                                        
var life = 0b101010;          /* binary, 42 in decimal */                                                     
var filePermissions = 0o777;  /* octal, 511 in decimal */                                                     
</code></p>

<h2>Block scoping</h2>

<p>As a mostly C++ programmer, I am always puzzled about the scoping of JavaScript variables.
In the following example, variable <code>x</code> does not only live inside the curly brackets block in which
it was declared, but also afterwards:</p>

<p>```
function work () {
  {</p>

<pre><code>var x = 1;
</code></pre>

<p>  }
  return x;
}
```</p>

<p>The reason is that the curly brackets around <code>var x = 1;</code> are not a scope at all in traditional
JavaScript. This sucks, because variables can linger around in programs longer than necessary,
leading to unwanted side-effects.</p>

<p>With block-level scopes, this can be fixed. To use it, introduce variables not with the <code>var</code>
keyword, but with <code>let</code>. <code>let</code> only works in strict mode, so make sure your function or module
uses it.</p>

<p>Now, with block-level scoping, the above snippet looks like this:
```
function work () {
  &ldquo;use strict&rdquo;;
  {</p>

<pre><code>let x = 1; 
</code></pre>

<p>  }
  return x;
};
```</p>

<p>And it will actually produce an error when trying to access variable <code>x</code> in the <code>return</code> statement.
The reason is that the life of <code>x</code> was over as soon as its scope was left. The scope of variable <code>x</code> is
now only the one with the <code>let</code> declaration inside the curly brackets.</p>

<p>Someone else said &ldquo;<em>let is the new var</em>&rdquo;, and I think there&rsquo;s not much to add.</p>

<p>Additionally, the <code>const</code> keyword can be used to define a read-only variables. Trying to re-define a
constant will produce an error in strict mode (the desired behavior), and do nothing in non-strict mode.
Another reason to use the strict mode.</p>

<h2>Additional String methods</h2>

<p><code>String</code> objects now provide extra built-in methods:</p>

<ul>
<li><code>string.startsWith(what)</code></li>
<li><code>string.endsWith(what)</code></li>
<li><code>string.includes(what)</code></li>
<li><code>string.repeat(count)</code></li>
<li><code>string.normalize(method)</code></li>
<li><code>string.codePointAt(position)</code></li>
</ul>


<p>There is also an extra &ldquo;static&rdquo; method:</p>

<ul>
<li><code>String.fromCodePoint(codePoint)</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Dynamic Attribute Names in AQL]]></title>
    <link href="http://jsteemann.github.io/blog/2015/02/03/using-dynamic-attribute-names-in-aql/"/>
    <updated>2015-02-03T00:12:39+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/02/03/using-dynamic-attribute-names-in-aql</id>
    <content type="html"><![CDATA[<p>On our mailing list, there is quite often the question whether attribute names in objects
returned from AQL queries can be made dynamic.</p>

<p>Here&rsquo;s a (non-working) example query for this:</p>

<p><code>plain example query that does not work
FOR doc IN collection
  RETURN { doc.type : doc.value }
</code></p>

<p>The intention in the above query obviously is to use the dynamic value from <code>doc.type</code> as
an attribute name in the result object and not to have an attribute named <code>"doc.type"</code>. This
feature is probably in the top 20 of the most-often wished features.</p>

<!-- more -->


<p>However, the above query won&rsquo;t even parse. The AQL grammar only allows string values
left of the colon in an object definition. Non-quoted strings are allowed there too, and are
implicitly turned into quoted strings. It works similar to how object literals are defined
in JavaScript:</p>

<p><code>plain using unquoted and quoted string attribute names
RETURN {
  foo : "bar",
  "baz" : "qux"
}
</code></p>

<p>Why not allow arbitrary expression left of the colon? The reason is simple: this would cause
ambiguity and probably have side-effects. For an example, have a look at the following query:</p>

<p><code>plain which attribute name to use here?
FOR doc IN collection
  LET type = doc.type;
  RETURN { type : doc.value }
</code></p>

<p>If the <code>type</code> attribute name inside the object definition is interpreted as a string literal
as it currently is an AQL (and always was), then the resulting attribute name is just <code>"type"</code>.</p>

<p>If the <code>type</code> attribute name would now be intepreted as an expression, it would get the value
that was assigned to the variable <code>type</code> by the <code>LET</code> statement. Removing the <code>LET</code> from the
query would change the attribute name in the result back to the string literal <code>"type"</code>.</p>

<p>The ambiguity could be solved by telling the parser what to do in such cases. While technically
this could be working, I think it may have too many unintended side-effects. I already mentioned
that introducing a <code>LET</code> statement into the query would change the attribute name in the result.
The same could also happen if a collection named <code>type</code> was added to the query. And it would
break compatibility with existing queries.</p>

<p>JavaScript has the same problem, and it wasn&rsquo;t solved portably yet. However, there is a proposal
for ES6 that suggests enclosing attribute name expressions in <code>[</code> and <code>]</code>.</p>

<p>To me, this looks like a good solution for the problem. It&rsquo;s two bytes more when keying in
queries, but the syntax is easy and explicit. There are no ambiguities.</p>

<p>I prototyped this solution for AQL, so I could write:</p>

<p>```plain query using dynamic attribute names
FOR i IN 1..5
  RETURN {</p>

<pre><code>[ CONCAT('test', i) ] : i, 
[ SUBSTITUTE(CONCAT('i is ', (i &lt;= 3 ? 'small' : 'not small')), { ' ' :  '_' } ) ] : i 
</code></pre>

<p>  }</p>

<p>[
  {</p>

<pre><code>"test1" : 1, 
"i_is_small" : 1 
</code></pre>

<p>  },
  {</p>

<pre><code>"test2" : 2, 
"i_is_small" : 2 
</code></pre>

<p>  },
  {</p>

<pre><code>"test3" : 3, 
"i_is_small" : 3 
</code></pre>

<p>  },
  {</p>

<pre><code>"test4" : 4, 
"i_is_not_small" : 4 
</code></pre>

<p>  },
  {</p>

<pre><code>"test5" : 5, 
"i_is_not_small" : 5 
</code></pre>

<p>  }
]
```</p>

<p>I ran a few queries with this, and they seemed to work. <del>However, I haven&rsquo;t
committed the feature yet. There might still be cases in which it doesn&rsquo;t work. Tests
for the feature are also still missing. I hope I can finalize the implementation soon
so it becomes available in some release.</del></p>

<p><strong>UPDATE</strong>: tests have been added, and the feature has been committed in devel. It is
included in ArangoDB since version 2.5.</p>

<p>Everyone is welcome to try it out already!</p>
]]></content>
  </entry>
  
</feed>
