<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Development | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/development/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2016-06-09T22:14:13+02:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Compiling an Optimized Version of ArangoDB]]></title>
    <link href="http://jsteemann.github.io/blog/2016/06/09/compiling-an-optimized-version-of-arangodb/"/>
    <updated>2016-06-09T20:31:31+02:00</updated>
    <id>http://jsteemann.github.io/blog/2016/06/09/compiling-an-optimized-version-of-arangodb</id>
    <content type="html"><![CDATA[<p>Why should you care about compiling ArangoDB on your own when there are
official release packages that are ready to use?</p>

<!--more -->


<p>There are three main reasons for compiling on your own:</p>

<ul>
<li><p>as a developer you want to <em>make changes to the ArangoDB C++ source code</em>.
Then your only option obviously is to compile on your own. Please consult
the <a href="/blog/2016/06/09/compiling-a-debug-version-of-arangodb/">compiling a debug version of ArangoDB</a>
page for more information.</p></li>
<li><p>you are trying to <em>get meaningful stack traces from core dumps</em> produced
by ArangoDB and need an ArangoDB binary that comes with enough debug
information (debug symbols, probably also assertions turned on). In this
case, please also consult the <a href="/blog/2016/06/09/compiling-a-debug-version-of-arangodb/">compiling a debug version of ArangoDB</a>
blog post for how to get this done.</p></li>
<li><p>you want to use an ArangoDB binary that is <em>optimized for your specific
target architecture</em>.</p></li>
</ul>


<p>The latter reason is relevant because the official release packages that
are provided by ArangoDB cannot make too many assumptions about the environment
in which they will be used. In the general release packages there is not so
much room for platform-specific optimizations as there would be if you are
compiling just for the local machine.</p>

<p>For example, all relevant CPU offer <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a>
instructions that a compiler can exploit when generating code. But different
generations of CPUs offer different levels of SIMD instructions. Not every CPU
in use today provides SSE4, not to talk about AVX.</p>

<p>To make our release packages compatible with most environments, we have had
to make some conservative assumptions about the CPU abilities, which effectively
disables many optimizations that would have been possible when creating a
build that only needs to run on a specific architecture.</p>

<p>To fully exploit the capabilities of a specific target environment, it&rsquo;s required
to build executables for that specific architecture. Most compilers offer an option
<code>-march</code> for that. You normally want to set this to <code>native</code> when compiling an
optimized version. There are also lots of compiler options for enabling or disabling
specific CPU features such as <code>-msse</code>, <code>-msse2</code>, <code>-msse3</code>, <code>-mssse3</code>,
<code>-msse4.1</code>, <code>-msse4.2</code>, <code>-msse4</code>, <code>-mavx</code>, <code>-mavx2</code>, to name just a few.</p>

<p>The good news is that there is no need to deal with such compiler-specific optimization
options in order to get an optimized build. The cmake-based ArangoDB 3.0 builds will
automatically test the local environment&rsquo;s capabilities and set the compiler options
based on which CPU abilities were detected.</p>

<p>For example, a mere <code>(cd build &amp;&amp; cmake -DCMAKE_BUILD_TYPE=Release ..)</code> will run the
CPU ability detection and configure the build to use the features supported by the
local architecture:</p>

<p><code>bash configuring a release build
(mkdir -p build; cd build &amp;&amp; cmake -DCMAKE_BUILD_TYPE=Release ..)
</code></p>

<p>For example, on my laptop this prints:
<code>plain cmake output
-- The CXX compiler identification is GNU 5.3.1
-- The C compiler identification is GNU 5.3.1
...
-- target changed from "" to "auto"
-- Detected CPU: haswell
-- Performing Test check_cxx_compiler_flag__march_core_avx2
-- Performing Test check_cxx_compiler_flag__march_core_avx2 - Success
-- Performing Test check_cxx_compiler_flag__msse2
-- Performing Test check_cxx_compiler_flag__msse2 - Success
-- Performing Test check_cxx_compiler_flag__msse3
-- Performing Test check_cxx_compiler_flag__msse3 - Success
-- Looking for pmmintrin.h
-- Looking for pmmintrin.h - found
-- Performing Test check_cxx_compiler_flag__mssse3
-- Performing Test check_cxx_compiler_flag__mssse3 - Success
-- Looking for tmmintrin.h
-- Looking for tmmintrin.h - found
-- Performing Test check_cxx_compiler_flag__msse4_1
-- Performing Test check_cxx_compiler_flag__msse4_1 - Success
-- Looking for smmintrin.h
-- Looking for smmintrin.h - found
-- Performing Test check_cxx_compiler_flag__msse4_2
-- Performing Test check_cxx_compiler_flag__msse4_2 - Success
-- Performing Test check_cxx_compiler_flag__mavx
-- Performing Test check_cxx_compiler_flag__mavx - Success
-- Looking for immintrin.h
-- Looking for immintrin.h - found
-- Performing Test check_cxx_compiler_flag__msse2avx
-- Performing Test check_cxx_compiler_flag__msse2avx - Success
-- Performing Test check_cxx_compiler_flag__mavx2
-- Performing Test check_cxx_compiler_flag__mavx2 - Success
-- Performing Test check_cxx_compiler_flag__mno_sse4a
-- Performing Test check_cxx_compiler_flag__mno_sse4a - Success
-- Performing Test check_cxx_compiler_flag__mno_xop
-- Performing Test check_cxx_compiler_flag__mno_xop - Success
-- Performing Test check_cxx_compiler_flag__mno_fma4
-- Performing Test check_cxx_compiler_flag__mno_fma4 - Success
...
</code>
The detected options will end up in the CMakeCache.txt file in the build
directory. The Makefile generated by cmake will automatically make use of
these options when invoking the C++ compiler.</p>

<p>The compiler options are not shown by default, but they can be made visible
by compiling with the option <code>VERBOSE=1</code>, e.g.</p>

<p><code>bash configuring and compiling a build
(mkdir -p build; cd build &amp;&amp; cmake -DCMAKE_BUILD_TYPE=Release ..)
(cd build &amp;&amp; make -j4 VERBOSE=1)
</code></p>

<p>Note that this will be <em>very verbose</em>, so you only want to set the <code>VERBOSE=1</code>
option to check that the compiler options were picked correctly.</p>

<p>On my local laptop, the architecture-specific compiler options that were automatically
detected and used were</p>

<p><code>bash compiler architecture options used
-march=core-avx2 -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -mavx -msse2avx -mavx2 -mno-sse4a -mno-xop -mno-fma4
</code></p>

<p>The build has detected <code>core-avx2</code>, which in my case is good &ndash; and a lot more
specific than the official packages which for example cannot assume the presence
of either SSE4 or AVX instructions.</p>

<p>And now that we can rely on the presence of specific CPU instructions, some code
parts such as JSON parsing can make use of SSE4.2 instructions, or the compiler
can use some optimized SIMD variants for operations such as memcpy, strlen etc.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using the Address Sanitizer (ASAN) in ArangoDB Development]]></title>
    <link href="http://jsteemann.github.io/blog/2016/06/09/using-the-address-sanitizer-asan-in-arangodb-development/"/>
    <updated>2016-06-09T20:07:29+02:00</updated>
    <id>http://jsteemann.github.io/blog/2016/06/09/using-the-address-sanitizer-asan-in-arangodb-development</id>
    <content type="html"><![CDATA[<p>Once you have set up a <a href="/blog/2016/06/09/compiling-a-debug-version-of-arangodb/">debug version of ArangoDB</a>,
it is quite helpful to also enable the <a href="https://en.wikipedia.org/wiki/AddressSanitizer">Address Sanitizer</a>
and its companion tools.</p>

<p>These sanitizers provide runtime instrumentation for executables and check
for common C++ programming errors such as buffer overflows, use-after-free
bugs and memory leaks. The sanitizers supported natively by recent versions
of g++ and clang++.</p>

<p>The general runtime overhead of the sanitizers is neglectable compared to
other instrumentation tools such as Valgrind, so it can well be used in the
day-to-day development process.</p>

<!-- more -->


<h2>Configuring the build to use ASAN</h2>

<p>To build with ASAN (Address Sanitizer) and UBSAN (Undefined Behavior Sanitizer),
the following environment variables need to be set when invoking cmake:</p>

<p><code>bash environment variables for ASAN and UBSAN
CXXFLAGS="-fsanitize=address -fsanitize=undefined -fno-sanitize=alignment -fno-sanitize=vptr"
</code></p>

<p>The full command to configure a debug build with ASAN and UBSAN support is:</p>

<p><code>bash configuring the build to use the sanitizers
(cd build &amp;&amp; CXXFLAGS="-fsanitize=address -fsanitize=undefined -fno-sanitize=alignment -fno-sanitize=vptr cmake -DCMAKE_BUILD_TYPE=Debug -DUSE_MAINTAINER_MODE=On ..)
</code></p>

<p>This will configure the build so it will pass the sanitizer options to the C++
compiler. Note that you&rsquo;ll need a recent version of g++ or clang++ for this
to work.</p>

<p>After that, build arangod normally. The binaries produced will be instrumented
by the sanitizers, allowing many nasty memory errors to be detected very early.</p>

<h2>Checking if an arangod binary is using ASAN</h2>

<p>Whether or not an ArangoDB binary is instrumented can be found out at any
time by calling the binary with the <code>--version</code> option. This will print some
version information for ArangoDB itself and the other required libraries,
and it will also print in the line starting with <code>asan</code> whether the binary
was compiled with ASAN support or not:</p>

<p>```bash checking the ASAN support of an arangod binary</p>

<blockquote><p>build/bin/arangod &mdash;version</p></blockquote>

<p>3.0.x-devel</p>

<p>architecture: 64bit
asan: true                       # !!!!
asm-crc32: true
boost-version: 1.61.0b1
build-date: 2016-06-09 12:07:07
compiler: gcc
cplusplus: 201103
endianness: little
fd-client-event-handler: poll
fd-setsize: 1024
icu-version: 54.1
jemalloc: false
libev-version: 4.22
maintainer-mode: true
openssl-version: OpenSSL 1.0.2g-fips  1 Mar 2016
rocksdb-version: 4.8.0
server-version: 3.0.x-devel
sizeof int: 4
sizeof void*: 8
sse42: true
tcmalloc: false
v8-version: 5.0.71.39
vpack-version: 0.1.30
zlib-version: 1.2.8
```</p>

<h2>Controlling ASAN runtime behavior</h2>

<p>ASAN behavior can also be controlled at runtime, after the binaries have
been produced, by adjusting the environment variable <code>ASAN_OPTIONS</code>.
The setting I use for this is:</p>

<p><code>bash adjusting ASAN options
ASAN_OPTIONS="handle_ioctl=true:check_initialization_order=true:detect_container_overflow=1:detect_stack_use_after_return=false:detect_odr_violation=1:allow_addr2line=true:strict_init_order=true"
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compiling a Debug Version of ArangoDB]]></title>
    <link href="http://jsteemann.github.io/blog/2016/06/09/compiling-a-debug-version-of-arangodb/"/>
    <updated>2016-06-09T20:07:29+02:00</updated>
    <id>http://jsteemann.github.io/blog/2016/06/09/compiling-a-debug-version-of-arangodb</id>
    <content type="html"><![CDATA[<p>Compiling a debug version of ArangoDB is a must for everyone that
wants to modify the C++ ArangoDB source code and test their changes
locally.</p>

<p>How to do this is different in the 2.8 and 3.0 branches of ArangoDB,
but luckily it&rsquo;s really easy to achieve in both branches.</p>

<!-- more -->


<h2>ArangoDB 2.8</h2>

<p>For the 2.8 branch of ArangoDB, clone the 2.8 version of the ArangoDB
repository first:</p>

<p><code>bash cloning the 2.8 repository
git clone -b 2.8 https://github.com/arangodb/arangodb
cd ArangoDB
</code></p>

<p>And in that directory execute the following commands:</p>

<p><code>bash compiling a debug version of 2.8
make setup
export CFLAGS="-g -Og"
export CXXFLAGS="-g -Og"
./configure --enable-relative --enable-maintainer-mode
make -j4
</code></p>

<p>(note that you&rsquo;ll need a working C++11 compiler and some prerequisites
such as the OpenSSL library, GNU Bison and Flex installed for this to work).</p>

<p>This will compile ArangoDB and all of its dependencies, and finally
make them available in the <code>bin</code> subdirectory of the current directory.
There is no need to install ArangoDB using <code>make install</code>. arangod and
the client tools can be run locally using the following commands:</p>

<p><code>bash running arangod and arangosh
bin/arangod --console mydb # start arangod in console mode
bin/arangosh # starts an ArangoShell
</code></p>

<p>Now, after any modification to the ArangoDB C++ source code you can re-compile
using <code>make</code>. This will only rebuild the things that need to be rebuilt. If the
build is successful, the changes you have made should be visible when restarting
the binaries.</p>

<p>As the <code>-g</code> option used above will have configured a build with debug
symbols, it&rsquo;s also possible to use a debugger such as gdb for stepping
through the executables, attach to the while they are running, or to
obtain stack traces in case any of the executables crashed.</p>

<h2>ArangoDB 3.0</h2>

<p>For the 3.0 branch of ArangoDB, it&rsquo;s required to once clone that version
of the ArangoDB repository into a local directory:</p>

<p><code>bash cloning the 3.0 repository
git clone -b 3.0 https://github.com/arangodb/arangodb
cd ArangoDB
</code></p>

<p>In that directory execute the following commands to configure the build
for debugging:</p>

<p><code>bash configuring a debug version of 3.0
(mkdir -p build; cd build &amp;&amp; cmake -DCMAKE_BUILD_TYPE=Debug -DUSE_MAINTAINER_MODE=On ..)
</code></p>

<p>(again you&rsquo;ll need a working C++11 compiler and some prerequisites
such as the OpenSSL library installed for this to work).</p>

<p>This will configure the build to be a debug build, with debug symbols
but most optimizations disabled. To build ArangoDB, just execute:</p>

<p><code>bash compiling a debug version of 3.0
(cd build &amp;&amp; make -j4)
</code></p>

<p>To execute one of the binaries, run them from the checkout directory
as follows:</p>

<p><code>bash running arangod and arangosh
build/bin/arangod --console mydb # start arangod in console mode
build/bin/arangosh # starts an ArangoShell
</code></p>

<p>After any modification to the ArangoDB C++ source code, build again
using <code>(cd build &amp;&amp; make -j4)</code> to see the changes in effect.
The build is a debug build, meaning you can use a debugger and get
meaningful stack traces for core dumps produced by the binaries.</p>

<p>If you got, then I strongly recommend to also enable the
<a href="https://en.wikipedia.org/wiki/AddressSanitizer">Address Sanitizer</a>
(ASAN) for your debug build. This can greatly help finding common memory usage
errors during development. There is another<br/>
<a href="/blog/2016/06/09/using-the-address-sanitizer-asan-in-arangodb-development/">blog post about using ASAN in ArangoDB development</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fastest String-to-uint64 Conversion Method?]]></title>
    <link href="http://jsteemann.github.io/blog/2016/06/02/fastest-string-to-uint64-conversion-method/"/>
    <updated>2016-06-02T20:15:27+02:00</updated>
    <id>http://jsteemann.github.io/blog/2016/06/02/fastest-string-to-uint64-conversion-method</id>
    <content type="html"><![CDATA[<p>While doing some optimization work for the upcoming ArangoDB 3.0 release,
we had to figure out what was the &ldquo;ideal&rdquo; way of converting a string
representation of a number into a C++ uint64_t (64 bit unsigned integer type).
This kind of operation is performed a lot during the lifetime of an ArangoDB
server process, so it seemed worthwhile making it as fast as possible.</p>

<!-- more -->


<h2>std::stoull and std::strtoull</h2>

<p>The natural solution for this kind of conversion is the standard library&rsquo;s
<a href="http://en.cppreference.com/w/cpp/string/basic_string/stoul">std::stoull</a>
function. On the one hand, that solution is potentially optimized and definitely
robust. It performs validation of the input characters and is also battle-tested
by millions of users.</p>

<p>On the other hand, std::stoull has a few &ldquo;features&rdquo; that some would consider
&ldquo;anti&rdquo;-features, and that sound like they could negatively influence performance:</p>

<ul>
<li>it may behave locale-dependent</li>
<li>it can parse and will let pass negative input values, which is often not desired
for a result of unsigned type</li>
<li>it can perform base conversion</li>
</ul>


<p>In C++11 there is also the alternative
<a href="http://en.cppreference.com/w/cpp/string/byte/strtoul">std::strtoull</a>.
It should behave about the same as std::stoull except in case of error.
std::stoull will throw and std::strtoull will not.</p>

<p>That&rsquo;s what we get from the standard library for long unsigned integer types.</p>

<h2>Alternative implementations (w/o error checking)</h2>

<p>Another alternative is to roll a string to number conversion function ourselves.
If we hard-code it to base 10 and do not care about error checking, a naive
implementation may look like this:</p>

<p>```cpp
inline uint64_t naive(std::string const&amp; value) {
  uint64_t result = 0;
  char const<em> p = value.c_str();
  char const</em> q = p + value.size();
  while (p &lt; q) {</p>

<pre><code>result *= 10;
result += *(p++) - '0';
</code></pre>

<p>  }
  return result;
}
```</p>

<p>Obviously the above will produce wrong results for invalid
input data, but for &ldquo;trusted&rdquo; (known to be valid) input it may
be just fine.</p>

<p>Here&rsquo;s just another implementation for the problem at hand. This one
doesn&rsquo;t perform the times 10 operation, but splits it into two bitshifting
operations:</p>

<p>```cpp
inline uint64_t bitshift(std::string const&amp; value) {
  uint64_t result = 0;</p>

<p>  char const<em> p = value.c_str();
  char const</em> q = p + value.size();
  while (p &lt; q) {</p>

<pre><code>result = (result &lt;&lt; 1) + (result &lt;&lt; 3) + *(p++) - '0';
</code></pre>

<p>  }
  return result;
}
```</p>

<p>Again no error checking is present in the above function, but it
should be ok for trusted inputs.</p>

<p>By manually unrolling the while loop and converting it into a switch
statement, we can also come up with a conversion function that has minimal
branching:</p>

<p>```cpp
inline uint64_t unrolled(std::string const&amp; value) {
  uint64_t result = 0;</p>

<p>  size_t const length = value.size();
  switch (length) {</p>

<pre><code>case 20:    result += (value[length - 20] - '0') * 10000000000000000000ULL;
case 19:    result += (value[length - 19] - '0') * 1000000000000000000ULL;
case 18:    result += (value[length - 18] - '0') * 100000000000000000ULL;
case 17:    result += (value[length - 17] - '0') * 10000000000000000ULL;
case 16:    result += (value[length - 16] - '0') * 1000000000000000ULL;
case 15:    result += (value[length - 15] - '0') * 100000000000000ULL;
case 14:    result += (value[length - 14] - '0') * 10000000000000ULL;
case 13:    result += (value[length - 13] - '0') * 1000000000000ULL;
case 12:    result += (value[length - 12] - '0') * 100000000000ULL;
case 11:    result += (value[length - 11] - '0') * 10000000000ULL;
case 10:    result += (value[length - 10] - '0') * 1000000000ULL;
case  9:    result += (value[length -  9] - '0') * 100000000ULL;
case  8:    result += (value[length -  8] - '0') * 10000000ULL;
case  7:    result += (value[length -  7] - '0') * 1000000ULL;
case  6:    result += (value[length -  6] - '0') * 100000ULL;
case  5:    result += (value[length -  5] - '0') * 10000ULL;
case  4:    result += (value[length -  4] - '0') * 1000ULL;
case  3:    result += (value[length -  3] - '0') * 100ULL;
case  2:    result += (value[length -  2] - '0') * 10ULL;
case  1:    result += (value[length -  1] - '0');
</code></pre>

<p>  }
  return result;
}
```</p>

<h2>Performance testing</h2>

<p>To check out how all these alternatives perform, I put them into a small
<a href="/downloads/code/stoull-test.cpp">test driver program</a>. To compile it with
g++ and run it, I used this command:</p>

<p><code>bash
g++ -Wall -Wextra -march=native -std=c++11 -O3 stdoull-test.cpp &amp;&amp; ./a.out
</code></p>

<p>The test program will convert input strings of different lengths to uint64_t
using the above (and some other) implementations, going up from 10,000 iterations
per string up to 100,000,000. It also prints the wall-clock time spent in each
run. The most interesting output it prints is in the &ldquo;ms&rdquo; column. The &ldquo;result&rdquo;
column can be fully ignored. It&rsquo;s only there so the compiler won&rsquo;t optimize away
the calls to the conversion functions.</p>

<p>The timings from my local laptop (Intel Core i7-4710HQ CPU @ 2.50GHz, Ubuntu 16.04,
g++ 5.3.1 &ndash; your mileage may vary!) for the 100,000,000 conversions are:</p>

<p>```plain execution times for various string-to-uint64 implementations
test &lsquo;std::stoull&rsquo;       string &lsquo;1&rsquo;                           1209 ms
test &lsquo;std::stoull&rsquo;       string &lsquo;99&rsquo;                          1382 ms
test &lsquo;std::stoull&rsquo;       string &lsquo;1234&rsquo;                        1725 ms
test &lsquo;std::stoull&rsquo;       string &lsquo;1234567&rsquo;                     2257 ms
test &lsquo;std::stoull&rsquo;       string &lsquo;1234567891&rsquo;                  2764 ms
test &lsquo;std::stoull&rsquo;       string &lsquo;12345678901234&rsquo;              3899 ms
test &lsquo;std::stoull&rsquo;       string &lsquo;12345678901234678901&rsquo;        7391 ms</p>

<p>test &lsquo;std::strtoull&rsquo;     string &lsquo;1&rsquo;                           1104 ms
test &lsquo;std::strtoull&rsquo;     string &lsquo;99&rsquo;                          1300 ms
test &lsquo;std::strtoull&rsquo;     string &lsquo;1234&rsquo;                        1628 ms
test &lsquo;std::strtoull&rsquo;     string &lsquo;1234567&rsquo;                     2428 ms
test &lsquo;std::strtoull&rsquo;     string &lsquo;1234567891&rsquo;                  2662 ms
test &lsquo;std::strtoull&rsquo;     string &lsquo;12345678901234&rsquo;              3705 ms
test &lsquo;std::strtoull&rsquo;     string &lsquo;12345678901234678901&rsquo;        6631 ms</p>

<p>test &lsquo;naive&rsquo;             string &lsquo;1&rsquo;                            202 ms
test &lsquo;naive&rsquo;             string &lsquo;99&rsquo;                           314 ms
test &lsquo;naive&rsquo;             string &lsquo;1234&rsquo;                         475 ms
test &lsquo;naive&rsquo;             string &lsquo;1234567&rsquo;                      732 ms
test &lsquo;naive&rsquo;             string &lsquo;1234567891&rsquo;                   987 ms
test &lsquo;naive&rsquo;             string &lsquo;12345678901234&rsquo;              1343 ms
test &lsquo;naive&rsquo;             string &lsquo;12345678901234678901&rsquo;        1862 ms</p>

<p>test &lsquo;bitshift&rsquo;          string &lsquo;1&rsquo;                            188 ms
test &lsquo;bitshift&rsquo;          string &lsquo;99&rsquo;                           245 ms
test &lsquo;bitshift&rsquo;          string &lsquo;1234&rsquo;                         397 ms
test &lsquo;bitshift&rsquo;          string &lsquo;1234567&rsquo;                      462 ms
test &lsquo;bitshift&rsquo;          string &lsquo;1234567891&rsquo;                   666 ms
test &lsquo;bitshift&rsquo;          string &lsquo;12345678901234&rsquo;               888 ms
test &lsquo;bitshift&rsquo;          string &lsquo;12345678901234678901&rsquo;        1277 ms</p>

<p>test &lsquo;unrolled&rsquo;          string &lsquo;1&rsquo;                            289 ms
test &lsquo;unrolled&rsquo;          string &lsquo;99&rsquo;                           289 ms
test &lsquo;unrolled&rsquo;          string &lsquo;1234&rsquo;                         351 ms
test &lsquo;unrolled&rsquo;          string &lsquo;1234567&rsquo;                      408 ms
test &lsquo;unrolled&rsquo;          string &lsquo;1234567891&rsquo;                   547 ms
test &lsquo;unrolled&rsquo;          string &lsquo;12345678901234&rsquo;               778 ms
test &lsquo;unrolled&rsquo;          string &lsquo;12345678901234678901&rsquo;        1068 ms
```</p>

<p>It&rsquo;s no surprise the standard library functions with their generality and
error checking features are slower than the specialized functions that took
the liberty to ignore all that.</p>

<p>Which method is fastest now?</p>

<p>As can be seen above, the &ldquo;bitshift&rdquo; variant was fastest for short and medium
length inputs in my environment. At some point when input values get longer,
the &ldquo;bitshift&rdquo; methods gets overtaken by the &ldquo;unrolled&rdquo; variant. The &ldquo;naive&rdquo;
variant was slower than the two in most cases, but still performs surprisingly
well.</p>

<h2>Conclusion</h2>

<p>The take-away: even though string-to-number conversion routines are
present in the standard library, it can still be beneficial to hand-craft
specialized variants of them for maximum performance. This is especially true
when most of the generality that the standard library routines provide is not
required in your use case.</p>

<p>For example, if you know that the conversion functions will only operate on
&ldquo;trusted&rdquo; input (only numeric digit input characters, length of input string
won&rsquo;t exceed the maximum length of a uint64_t number etc.) then error checking
is not required.</p>

<p>Additionally, if you can limit yourself to numbers of a specific base and
don&rsquo;t negative base conversion nor the handling of negative values, a lot of
the generality and safety overhead of std::stoull may be avoided.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compiling ArangoDB 3.0 on Ubuntu]]></title>
    <link href="http://jsteemann.github.io/blog/2016/06/02/compiling-arangodb-3-dot-0-on-ubuntu/"/>
    <updated>2016-06-02T20:15:01+02:00</updated>
    <id>http://jsteemann.github.io/blog/2016/06/02/compiling-arangodb-3-dot-0-on-ubuntu</id>
    <content type="html"><![CDATA[<p>We have spent a lot of time working on ArangoDB 3.0. That
version will not only provide major functionality and performance
improvements, but will also come with an improved, CMake-based
build system.</p>

<p>This post explains how to use CMake to build ArangoDB 3.0 on a recent
Ubuntu Linux. For the impatient there&rsquo;s a command summary at the end of
this post.</p>

<!-- more -->


<h2>Installing prerequisites</h2>

<p>Here&rsquo;s how to build ArangoDB 3.0 with cmake on a recent Ubuntu Linux.</p>

<p>Ubuntu 15.x and 16.x should have recent enough packages so any missing
prerequisites can be installed via a simple <code>sudo apt-get install</code> command:</p>

<p><code>bash installing prerequisites
sudo apt-get install cmake make build-essential openssl python2.7 g++ gcc
</code></p>

<p>Older versions of Ubuntu can be convinced to work too, but this requires
a g++ version of at least 4.9. Ubuntu 14 ships with older g++
versions by default, so you will first need to install a newer g++ version
(see <a href="http://askubuntu.com/questions/466651/how-do-i-use-the-latest-gcc-on-ubuntu-14-04">here</a> or
<a href="http://askubuntu.com/questions/428198/getting-installing-gcc-g-4-9-on-ubuntu">here</a> for
some external instructions). Once the g++ and gcc compilers are recent enough,
install the other prerequisites.</p>

<h2>Cloning ArangoDB</h2>

<p>After having installed the prerequisites, clone the ArangoDB repository
from Github and then cd into the directory <code>arangodb</code> that the cloning
will have created:</p>

<p><code>bash cloning ArangoDB
git clone https://github.com/arangodb/arangodb
cd arangodb
</code></p>

<p>Then check out the 3.0 branch and pull the latest changes:
<code>bash cloning ArangoDB
git checkout 3.0
git pull
</code></p>

<h2>Building ArangoDB</h2>

<p>A convention when using CMake is to not build directly in the source
directory, but use a separate build directory instead. The benefit of
this is that building in a separate directory won&rsquo;t change the source
directory, and the build directory can be disposed easily.</p>

<p>To create an initial build directory named <code>build</code> and cd into it,
just type:</p>

<p><code>bash creating a build directory
mkdir -p build
cd build
</code></p>

<p>It&rsquo;s now time to invoke CMake. CMake should be executed from the build
directory, but needs to know where it&rsquo;s build instructions file
(named <code>CMakeLists.txt</code> is). This file is located in the source directory.
To run CMake without any specific options, we can use:</p>

<p><code>bash running CMake
cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo ..
</code></p>

<p>This will run CMake from inside the <code>build</code> directory and tell it to
look for <code>CMakeLists.txt</code> in the source directory. The
<code>-DCMAKE_BUILD_TYPE=RelWithDebInfo</code> part will tell CMake to build
binaries with optimizations and debug symbols. Other useful build
types are:</p>

<ul>
<li><code>-DCMAKE_BUILD_TYPE=Debug</code>: without optimizations, for debugging only</li>
<li><code>-DCMAKE_BUILD_TYPE=Release</code>: with optimizations, no debug symbols,
not useful for debugging</li>
</ul>


<p>Invoking CMake will perform some checks for required components, compiler
and platform features. If anything fails, it should print some error
message. If everything works well, the command should have created a
<code>Makefile</code> in the <code>build</code> directory.</p>

<p><em>side note: CMake on Linux will by default generate UNIX <code>Makefile</code>s,
but it can also be told to generate <a href="https://ninja-build.org/">ninja</a>
files instead. On Windows it can generate solution files for Visual
Studio.</em></p>

<p>Now that the <code>Makefile</code> is there, we can run <code>make</code> as usual (note that
the <code>-j4</code> means to build with 4 parallel processes &ndash; adjust as needed!):</p>

<p><code>bash running make
make -j4
</code></p>

<h2>Starting arangod and arangosh</h2>

<p>And that&rsquo;s already it for a normal build. Note that the build artefacts
and thus the binaries will also be created inside the <code>build</code> directory.
<code>arangod</code> and <code>arangosh</code> will be located in the <code>bin</code> subdirectory of
the <code>build</code> directory. There is no need to install these binaries, they
can be run without installing them first. However, starting them from
inside the build directory will not work, because they will complain
about missing files. It is better to cd one level up first and then
start them:</p>

<p><code>bash starting arangod
cd ..
build/bin/arangod ~/testdata --server.authentication false
</code></p>

<p>The former will start arangod with default configuration, with a fresh
database directory located in <code>~/testdata</code>.</p>

<p>If you ran all the commands on your local machine (127.0.0.1) then you
can now open a browser and point it to <a href="http://127.0.0.1:8529/">http://127.0.0.1:8529/</a>.
This should bring up ArangoDB&rsquo;s web interface.</p>

<p>You can alternatively start an ArangoShell to connect to the ArangoDB
server. In another terminal window, cd into the <code>arangodb</code> directory and
start an ArangoShell as follows:</p>

<p><code>bash starting arangosh
cd arangodb
build/bin/arangosh
</code></p>

<p>You should now see the ArangoShell prompt and be able to type some
commands!</p>

<h2>Command summary</h2>

<p>Note: in contrast to the above step-by-step instructions, some commands
here have been put together on a single line to make developer&rsquo;s life
easier.</p>

<p><code>bash installing prerequisites
sudo apt-get install cmake make build-essential openssl python2.7 g++ gcc
</code></p>

<p><code>bash initial checkout of the 3.0 branch and build configuration
git clone https://github.com/arangodb/arangodb
cd arangodb
git checkout 3.0
git pull
mkdir -p build
(cd build &amp;&amp; cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo ..)
</code></p>

<p><code>bash Update, build and run cycle
git pull
(cd build &amp;&amp; make -j4)
build/bin/arangod ~/testdata --server.authentication false
</code></p>
]]></content>
  </entry>
  
</feed>
