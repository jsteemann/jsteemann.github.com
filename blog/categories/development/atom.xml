<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Development | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/development/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2016-06-03T00:48:00+02:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fastest String-to-uint64 Conversion Method?]]></title>
    <link href="http://jsteemann.github.io/blog/2016/06/02/fastest-string-to-uint64-conversion-method/"/>
    <updated>2016-06-02T20:15:27+02:00</updated>
    <id>http://jsteemann.github.io/blog/2016/06/02/fastest-string-to-uint64-conversion-method</id>
    <content type="html"><![CDATA[<p>While doing some optimization work for the upcoming ArangoDB 3.0 release,
we had to figure out what was the &ldquo;ideal&rdquo; way of converting a string
representation of a number into a C++ uint64_t (64 bit unsigned integer type).
This kind of operation is performed a lot during the lifetime of an ArangoDB
server process, so it seemed worthwhile making it as fast as possible.</p>

<!-- more -->


<h2>std::stoull and std::strtoull</h2>

<p>The natural solution for this kind of conversion is the standard library&rsquo;s
<a href="http://en.cppreference.com/w/cpp/string/basic_string/stoul">std::stoull</a>
function. On the one hand, that solution is potentially optimized and definitely
robust. It performs validation of the input characters and is also battle-tested
by millions of users.</p>

<p>On the other hand, std::stoull has a few &ldquo;features&rdquo; that some would consider
&ldquo;anti&rdquo;-features, and that sound like they could negatively influence performance:</p>

<ul>
<li>it may behave locale-dependent</li>
<li>it can parse and will let pass negative input values, which is often not desired
for a result of unsigned type</li>
<li>it can perform base conversion</li>
</ul>


<p>In C++11 there is also the alternative
<a href="http://en.cppreference.com/w/cpp/string/byte/strtoul">std::strtoull</a>.
It should behave about the same as std::stoull except in case of error.
std::stoull will throw and std::strtoull will not.</p>

<p>That&rsquo;s what we get from the standard library for long unsigned integer types.</p>

<h2>Alternative implementations (w/o error checking)</h2>

<p>Another alternative is to roll a string to number conversion function ourselves.
If we hard-code it to base 10 and do not care about error checking, a naive
implementation may look like this:</p>

<p>```cpp
inline uint64_t naive(std::string const&amp; value) {
  uint64_t result = 0;
  char const<em> p = value.c_str();
  char const</em> q = p + value.size();
  while (p &lt; q) {</p>

<pre><code>result *= 10;
result += *(p++) - '0';
</code></pre>

<p>  }
  return result;
}
```</p>

<p>Obviously the above will produce wrong results for invalid
input data, but for &ldquo;trusted&rdquo; (known to be valid) input it may
be just fine.</p>

<p>Here&rsquo;s just another implementation for the problem at hand. This one
doesn&rsquo;t perform the times 10 operation, but splits it into two bitshifting
operations:</p>

<p>```cpp
inline uint64_t bitshift(std::string const&amp; value) {
  uint64_t result = 0;</p>

<p>  char const<em> p = value.c_str();
  char const</em> q = p + value.size();
  while (p &lt; q) {</p>

<pre><code>result = (result &lt;&lt; 1) + (result &lt;&lt; 3) + *(p++) - '0';
</code></pre>

<p>  }
  return result;
}
```</p>

<p>Again no error checking is present in the above function, but it
should be ok for trusted inputs.</p>

<p>By manually unrolling the while loop and converting it into a switch
statement, we can also come up with a conversion function that has minimal
branching:</p>

<p>```cpp
inline uint64_t unrolled(std::string const&amp; value) {
  uint64_t result = 0;</p>

<p>  size_t const length = value.size();
  switch (length) {</p>

<pre><code>case 20:    result += (value[length - 20] - '0') * 10000000000000000000ULL;
case 19:    result += (value[length - 19] - '0') * 1000000000000000000ULL;
case 18:    result += (value[length - 18] - '0') * 100000000000000000ULL;
case 17:    result += (value[length - 17] - '0') * 10000000000000000ULL;
case 16:    result += (value[length - 16] - '0') * 1000000000000000ULL;
case 15:    result += (value[length - 15] - '0') * 100000000000000ULL;
case 14:    result += (value[length - 14] - '0') * 10000000000000ULL;
case 13:    result += (value[length - 13] - '0') * 1000000000000ULL;
case 12:    result += (value[length - 12] - '0') * 100000000000ULL;
case 11:    result += (value[length - 11] - '0') * 10000000000ULL;
case 10:    result += (value[length - 10] - '0') * 1000000000ULL;
case  9:    result += (value[length -  9] - '0') * 100000000ULL;
case  8:    result += (value[length -  8] - '0') * 10000000ULL;
case  7:    result += (value[length -  7] - '0') * 1000000ULL;
case  6:    result += (value[length -  6] - '0') * 100000ULL;
case  5:    result += (value[length -  5] - '0') * 10000ULL;
case  4:    result += (value[length -  4] - '0') * 1000ULL;
case  3:    result += (value[length -  3] - '0') * 100ULL;
case  2:    result += (value[length -  2] - '0') * 10ULL;
case  1:    result += (value[length -  1] - '0');
</code></pre>

<p>  }
  return result;
}
```</p>

<h2>Performance testing</h2>

<p>To check out how all these alternatives perform, I put them into a small
<a href="/downloads/code/stoull-test.cpp">test driver program</a>. To compile it with
g++ and run it, I used this command:</p>

<p><code>bash
g++ -Wall -Wextra -march=native -std=c++11 -O3 stdoull-test.cpp &amp;&amp; ./a.out
</code></p>

<p>The test program will convert input strings of different lengths to uint64_t
using the above (and some other) implementations, going up from 10,000 iterations
per string up to 100,000,000. It also prints the wall-clock time spent in each
run. The most interesting output it prints is in the &ldquo;ms&rdquo; column. The &ldquo;result&rdquo;
column can be fully ignored. It&rsquo;s only there so the compiler won&rsquo;t optimize away
the calls to the conversion functions.</p>

<p>The timings from my local laptop (Intel Core i7-4710HQ CPU @ 2.50GHz, Ubuntu 16.04,
g++ 5.3.1 &ndash; your mileage may vary!) for the 100,000,000 conversions are:</p>

<p>```plain execution times for various string-to-uint64 implementations
test &lsquo;std::stoull&rsquo;       string &lsquo;1&rsquo;                           1209 ms
test &lsquo;std::stoull&rsquo;       string &lsquo;99&rsquo;                          1382 ms
test &lsquo;std::stoull&rsquo;       string &lsquo;1234&rsquo;                        1725 ms
test &lsquo;std::stoull&rsquo;       string &lsquo;1234567&rsquo;                     2257 ms
test &lsquo;std::stoull&rsquo;       string &lsquo;1234567891&rsquo;                  2764 ms
test &lsquo;std::stoull&rsquo;       string &lsquo;12345678901234&rsquo;              3899 ms
test &lsquo;std::stoull&rsquo;       string &lsquo;12345678901234678901&rsquo;        7391 ms</p>

<p>test &lsquo;std::strtoull&rsquo;     string &lsquo;1&rsquo;                           1104 ms
test &lsquo;std::strtoull&rsquo;     string &lsquo;99&rsquo;                          1300 ms
test &lsquo;std::strtoull&rsquo;     string &lsquo;1234&rsquo;                        1628 ms
test &lsquo;std::strtoull&rsquo;     string &lsquo;1234567&rsquo;                     2428 ms
test &lsquo;std::strtoull&rsquo;     string &lsquo;1234567891&rsquo;                  2662 ms
test &lsquo;std::strtoull&rsquo;     string &lsquo;12345678901234&rsquo;              3705 ms
test &lsquo;std::strtoull&rsquo;     string &lsquo;12345678901234678901&rsquo;        6631 ms</p>

<p>test &lsquo;naive&rsquo;             string &lsquo;1&rsquo;                            202 ms
test &lsquo;naive&rsquo;             string &lsquo;99&rsquo;                           314 ms
test &lsquo;naive&rsquo;             string &lsquo;1234&rsquo;                         475 ms
test &lsquo;naive&rsquo;             string &lsquo;1234567&rsquo;                      732 ms
test &lsquo;naive&rsquo;             string &lsquo;1234567891&rsquo;                   987 ms
test &lsquo;naive&rsquo;             string &lsquo;12345678901234&rsquo;              1343 ms
test &lsquo;naive&rsquo;             string &lsquo;12345678901234678901&rsquo;        1862 ms</p>

<p>test &lsquo;bitshift&rsquo;          string &lsquo;1&rsquo;                            188 ms
test &lsquo;bitshift&rsquo;          string &lsquo;99&rsquo;                           245 ms
test &lsquo;bitshift&rsquo;          string &lsquo;1234&rsquo;                         397 ms
test &lsquo;bitshift&rsquo;          string &lsquo;1234567&rsquo;                      462 ms
test &lsquo;bitshift&rsquo;          string &lsquo;1234567891&rsquo;                   666 ms
test &lsquo;bitshift&rsquo;          string &lsquo;12345678901234&rsquo;               888 ms
test &lsquo;bitshift&rsquo;          string &lsquo;12345678901234678901&rsquo;        1277 ms</p>

<p>test &lsquo;unrolled&rsquo;          string &lsquo;1&rsquo;                            289 ms
test &lsquo;unrolled&rsquo;          string &lsquo;99&rsquo;                           289 ms
test &lsquo;unrolled&rsquo;          string &lsquo;1234&rsquo;                         351 ms
test &lsquo;unrolled&rsquo;          string &lsquo;1234567&rsquo;                      408 ms
test &lsquo;unrolled&rsquo;          string &lsquo;1234567891&rsquo;                   547 ms
test &lsquo;unrolled&rsquo;          string &lsquo;12345678901234&rsquo;               778 ms
test &lsquo;unrolled&rsquo;          string &lsquo;12345678901234678901&rsquo;        1068 ms
```</p>

<p>It&rsquo;s no surprise the standard library functions with their generality and
error checking features are slower than the specialized functions that took
the liberty to ignore all that.</p>

<p>Which method is fastest now?</p>

<p>As can be seen above, the &ldquo;bitshift&rdquo; variant was fastest for short and medium
length inputs in my environment. At some point when input values get longer,
the &ldquo;bitshift&rdquo; methods gets overtaken by the &ldquo;unrolled&rdquo; variant. The &ldquo;naive&rdquo;
variant was slower than the two in most cases, but still performs surprisingly
well.</p>

<h2>Conclusion</h2>

<p>The take-away: even though string-to-number conversion routines are
present in the standard library, it can still be beneficial to hand-craft
specialized variants of them for maximum performance. This is especially true
when most of the generality that the standard library routines provide is not
required in your use case.</p>

<p>For example, if you know that the conversion functions will only operate on
&ldquo;trusted&rdquo; input (only numeric digit input characters, length of input string
won&rsquo;t exceed the maximum length of a uint64_t number etc.) then error checking
is not required.</p>

<p>Additionally, if you can limit yourself to numbers of a specific base and
don&rsquo;t negative base conversion nor the handling of negative values, a lot of
the generality and safety overhead of std::stoull may be avoided.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compiling ArangoDB 3.0 on Ubuntu]]></title>
    <link href="http://jsteemann.github.io/blog/2016/06/02/compiling-arangodb-3-dot-0-on-ubuntu/"/>
    <updated>2016-06-02T20:15:01+02:00</updated>
    <id>http://jsteemann.github.io/blog/2016/06/02/compiling-arangodb-3-dot-0-on-ubuntu</id>
    <content type="html"><![CDATA[<p>We have spent a lot of time working on ArangoDB 3.0. That
version will not only provide major functionality and performance
improvements, but will also come with an improved, CMake-based
build system.</p>

<p>This post explains how to use CMake to build ArangoDB 3.0 on a recent
Ubuntu Linux. For the impatient there&rsquo;s a command summary at the end of
this post.</p>

<!-- more -->


<h2>Installing prerequisites</h2>

<p>Here&rsquo;s how to build ArangoDB 3.0 with cmake on a recent Ubuntu Linux.</p>

<p>Ubuntu 15.x and 16.x should have recent enough packages so any missing
prerequisites can be installed via a simple <code>sudo apt-get install</code> command:</p>

<p><code>bash installing prerequisites
sudo apt-get install cmake make build-essential openssl python2.7 g++ gcc
</code></p>

<p>Older versions of Ubuntu can be convinced to work too, but this requires
a g++ version of at least 4.9. Ubuntu 14 ships with older g++
versions by default, so you will first need to install a newer g++ version
(see <a href="http://askubuntu.com/questions/466651/how-do-i-use-the-latest-gcc-on-ubuntu-14-04">here</a> or
<a href="http://askubuntu.com/questions/428198/getting-installing-gcc-g-4-9-on-ubuntu">here</a> for
some external instructions). Once the g++ and gcc compilers are recent enough,
install the other prerequisites.</p>

<h2>Cloning ArangoDB</h2>

<p>After having installed the prerequisites, clone the ArangoDB repository
from Github and then cd into the directory <code>arangodb</code> that the cloning
will have created:</p>

<p><code>bash cloning ArangoDB
git clone https://github.com/arangodb/arangodb
cd arangodb
</code></p>

<p>Then check out the 3.0 branch and pull the latest changes:
<code>bash cloning ArangoDB
git checkout 3.0
git pull
</code></p>

<h2>Building ArangoDB</h2>

<p>A convention when using CMake is to not build directly in the source
directory, but use a separate build directory instead. The benefit of
this is that building in a separate directory won&rsquo;t change the source
directory, and the build directory can be disposed easily.</p>

<p>To create an initial build directory named <code>build</code> and cd into it,
just type:</p>

<p><code>bash creating a build directory
mkdir -p build
cd build
</code></p>

<p>It&rsquo;s now time to invoke CMake. CMake should be executed from the build
directory, but needs to know where it&rsquo;s build instructions file
(named <code>CMakeLists.txt</code> is). This file is located in the source directory.
To run CMake without any specific options, we can use:</p>

<p><code>bash running CMake
cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo ..
</code></p>

<p>This will run CMake from inside the <code>build</code> directory and tell it to
look for <code>CMakeLists.txt</code> in the source directory. The
<code>-DCMAKE_BUILD_TYPE=RelWithDebInfo</code> part will tell CMake to build
binaries with optimizations and debug symbols. Other useful build
types are:</p>

<ul>
<li><code>-DCMAKE_BUILD_TYPE=Debug</code>: without optimizations, for debugging only</li>
<li><code>-DCMAKE_BUILD_TYPE=Release</code>: with optimizations, no debug symbols,
not useful for debugging</li>
</ul>


<p>Invoking CMake will perform some checks for required components, compiler
and platform features. If anything fails, it should print some error
message. If everything works well, the command should have created a
<code>Makefile</code> in the <code>build</code> directory.</p>

<p><em>side note: CMake on Linux will by default generate UNIX <code>Makefile</code>s,
but it can also be told to generate <a href="https://ninja-build.org/">ninja</a>
files instead. On Windows it can generate solution files for Visual
Studio.</em></p>

<p>Now that the <code>Makefile</code> is there, we can run <code>make</code> as usual (note that
the <code>-j4</code> means to build with 4 parallel processes &ndash; adjust as needed!):</p>

<p><code>bash running make
make -j4
</code></p>

<h2>Starting arangod and arangosh</h2>

<p>And that&rsquo;s already it for a normal build. Note that the build artefacts
and thus the binaries will also be created inside the <code>build</code> directory.
<code>arangod</code> and <code>arangosh</code> will be located in the <code>bin</code> subdirectory of
the <code>build</code> directory. There is no need to install these binaries, they
can be run without installing them first. However, starting them from
inside the build directory will not work, because they will complain
about missing files. It is better to cd one level up first and then
start them:</p>

<p><code>bash starting arangod
cd ..
build/bin/arangod ~/testdata --server.authentication false
</code></p>

<p>The former will start arangod with default configuration, with a fresh
database directory located in <code>~/testdata</code>.</p>

<p>If you ran all the commands on your local machine (127.0.0.1) then you
can now open a browser and point it to <a href="http://127.0.0.1:8529/">http://127.0.0.1:8529/</a>.
This should bring up ArangoDB&rsquo;s web interface.</p>

<p>You can alternatively start an ArangoShell to connect to the ArangoDB
server. In another terminal window, cd into the <code>arangodb</code> directory and
start an ArangoShell as follows:</p>

<p><code>bash starting arangosh
cd arangodb
build/bin/arangosh
</code></p>

<p>You should now see the ArangoShell prompt and be able to type some
commands!</p>

<h2>Command summary</h2>

<p>Note: in contrast to the above step-by-step instructions, some commands
here have been put together on a single line to make developer&rsquo;s life
easier.</p>

<p><code>bash installing prerequisites
sudo apt-get install cmake make build-essential openssl python2.7 g++ gcc
</code></p>

<p><code>bash initial checkout of the 3.0 branch and build configuration
git clone https://github.com/arangodb/arangodb
cd arangodb
git checkout 3.0
git pull
mkdir -p build
(cd build &amp;&amp; cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo ..)
</code></p>

<p><code>bash Update, build and run cycle
git pull
(cd build &amp;&amp; make -j4)
build/bin/arangod ~/testdata --server.authentication false
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compiling V8 With G++6]]></title>
    <link href="http://jsteemann.github.io/blog/2016/06/02/compiling-v8-with-g-plus-plus-6/"/>
    <updated>2016-06-02T20:14:46+02:00</updated>
    <id>http://jsteemann.github.io/blog/2016/06/02/compiling-v8-with-g-plus-plus-6</id>
    <content type="html"><![CDATA[<p>With g++ 6 becoming more and more adopted, it&rsquo;s about time to point out an issue
that hit some of us ArangoDB developers and a few of our users that compile ArangoDB
from source with g++ 6.</p>

<p>The problem is that when compiling ArangoDB with g++6 with default options, arangod
starts and almost immediately segfaults.</p>

<!-- more -->


<p>A backtrace of the crashed arangod process shows that the segfaults originate from
the V8 JavaScript engine that ArangoDB uses internally.
The problem seems to have affected other users of V8 as well, indicated by the following
error reports:</p>

<ul>
<li>node.js: <a href="https://github.com/nodejs/node/issues/6724">https://github.com/nodejs/node/issues/6724</a></li>
<li>chromium: <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68853">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68853</a></li>
</ul>


<p>The reason for the error now popping up is a change in the g++ 6 optimizer as stated
in the <a href="https://gcc.gnu.org/gcc-6/changes.html">gcc6 release notes</a>:</p>

<blockquote><p>Value range propagation now assumes that the this pointer of C++ member functions is non-null.
This eliminates common null pointer checks but also breaks some non-conforming code-bases (such as Qt-5, Chromium, KDevelop).
As a temporary work-around -fno-delete-null-pointer-checks can be used. Wrong code can be identified by using -fsanitize=undefined.</p></blockquote>

<p>That means if compiling ArangoDB 2.8 from source with g++ 6 or higher, please be sure to
set the environment variables <code>CFLAGS="-fno-delete-null-pointer-checks"</code> and<br/>
<code>CXXFLAGS="-fno-delete-null-pointer-checks"</code> before invoking the <code>configure</code> command:</p>

<p><code>bash
make setup
CFLAGS="-fno-delete-null-pointer-checks" CXXFLAGS="-fno-delete-null-pointer-checks" ./configure
make
</code></p>

<p>The options will then be passed to the sub-make that builds the V8 engine. If you have
already built V8 without these options, try removing the file <code>.v8-build-64</code> from the
build directory and run <code>configure</code> and <code>make</code> again.</p>

<p>As a reminder, ArangoDB 2.8 will also emit this big notice at the end of its <code>configure</code> output:</p>

<p><code>plain
configure: --------------------------------------------------------------------------------
configure:                                                                                 
configure: NOTE: if you are compiling ArangoDB with g++ 6.0 or higher, please make sure to
configure: set the following environment variables when compiling ArangoDB:                
configure:                                                                                 
configure:   CFLAGS="-fno-delete-null-pointer-checks"                                      
configure:   CXXFLAGS="-fno-delete-null-pointer-checks"                                    
configure:                                                                                 
configure: --------------------------------------------------------------------------------
</code></p>

<p>Users of g++ 5.x do not need to set these flags, neither need users of clang++. And in the
ArangoDB 3.0 build the options will be set automatically when compiling V8 if the compiler
is g++. They will not be set for compiling any other parts of ArangoDB as it&rsquo;s only required
for building V8.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Constructors and Memory Leaks]]></title>
    <link href="http://jsteemann.github.io/blog/2015/11/18/on-exception-handling/"/>
    <updated>2015-11-18T01:10:51+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/11/18/on-exception-handling</id>
    <content type="html"><![CDATA[<h2>Preventing leaks in throwing constructors</h2>

<p>The easiest way to prevent memory leaks is to create all objects on
the stack and not using dynamic memory at all. However, often this is not
possible, for example because stack size is limited or objects need to
outlive the caller&rsquo;s scope.</p>

<p>Another way to prevent memory leaks and leaks of other resources is
obviously to employ the RAII pattern. How can it be used safely and
easily in practice, so memory leaks can be avoided?</p>

<p>This post will start with a few seemingly working but subtly ill-formed
techniques that a few common pitfalls. Later on it will provide a few
very simple solutions for getting it right.</p>

<!--more -->


<p>None of the solutions here are new or original.</p>

<p>I took some inspiration from the excellent <a href="http://gotw.ca/gotw/066.htm">constructor failures GotW post</a>.
That doesn&rsquo;t cover smart pointers and is not explicitly about preventing
preventing memory leak, so I put together this overview myself.</p>

<h2>Naive implementation</h2>

<p>Let&rsquo;s pretend we have a simple test program <code>main.cpp</code>, which
creates an object of class <em>MyClass</em> on the stack like this:</p>

<p>```cpp main.cpp</p>

<h1>include <iostream></h1>

<h1>include &ldquo;MyClass.h&rdquo;</h1>

<p>int main () {
  try {</p>

<pre><code>MyClass myClass;
std::cout &lt;&lt; "NO EXCEPTION" &lt;&lt; std::endl;
</code></pre>

<p>  }
  catch (&hellip;) {</p>

<pre><code>std::cout &lt;&lt; "CAUGHT EXCEPTION" &lt;&lt; std::endl;
</code></pre>

<p>  }
}
```</p>

<p>The above code creates the <em>myClass</em> instance on the stack, so
itself will not leak any memory. When the creating of the <em>myClass</em>
instance fails for whatever reason, the instance newer existed so
the memory for holding a <em>MyClass</em> object will be freed automatically.
If object creation succeeds and the object goes out of scope at the
end of the <em>try</em> block, then the object&rsquo;s destructor will be called
and resources can be freed, too.</p>

<p>Obviously this is already good, so let&rsquo;s keep it as it is and have a
look at the implementation of <em>MyClass</em> now. This class will manage
two heap objects of type <em>A</em>, which are created using the helper
function <em>createInstance</em>:</p>

<p>```cpp MyClass.h</p>

<h1>include <iostream></h1>

<h1>include &ldquo;A.h&rdquo;</h1>

<p>struct MyClass {
  A<em> a1;
  A</em> a2;</p>

<p>  MyClass ()</p>

<pre><code>: a1(createInstance()),
  a2(createInstance()) {

std::cout &lt;&lt; "CTOR MYCLASS" &lt;&lt; std::endl;
</code></pre>

<p>  }</p>

<p>  ~MyClass () {</p>

<pre><code>std::cout &lt;&lt; "DTOR MYCLASS" &lt;&lt; std::endl;
delete a1;
delete a2;
</code></pre>

<p>  }
};
```</p>

<p>For completeness, here is class <em>A</em>. It won&rsquo;t manage any resources
itself:</p>

<p>```cpp A.h</p>

<h1>include <iostream></h1>

<p>struct A {
  A () {</p>

<pre><code>std::cout &lt;&lt; "CTOR A" &lt;&lt; std::endl;
</code></pre>

<p>  }
  ~A () {</p>

<pre><code>std::cout &lt;&lt; "DTOR A" &lt;&lt; std::endl;
</code></pre>

<p>  }
};</p>

<p>// helper method for creating an instance of A
A* createInstance (bool shouldThrow = false) {
  if (shouldThrow) {</p>

<pre><code>throw "THROWING AN EXCEPTION";
</code></pre>

<p>  }
  return new A;
}
```</p>

<p>During this complete post, the code of <em>A.h</em> will remain unchanged.</p>

<p>Compiling and running the initial version of <code>main.cpp</code> will produce the
following output:</p>

<p><code>plain output of naive implementation
CTOR A
CTOR A
CTOR MYCLASS
NO EXCEPTION
DTOR MYCLASS
DTOR A
DTOR A
</code></p>

<p>Valgrind also reports no memory leaks. Are we done already?</p>

<h2>Introducing exceptions</h2>

<p>No, because everything still went well. Let&rsquo;s introduce exceptions into
the picture and check what happens then.</p>

<p>Let&rsquo;s first introduce an exception in the constructor of <em>MyClass</em>.
We&rsquo;ll make the <em>createInstance</em> function throw on second invocation (we do
this by passing a value of <em>true</em> to it):</p>

<p>```cpp constructor throwing an exception
MyClass ()
  : a1(createInstance()),</p>

<pre><code>a2(createInstance(true)) {
</code></pre>

<p>  std::cout &lt;&lt; &ldquo;CTOR MYCLASS&rdquo; &lt;&lt; std::endl;
}
```</p>

<p>Running the program will now emit the following:</p>

<p><code>plain output of naive implementation, with exception
CTOR A
CAUGHT EXCEPTION
</code></p>

<p>As we&rsquo;re throwing in the initializer list already, we don&rsquo;t even
reach the constructor body. This is no problem, but worse is that the
destructor for class <em>MyClass</em> is not being called at all.
Valgrind therefore reports the memory for first <em>A</em> instance as leaked.</p>

<p>By the way, the destructor for the <em>MyClass</em> instance is intentionally
not being called as the object hasn&rsquo;t been fully constructed and logically
never existed.</p>

<p>Will it help if we move the heap allocations from the initializer list
into the constructor body like this?</p>

<p><code>cpp using the constructor body instead of the initializer list
MyClass () {
  std::cout &lt;&lt; "CTOR MYCLASS" &lt;&lt; std::endl;
  a1 = createInstance();
  a2 = createInstance(true);
}
</code></p>

<p>Unfortunately not. Still no destructor invocations:</p>

<p><code>plain output of constructor body variant
CTOR MYCLASS
CTOR A
CAUGHT EXCEPTION
</code></p>

<p>Remember: an object&rsquo;s destructor won&rsquo;t be called if its constructor threw
and the exception wasn&rsquo;t caught. That also means releasing an object&rsquo;s
resources solely via the destructor as in implementation above will not be
sufficient if resources are allocated in the constructor and the constructor
can throw.</p>

<p>What can be done about that?</p>

<p>Obviously all resource allocations can be moved into the constructor body so
exceptions can be caught there:</p>

<p>```cpp catching exceptions in constructor of MyClass
MyClass () {
  std::cout &lt;&lt; &ldquo;CTOR MYCLASS&rdquo; &lt;&lt; std::endl;
  a1 = createInstance();</p>

<p>  try {</p>

<pre><code>a2 = createInstance(true);
</code></pre>

<p>  }
  catch (&hellip;) {</p>

<pre><code>// must clean up a1 to prevent a leak
delete a1;
// and re-throw the exception
throw;
</code></pre>

<p>  }
}
```</p>

<p>While the above will work, it&rsquo;s clumsy, verbose and error-prone. If
more objects need to be managed this will make us end up in deeply
nested try&hellip;catch blocks.</p>

<h2>try&hellip;catch for the initializer list</h2>

<p>But wait, wasn&rsquo;t there a try&hellip;catch feature especially for initializer
list code? Sounds like it could be useful. Maybe we can use this instead
so we can catch exceptions during initialization?</p>

<p>There is indeed something like that: exceptions thrown from the initializer
list  can be caught using the following special syntax:</p>

<p>```cpp catching exceptions thrown in the initializer list
MyClass ()
  try : a1(createInstance()),</p>

<pre><code>    a2(createInstance(true)) {

std::cout &lt;&lt; "CTOR MYCLASS" &lt;&lt; std::endl;
</code></pre>

<p>  }
  catch (&hellip;) {  // catch block for initializer list code</p>

<pre><code>std::cout &lt;&lt; "CATCH BLOCK MYCLASS" &lt;&lt; std::endl;
delete a1;
</code></pre>

<p>  }
```</p>

<p>Running the program with the above <em>MyClass</em> constructor will also
do what is expected: when creating the second <em>A</em> instance, the
initializer list code will throw, invoking its catch block. Again
code execution won&rsquo;t make it into the constructor body, and we don&rsquo;t
see the destructor code in action.</p>

<p>The output of the program is:</p>

<p><code>plain output of initializer list variant
CTOR A
CATCH BLOCK MYCLASS
DTOR A
CAUGHT EXCEPTION
</code></p>

<p>Valgrind does not report a leak, so are we done now?</p>

<p>No, as the above code has a severe problem. It worked only
because we knew the second invocation of <em>createInstance</em> would fail.</p>

<p>But in the general case, either the first call or the second call
can fail. If the first call fails, then the initializer hasn&rsquo;t
initialized any of the object&rsquo;s members, and it would be unsafe to
delete any object members in the initializer&rsquo;s catch block. If the
second <em>createInstance</em> call fails, then the initializer has created
<em>a1</em> but not <em>a2</em>. To prevent a leak in this case, we should delete <em>a1</em>,
but we better don&rsquo;t delete <em>a2</em> yet.</p>

<p>But how do we tell in the catch block at what stage the initializer
list had thrown? There is no natural way to do this correctly without
introducing more state. And without that, we have the choice between
undefined behavior when deleting the not-yet-initialized object
members, and memory leaks when ignoring them.</p>

<h2>Not using pointers at all</h2>

<p>Note that if we wouldn&rsquo;t have used pointers for our managed <em>A</em> objects,
then we could have used the fact that destructors for all initialized
object members <strong>are</strong> actually called when object construction fails.</p>

<p>However, simple pointers don&rsquo;t have a destructor, so the objects they
point to remain and the memory is lost.</p>

<p>So one obvious solution for preventing memory leaks is to not use pointers,
and get rid of all <code>new</code> and <code>delete</code> statements.</p>

<p>In some situations we can probably get away with making the managed objects
regular class members of the class that manages them:</p>

<p>```cpp not using pointers
struct MyClass {
  A a1; // no pointer anymore!
  A a2; // no pointer anymore!</p>

<p>  MyClass ()</p>

<pre><code>: a1(),
  a2() {

std::cout &lt;&lt; "CTOR MYCLASS" &lt;&lt; std::endl;
</code></pre>

<p>  }</p>

<p>  ~MyClass () {</p>

<pre><code>std::cout &lt;&lt; "DTOR MYCLASS" &lt;&lt; std::endl;
// no delete statements needed anymore!
</code></pre>

<p>  }
};
```</p>

<p>Now if any of the <em>A</em> constructors will throw an exception during
initialization, everything will be cleaned up properly. Now we can make
use of the destructor of <em>A</em>. If <em>A</em> instances are not pointers but
regular objects, the destructors for already created instances will
be called normally, and no destructors will be called for the not-yet-initialized
<em>A</em> instances. That&rsquo;s how it should be. We don&rsquo;t get this benefit with
regular pointers, which don&rsquo;t have a destructor.</p>

<p>As an aside, we got rid of the <code>delete</code> statements in the destructor
and may even get away with the default destructor.</p>

<p>Obviously this is an easy and safe solution, but it also has a few
downsides. Here are a few (incomplete list):</p>

<ul>
<li>when compiling <em>MyClass</em>, the compiler will now need to know the
definition for class <em>A</em>. You can&rsquo;t get away with a simple forward
declaration for class <em>A</em> anymore as in the case when the class
only contained pointers to <em>A</em>.
So this solution increases the source code dependencies and coupling.</li>
<li>instances of managed objects (e.g. <em>A</em>) will need to be created when
the managing object (e.g. <em>MyClass</em>) is created. There is no way to
postpone the object creation as in the case of when using pointers.</li>
<li>in general, the lifetime of the managed objects is tied to the lifetime
of the managing object. This may or may not be ok, depending on
requirements.</li>
</ul>


<h2>Using smart pointers (e.g. std::unique_ptr)</h2>

<p>In many cases the superior alternative to all the above is using one
of the available smart pointer classes for managing resources.</p>

<p>The promise of smart pointers is that resource management becomes easier,
safer and more flexible with them.</p>

<p>Really useful smart pointers (this excludes <code>std::auto_ptr</code>) are part
of standard C++ since C++11, and to my knowledge they can be used in
all C++11-compatible compilers and even in some older ones. Apart from
that, smart pointers are available in Boost for a long time already.</p>

<p>In the following snippets, I&rsquo;ll be using smart pointers of type
<code>std::unique_ptr</code> as it is the perfect fit for this particular problem.
I won&rsquo;t cover <code>shared_ptr</code>, <code>weak_ptr</code> or other types of smart pointers
here.</p>

<p>When using an <code>std::unique_ptr</code> for managing the resources of <em>MyClass</em>,
the <em>MyClass</em> code becomes:</p>

<p>```cpp using std::unique_ptr</p>

<h1>include <memory></h1>

<p>struct MyClass {
  std::unique_ptr<A> a1;
  std::unique_ptr<A> a2;</p>

<p>  MyClass () :</p>

<pre><code>a1(createInstance()),
a2(createInstance(true)) {

std::cout &lt;&lt; "CTOR MYCLASS" &lt;&lt; std::endl;
</code></pre>

<p>  }</p>

<p>  ~MyClass () {</p>

<pre><code>std::cout &lt;&lt; "DTOR MYCLASS" &lt;&lt; std::endl;
</code></pre>

<p>  }
};
```</p>

<p>With a <code>unique_ptr</code>, we can still create resources when needed,
either in the initializer list, the constructor or even later. The
resources can still be created dynamically using <code>new</code> (as is still done
by function <em>createInstance</em>). When we&rsquo;re not taking the resources
away from the <code>unique_ptr</code>s, then they will free their managed
objects automatically and safely. We don&rsquo;t need to bother with <code>delete</code>.</p>

<p>And we don&rsquo;t need to bother with nested try&hellip;catch blocks either. If
anything goes wrong during object creation, any already assigned
<code>unique_ptr</code>s will happily release the resources they manage in their
own destructors.</p>

<p>It does not matter if the above code throws an exception in the first
invocation of <em>createInstance</em>, in the second or not at all: in every
case any allocated resources are released properly, and still there
is no need for any explicit exception handling or cleanup code. This is
what a smart pointer will do for us, behind the scenes.</p>

<p>Simply compare the following two code snippets, which both create three
instances of <em>A</em> while making sure no memory will be leaked if the
initialization goes wrong:</p>

<p>```cpp solution using smart pointers
std::unique_ptr<A> a1(createInstance());
std::unique_ptr<A> a2(createInstance());
std::unique_ptr<A> a3(createInstance());</p>

<p>// now do something with a1, a2, a3
// managed objects will be released automatically when
// the unique_ptrs go out of scope
// note: they may go out of scope unintentionally if
// some code below will throw an exception&hellip;
```</p>

<p>```cpp solution using nested try&hellip;catch blocks
A<em> a1 = nullptr;
A</em> a2 = nullptr;
A* a3 = nullptr;</p>

<p>a1 = new A;
try {
  a2 = new A;
  try {</p>

<pre><code>a3 = new A;
</code></pre>

<p>  }
  catch (&hellip;) {</p>

<pre><code>delete a2;
throw;
</code></pre>

<p>  }
}
catch (&hellip;) {
  delete a1;
  throw;
}</p>

<p>// now do something with a1, a2, a3
// objects a1, a2, a3 will not be released automatically
// when a1, a2, a3 go out of scope. any user of a1, a2, a3
// below must make sure to release the objects when they
// go out of scope or when an exception is thrown&hellip;
```</p>

<p>Obviously the smart pointer-based solution is less verbose,
but it is also safer and hard to get wrong. It is especially
useful for initializing and managing dynamically allocated
object members, because as we&rsquo;ve seen most of the other
ways to do this are either subtly broken or much more complex.</p>

<p>Apart from that, we can take the managed object from out of a
<code>unique_ptr</code> and take over responsibility for managing its
lifetime.</p>

<p>Further on the plus side, a class definition that contains
<code>unique_ptr</code>s can be compiled with only forward declarations
for the managed types. However, when the <code>unique_ptr</code> is a
regular object member, at least the class destructor
implementation will need to know the size of the managed type
so it can call <code>delete</code> properly.</p>

<p>The downside of using smart pointers is that they may impose
minimal overhead when compared to the pure pointer-based
solution. However in most cases this overhead should be
absolutely negligible or even be optimized away by the compiler.
It may make a difference though when compiling without any
optimizations, but this shouldn&rsquo;t matter too much in reality.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Less Intrusive Linking]]></title>
    <link href="http://jsteemann.github.io/blog/2015/05/07/less-intrusive-linking/"/>
    <updated>2015-05-07T19:52:53+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/05/07/less-intrusive-linking</id>
    <content type="html"><![CDATA[<p>A while ago our continuous integration builds on <a href="http://travis-ci.org">TravisCI</a>
began to fail seemingly randomly because the build worker was killed without
an apparent reason. Obviously the build process reached some resource limits
though we couldn&rsquo;t find any documented limit that the build obviously violated.</p>

<p>Some builds still succeeded without issues, but those builds that were killed
had one thing in common: they were all stuck waiting the linker to finish.</p>

<p>The default linker used on TravisCI is <em>GNU ld</em>. After some research, it turned
out that replacing <em>GNU ld</em> with <em>GNU gold</em> not only made the linking much
faster, but also less resource-intensive. Linking ArangoDB on my local machine
is almost twice as fast with <em>gold</em> as with <em>ld</em>. Even better, after reconfiguring
our TravisCI builds to also use <em>gold</em>, our builds weren&rsquo;t killed anymore by
TravisCI&rsquo;s build scheduling system.</p>

<p>To make TravisCI use <em>gold</em> instead of <em>ld</em>, add the following to your project&rsquo;s
<code>.travis.yml</code> in the <code>install</code> section (so it gets execute before the actual build
steps):</p>

<p><code>bash commands for wrapping gold
sudo apt-get -y install binutils-gold
mkdir -p ~/bin/gold
echo '#!/bin/bash' &gt; ~/bin/gold/ld
echo 'gold "$@"' &gt;&gt; ~/bin/gold/ld
chmod a+x ~/bin/gold/ld
export CFLAGS="-B$HOME/bin/gold $CFLAGS"
export CXXFLAGS="-B$HOME/bin/gold $CXXFLAGS"
</code></p>

<p>The script downloads and installs <em>gold</em> and creates a tiny wrapper script in a
file named <code>ld</code> in the user&rsquo;s home directory. The wrapper simply calls <em>gold</em>
with all the arguments passed to the wrapper. Finally, the script modifies the
environments <code>CFLAGS</code> and <code>CXXFLAGS</code> by setting the <code>-B</code> parameter to the
wrapper script&rsquo;s directory.</p>

<p><code>-B</code> is the option for the compiler&rsquo;s search path. The compiler (g++) at least
will look in this path for any helper tools it invokes. As we have a file named
<code>ld</code> in this directory, g++ will use our wrapper script instead of the original
<code>ld</code> binary. This way we can keep the original version of <code>ld</code> in <code>/usr/bin</code>,
and only override it using environment variables. This is also helpful in
other contexts, e.g. when <code>ld</code> shall remain as the system&rsquo;s default linker but
<code>gold</code>shall only be used for linking a few selected components.</p>
]]></content>
  </entry>
  
</feed>
