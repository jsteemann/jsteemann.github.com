<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ArangoShell | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/arangoshell/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2016-06-03T00:48:00+02:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Killing a Long-running Query]]></title>
    <link href="http://jsteemann.github.io/blog/2016/01/26/killing-a-long-running-query/"/>
    <updated>2016-01-26T23:13:33+01:00</updated>
    <id>http://jsteemann.github.io/blog/2016/01/26/killing-a-long-running-query</id>
    <content type="html"><![CDATA[<p>Suppose there is an AQL query that&rsquo;s executing in the server
for a long time already and you want to get rid of it. What can
be done to abort that query?</p>

<p>If a connection to the server can still be established, the easiest
is to use the ArangoShell to fetch the list of currently executing
AQL queries and send a <em>kill</em> command to the server for the correct query.</p>

<!-- more -->


<p>To start, we can fetch the list of all running queries and print
their ids, query strings and runtimes. This is only inspection and does
not abort any query:</p>

<p><code>js printing all currently running queries
var queries = require("org/arangodb/aql/queries");
queries.current();
</code></p>

<p>Here&rsquo;s an example result for the list of running queries:</p>

<p>```json example list of currently running queries
[
  {</p>

<pre><code>"id" : "190", 
"query" : "RETURN SLEEP(1000)", 
"started" : "2016-01-26T22:41:24Z", 
"runTime" : 218.49146389961243 
</code></pre>

<p>  }
]
```</p>

<p>To now kill a query from the list, we can pass the query&rsquo;s id to <em>kill</em>:</p>

<p><code>js killing a specific query
var queries = require("org/arangodb/aql/queries");
queries.kill("190");  /* insert actual query id here */
</code></p>

<p>If a query was actually killed on the server, that call should return without
an error, and the server should have logged a warning in addition.</p>

<p>If we wanted to abort one or many queries from the list solely by
looking at query string patterns or query runtime, we could iterate
over the list of current queries and kill each one that matches
a predicate.</p>

<p>For example, the following snippet will abort all currently running
queries that contain the string <code>SLEEP</code> anywhere inside their query string:</p>

<p>```js aborting all queries containing the word SLEEP inside the query string
var queries = require(&ldquo;org/arangodb/aql/queries&rdquo;);</p>

<p>queries.current().filter(function(query) {
  return query.query.match(/SLEEP/);  /<em> predicate based on query string </em>/
}).forEach(function(query) {
  print(&ldquo;killing query: &rdquo;, query);    /<em> print what we&rsquo;re killing </em>/
  queries.kill(query.id);             /<em> actually kill query </em>/
});
```</p>

<p>Filtering based on current query runtime is also simple, by adjusting the
predicate. To abort all queries that ran longer than 30 seconds use:</p>

<p>```js aborting all queries running at least 30 seconds
var queries = require(&ldquo;org/arangodb/aql/queries&rdquo;);</p>

<p>queries.current().filter(function(query) {
  return query.runTime > 30;          /<em> predicate based on query runtime </em>/
}).forEach(function(query) {
  print(&ldquo;killing query: &rdquo;, query);    /<em> print what we&rsquo;re killing </em>/
  queries.kill(query.id);             /<em> actually kill query </em>/
});
```</p>

<p>Please make sure the predicates are correct so only the actually intended
queries get aborted!</p>

<p>To test a predicate without killing a query, use the above code without the
<code>forEach</code> part that did the killing.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Small Things in 2.8: Collection Type for Arangoimp]]></title>
    <link href="http://jsteemann.github.io/blog/2016/01/26/small-things-in-28-arangoimp-collection-type/"/>
    <updated>2016-01-26T21:59:17+01:00</updated>
    <id>http://jsteemann.github.io/blog/2016/01/26/small-things-in-28-arangoimp-collection-type</id>
    <content type="html"><![CDATA[<p>When trying to import data into ArangoDB from a JSON or CSV file using the
<em>arangoimp</em> binary, there is always the chance that the target collection does
not yet exist.</p>

<p>In order to create a missing target collection <em>arangoimp</em> for long has
provided the option <code>--create-collection true</code>:</p>

<p><code>bash importing, optionally creating a missing collection
arangoimp                       \
  --file users.json             \
  --collection users            \
  --create-collection true
</code></p>

<p>However there hasn&rsquo;t been a way of specifying the <strong>type</strong> for the target collection,
so the new collection was always created as <em>document</em> collection.</p>

<p>To import data into an <em>edge</em> collection, the target collection needed to be created
by another means, e.g. by using the ArangoShell. It would have been more handy if
<em>arangoimp</em> were able to create <em>edge</em> collections too.</p>

<p>2.8 finally adds that feature, and it&rsquo;s simple to use: to create an <em>edge</em> collection
if the target collection does not exist, append the <code>--create-collection-type edge</code>
option when invoking <em>arangoimp</em>:</p>

<p><code>bash importing, optionally creating a missing edge collection
arangoimp                       \
  --file users.json             \
  --collection users            \
  --create-collection true      \
  --create-collection-type edge
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Improved Deadlock Detection]]></title>
    <link href="http://jsteemann.github.io/blog/2015/11/18/improved-deadlock-detection/"/>
    <updated>2015-11-18T19:24:24+01:00</updated>
    <id>http://jsteemann.github.io/blog/2015/11/18/improved-deadlock-detection</id>
    <content type="html"><![CDATA[<p>The upcoming ArangoDB version 2.8 (currently in devel) will
provide a much better deadlock detection mechanism than its
predecessors.</p>

<p>The new deadlock detection mechanism will kick in automatically
when it detects operations that are mutually waiting for each other.
In case it finds such deadlock, it will abort one of the operations
so that the others can continue and overall progress can be made.</p>

<!-- more -->


<p>In previous versions of ArangoDB, deadlocks could make operations
wait forever, requiring the server to be stopped and restarted.</p>

<h2>How deadlocks can occur</h2>

<p>Here&rsquo;s a simple example for getting into a deadlock state:</p>

<p>Transaction A wants to write to collection c1 and to read from collection
c2. In parallel, transaction B wants to write to collection c2 and read
from collection c1. If the sequence of operations is interleaved as follows,
then the two transactions prevent each other from making progress:</p>

<ul>
<li>transaction A successfully acquires write-lock on c1</li>
<li>transaction B sucessfull acquires write-lock on c2</li>
<li>transaction A tries to acquire read-lock on c2 (and must wait for B)</li>
<li>transaction B tries to acquire read-lock on c1 (and must wait for A)</li>
</ul>


<p>Here&rsquo;s these such two transactions being started from two ArangoShell
instances in parallel (left is A, right is B):</p>

<p><img src="/downloads/screenshots/deadlock.png"></p>

<p>(note that this screenshot is from 2.8 and the automatic deadlock detection
had already detected the deadlock and aborted one of the transactions)</p>

<p>In general, deadlocks can occur only when multiple operations (AQL
queries or other transactions) try to access the same resources
(collections) at the same time, and only if the operations already
have already acquired some locks on these resources. And finally
each operation needs to involve more than one collection, so there
is the potential for already having acquired some locks but having
to wait for others.</p>

<h2>Dynamically added collections</h2>

<p>Most operations will just work fine and will not cause any deadlocks.
This is especially true for all operations that involve only a single
collection. This leaves multi-collection AQL queries and multi-collection
userland transactions.</p>

<p>Normally these will also work fine. This is because when a query or
transaction starts, it will tell the transaction manager about the resources
(collections) it will need. The transaction manager can then acquire the
required resources in a deterministic fashion that prevents deadlocks.
If all queries and transactions properly announce upfront which collections
they will access, there will also be no deadlocks.</p>

<p>But for some operations its hard to predict at transaction start which
collections will be accessed. This includes some AQL functions that
can dynamically access collection data without having to specify the
collection name anywhere in the query.</p>

<p>A good example for this is the <code>GRAPH_EDGES</code> AQL function, which will get
a graph name as its first input parameter, but not the names of the underlying
edge collection(s). When this function is used in an AQL query, the
query parser will just find a function parameter containing a graph name
but doesn&rsquo;t know it&rsquo;s a collection name.</p>

<p><code>
GRAPH_EDGES("myEdges", [ { type: "friend" } ])
</code></p>

<p>The <code>"myEdges"</code> graph name will look like any other string to the parser.
It does not know about the contexts in which strings may have special meanings.</p>

<p>Note that even if this would be fixed, the problem won&rsquo;t go away entirely:
a function call parameter in a query isn&rsquo;t necessarily a constant but can
be an arbitrary expression:</p>

<p><code>
FOR doc IN collection
  RETURN GRAPH_EDGES(CONCAT(doc.graphName, '-test'), [ doc.example ])
</code></p>

<p>At least in this case the AQL query parser won&rsquo;t find a collection name,
so when the AQL query starts it is yet unknown which collections will be
accessed. Only at runtime when the function is actually executed, the
collection names will be looked up by finding the graph description in the
<code>_graphs</code>system collection. Then the edge collections participating in
the graph will be added to the query dynamically. Only this dynamic addition
adds the potential for deadlock.</p>

<p>This dynamic addition of collections in unavoidable for conveniently
querying data from collections whose names are unknown when the query starts.</p>

<h2>Deadlock detection</h2>

<p>Whenever transaction manager detects a deadlock in ArangoDB 2.8, it will
automatically abort one of the blocking transactions. The transaction will
be rolled back and all modifications it has made will be reverted. The
operation will fail with error code 29 (<em>deadlock detected</em>) and raise an
exception that the user can handle in the calling code.</p>

<p>Deadlocks will be found if two transactions mutually lock each other as
seen in the screenshot above, but also for more complex setups. The following
screenshot shows four parallel transactions that block each other indirectly.</p>

<p><img src="/downloads/screenshots/threeway-deadlock.png"></p>

<p>The top left window (transaction 1) will block the one in the top right
(transaction 2), and is itself blocked by the transaction in the bottom left
(transaction 3).</p>

<p>The transaction in the top right window (transaction 2) blocks the one in the
bottom left (transaction 3), and is itself blocked by the one in the top left
(transaction 1).</p>

<p>Transaction 3 (bottom left) is blocked by transaction 2 (top right).
Transaction 4 (bottom right) does exactly the same as transaction 3.</p>

<p>With these transactions, we end up in this waiting state:</p>

<ul>
<li>T1 waits for T3 and T4</li>
<li>T2 waits for T1</li>
<li>T3 waits for T2</li>
<li>T4 waits for T2</li>
</ul>


<p>This waiting state is cyclic (T1 &lt; T3 &lt; T2 &lt; T1) and therefore no progress
can be made. This is exactly a situation in which the transaction manager
will abort one of the transactions.</p>

<p>No configuration is required for the deadlock detection mechanism. It will
always be active and cannot be configured or turned off.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On Building AQL Query Strings]]></title>
    <link href="http://jsteemann.github.io/blog/2015/08/30/on-building-aql-query-strings/"/>
    <updated>2015-08-30T23:14:42+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/08/30/on-building-aql-query-strings</id>
    <content type="html"><![CDATA[<p>I recently wrote two recipes about generating AQL query
strings. They are contained in the ArangoDB cookbook by now:</p>

<ul>
<li><a href="https://docs.arangodb.com/cookbook/AvoidingInjection.html">Avoiding parameter injection in AQL</a></li>
<li><a href="https://docs.arangodb.com/cookbook/MultilineQueryStrings.html">Writing multi-line AQL queries</a></li>
</ul>


<p>After that, Github user <em>tracker1</em> suggested in <a href="https://github.com/arangodb/arangodb/issues/1457">Github issue 1457</a>
to take the ES6 template string variant even further, using a generator function for
string building, and also using promises and ES7 async/await.</p>

<p>We can&rsquo;t use ES7 async/await in ArangoDB at the moment due to lacking support
in V8, but the suggested template string generator function seemed to be an
obvious improvement that deserved inclusion in ArangoDB.</p>

<!-- more -->


<p>Basically, the suggestion is to use regular JavaScript variables/expressions in
the template string and have them substituted <em>safely</em>.</p>

<p>With regular AQL bind parameters, a query looks like this:</p>

<p><code>``js
var bindVars = { name: "test" };
var query =</code>FOR doc IN collection</p>

<pre><code>         FILTER doc.name == @name 
         RETURN doc._key`;
</code></pre>

<p>db._query(query, bindVars);
```</p>

<p>This is immune to parameter injection, because the query string and the bind parameter
value are passed in separately. But it&rsquo;s <strong>not very ES6-y</strong>.</p>

<p>Now, after partly implementing <em>tracker1</em>&rsquo;s suggestion, JavaScript values
and expressions can be used much more <em>naturally</em> when building AQL query strings:</p>

<p><code>``js
var name = "test";
var query = aqlQuery</code>FOR doc IN collection</p>

<pre><code>                 FILTER doc.name == ${name} 
                 RETURN doc._key`;
</code></pre>

<p>db._query(query);
```</p>

<p><code>${name}</code> is regular ES template string syntax and would normally be substituted
with the value of JavaScript variable <code>name</code>. Such simple substitution would be unsafe,
because it would make the query vulnerable to parameter injection. So we&rsquo;re also
using a template string generator function named <code>aqlQuery</code>. This function comes
bundled with ArangoDB 2.7.</p>

<p>Under the hood, <code>aqlQuery</code> will create regular AQL bind parameters for each occurrence
of a template string parameter. It will keep the query string and the actual bind
parameter values separate, so it is safe to use.</p>

<p>The function will return an object with that can directly be passed on to the
<code>db._query()</code> function. Here&rsquo;s what <code>aqlQuery</code> will generate for the above example
(note: some whitespace was removed from the output):</p>

<p>```js
{
  &ldquo;query&rdquo; : &ldquo;FOR doc IN collection FILTER doc.name == @value0 RETURN doc._key&rdquo;,
  &ldquo;bindVars&rdquo; : {</p>

<pre><code>"value0" : "test" 
</code></pre>

<p>  }
}
```</p>

<p>The <code>aqlQuery</code> template string generator function is available in 2.7, which is
currently in development. The changes are contained in the <code>devel</code> branch only
at the moment, but will become available in following 2.7 release. A pull request
has been issued to have the cookbook recipes updated to include <code>aqlQuery</code>, too.</p>

<p><code>aqlQuery</code> can be used in 2.7 from the ArangoShell, inside arangod (e.g. from inside
Foxx actions) and from ArangoDB&rsquo;s web interface.</p>

<p>All other variants for building AQL queries are still fully supported.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How V8 Is Used in ArangoDB]]></title>
    <link href="http://jsteemann.github.io/blog/2015/08/01/how-v8-is-used-in-arangodb/"/>
    <updated>2015-08-01T19:06:04+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/08/01/how-v8-is-used-in-arangodb</id>
    <content type="html"><![CDATA[<p>ArangoDB allows running user-defined JavaScript code in the database.
This can be used for more complex, <em>stored procedures</em>-like database operations.
Additionally, ArangoDB&rsquo;s <a href="https://www.arangodb.com/foxx/">Foxx framework</a> can
be used to make any database functionality available via an HTTP REST API.
It&rsquo;s easy to build microservices with it, using the scripting functionality
for tasks like access control, data validation, sanitation etc.</p>

<p>We often get asked how the scripting functionality is implemented under the hood.
Additionally, several people have asked how ArangoDB&rsquo;s JavaScript functionality
relates to node.js.</p>

<p>This post tries to explain that in detail.</p>

<!-- more -->


<h1>The C++ parts</h1>

<p><em>arangosh</em>, the ArangoShell, and <em>arangod</em>, the database server, are written in
C++ and they are shipped as native code executables. Some parts of both <em>arangosh</em>
and <em>arangod</em> itself are written in JavaScript (more on that later).</p>

<p>The I/O handling in <em>arangod</em> is written in C++ and uses libev (written in C)
for the low-level event handling. All the socket I/O, working scheduling and
queueing is written in C++, too. These are parts that require high parallelism,
so we want this to run in multiple threads.</p>

<p>All the indexes, the persistence layer and many of the fundamental operations,
like the ones for document inserts, updates, deletes, imports are written in C++ for
effective control of memory usage and parallelism. AQL&rsquo;s query parser is written
using the usual combination of Flex and Bison, which generate C files that are
compiled to native code. The AQL optimizer, AQL executor and many AQL functions are
writting in C++ as well.</p>

<p>Some AQL functions however, are written in JavaScript. And if an AQL query
invokes a user-defined function, this function will be a JavaScript function, too.</p>

<h1>How ArangoDB uses V8</h1>

<p>How is JavaScript code executed in ArangoDB?</p>

<p>Both <em>arangosh</em> and <em>arangod</em> are linked against the <a href="https://developers.google.com/v8/">V8 JavaScript engine</a>
library. V8 (itself written in C++) is the component that runs the JavaScript
code in ArangoDB.</p>

<p>V8 requires JavaScript code to run in a so-called <em>isolate</em> (note: I&rsquo;ll be
oversimplifying a bit here &ndash; in reality there are isolates and contexts).
As the name suggests, isolates are completely isolated from each other.
Especially, data cannot be shared or moved across isolates, and each isolate
can be used by only one thread at a time.</p>

<p>Let&rsquo;s look at how <em>arangosh</em>, the ArangoShell, uses V8. All JavaScript commands
entered in <em>arangosh</em> will be compiled and executing with V8 immediately.
In <em>arangosh</em>, this happens using a single V8 isolate.</p>

<p>On the server side, things are a bit different. In <em>arangod</em>, there are multiple
V8 isolates. The number of isolates to create is a startup configuration
option (<code>--javascript.v8-contexts</code>). Creating multiple isolates allows running
JavaScript code in multiple threads, truly parallel. Apart from that, <em>arangod</em>
has multiple I/O threads (<code>--scheduler.threads</code> configuration option) for handling
the communication with client applications.</p>

<p>As mentioned earlier, part of ArangoDB&rsquo;s codebase itself is written in JavaScript,
and this JavaScript code is executed the same way as any user-defined will be executed.</p>

<h1>Executing JavaScript code with V8</h1>

<p>For executing any JavaScript code (built-in or user-defined), ArangoDB will invoke
V8&rsquo;s JIT compiler to compile the script code into native code and run it.</p>

<p>The JIT compiler in V8 will not try extremely hard to optimize the code on the
first invocation. On initial compilation, it will aim for a good balance of
optimizations and fast compilation time. If it finds some code parts are called
often, it may re-try to optimize these parts more aggressively automatically.
To make things even more complex, there are different JIT compilers in V8
(i.e. Crankshaft and Turbofan) with different sweet spots. JavaScript modes
(i.e. <em>strict mode</em> and <em>strong mode</em>) can also affect the level of optimizations
the compilers will carry out.</p>

<p>Now, after the JavaScript code has been compiled to native code, V8 will run it
until it returns or fails with an uncaught exception.</p>

<p>But how can the JavaScript code access the database data and server internals?
In other words, what actually happens if a JavaScript command such as the following
is executed?</p>

<p><code>js example JavaScript command
db.myCollection.save({ _key: "test" });
</code></p>

<h2>Accessing server internals from JavaScript</h2>

<p>Inside <em>arangod</em>, each V8 isolate is equipped with a global variable named <code>db</code>.
This JavaScript variable is a wrapper around database functionality written in C++.
When the <code>db</code> object is created, we tell V8 that its methods are C++ callbacks.</p>

<p>Whenever the <code>db</code> object is accessed in JavaScript, the V8 engine will therefore
call C++ methods. These provide full access to the server internals, can do whatever
is required and return data in the format that V8 requires. V8 then makes the
return data accessible to the JavaScript code.</p>

<p>Executing <code>db.myCollection.save(...)</code> is effectively two operations: accessing the
property <code>myCollection</code> on the object <code>db</code> and then calling function <code>save</code> on that
property. For the first operation, V8 will invoke the object&rsquo;s <code>NamedPropertyHandler</code>,
which is a C++ function that is responsible for returning the value for the property
with the given name (<code>myCollection</code>). In the case of <code>db</code>, we have a C++ function
that collection object if it exists, or <code>undefined</code> if not.</p>

<p>The collection object again has C++ bindings in the background, so calling function
<code>save</code> on it will call another C++ function. The collection object also has a (hidden)
pointer to the C++ collection. When <code>save</code> is called, we will extract that pointer
from the <code>this</code> object so we know which C++ data structures to work on. The <code>save</code>
function will also get the to-be-inserted document data as its payload. V8 will
pass this to the C++ function as well so we can validate it and convert it into
our internal data format.</p>

<p>On the server side, there are several objects exposed to JavaScript that have C++
bindings. There are also non-object functions that have C++ bindings. Some of these
functions are also bolted on regular JavaScript objects.</p>

<h2>Accessing server internals from ArangoShell</h2>

<p>When running the same command in <em>arangosh</em>, things will be completely different.
The ArangoShell may run on the same host as the <em>arangod</em> server process, but it may
also run on a completely different one. Providing <em>arangosh</em> access to server internals
such as pointers will therefore not work in general. Even if <em>arangosh</em> and <em>arangod</em>
do run on the same host, they are independent processes with no access to the each
other&rsquo;s data. The latter problem could be solved by having a shared memory segment
that both <em>arangosh</em> and <em>arangod</em> can use, but why bother with that special case
which will provide no help in the general case when the shell can be located on
<strong>any</strong> host.</p>

<p>To make the shell work in all these situations, it uses the HTTP REST API provided
by the ArangoDB server to talk to it. For <em>arangod</em>, any ArangoShell client is just
another client, with no special treatments or protocols.</p>

<p>As a consequence, all operations on databases and collections run from the ArangoShell
are JavaScript wrappers that call their respective server-side HTTP APIs.</p>

<p>Recalling the command example again (<code>db.myCollection.save(...)</code>), the shell will first
access the property <code>myCollection</code> of the object <code>db</code>. In the shell <code>db</code> is a regular
JavaScript object with no C++ bindings. When the shell is started, it will make an
HTTP call to <em>arangod</em> to retrieve a list of all available collections, and register
them as properties in its <code>db</code> object. Calling the <code>save</code> method on one of these
objects will trigger an HTTP POST request to the server API at <code>/_api/document?collection=myCollection</code>,
with the to-be-inserted data in its request body. Eventually the server will respond
and the command will return with the data retrieved from the server.</p>

<h2>Considerations</h2>

<p>Consider running the following JavaScript code:</p>

<p><code>js code to insert 1000 documents
for (var i = 0; i &lt; 1000; ++i) {
  db.myCollection.save({ _key: "test" + i });
}
</code></p>

<p>When run from inside the ArangoShell, the code will be executed in there. The shell will
perform an HTTP request to <em>arangod</em> for each call to <code>save</code>. We&rsquo;ll end up with 1,000
HTTP requests.</p>

<p>Running the same code inside <em>arangod</em> will trigger no HTTP requests, as the server-side
functions are backed with C++ internals and can access the database data directly. It will
be a lot faster to run this loop on the server than in <em>arangosh</em>. A while ago I wrote
<a href="/blog/2014/08/30/understanding-where-operations-are-executed/">another article</a> about this.</p>

<p>When replacing the ArangoShell with another client application, things are no different.
A client application will not have access to the server internals, so all it can do is to
make requests to the server (by the way, the principle would be no different if we used
MySQL or other database servers, only the protocols would vary).</p>

<p>Fortunately, there is a fix for this: making the code run server-side. For example, the
above code can be put into a Foxx route. This way it is not only fast but will be made
accessible via an HTTP REST API so client applications can call it with a single HTTP request.</p>

<p>In reality, database operations will be more complex than in the above example. And this
is where having a full-featured scripting language like JavaScript helps. It provides all
the features that are needed for more complex tasks such as validating and sanitizing input
data, access control, executing database queries and postprocessing results.</p>

<h1>The differences to node.js</h1>

<p>To start with: ArangoDB is not node.js, and vice versa. ArangoDB is not a node.js module
either. ArangoDB and node.js are completely indepedent.</p>

<p>But there is a commonality: both ArangoDB and node.js use the V8 engine for running
JavaScript code.</p>

<h2>Threading</h2>

<p>AFAIK, standard node.js only has a single V8 isolate to run all code in.
While that made the implementation easier (no hassle with multi-threading) it
also limits node.js to using only a single CPU.</p>

<p>It&rsquo;s not unusual to see a multi-core server with a node.js instance maxing out
one CPU while the other CPUs are sitting idle. In order to max out a multi-core
server, people often start multiple node.js instances on a single server. That will
work fine, but the node.js instances will be independent, and sharing data between
them is not possible in plain JavaScript.</p>

<p>And because a node.js instance is single-threaded, it is also important that
code written for node.js is non-blocking. Code that blocks while waiting for
some I/O operation would block the only available CPU. Using non-blocking
I/O operations allows node.js to queue the operation, and execute other code
in the meantime, allowing overall progress. This also makes it look like it
would be executing multiple actions in parallel, while it is actually executing
them sequentially.</p>

<p>Contrary, <em>arangod</em> is a multi-threaded server. It can serve multiple requests in
parallel, using multiple CPUs. Because <em>arangod</em> has multiple V8 isolates that
each can execute JavaScript code, it can run JavaScript in multiple threads in parallel.</p>

<p><em>arangosh</em>, the ArangoShell, is single-threaded and provides only a single V8 isolate.</p>

<h2>Usage of modules</h2>

<p>Both node.js and ArangoDB can load code at runtime so it can be organized into
modules or libraries. In both, extra JavaScript modules can be loaded using the
<code>require</code> function.</p>

<p>There is often confusion about whether node.js modules can be used in ArangoDB.
This is probably because the answer is &ldquo;<em>it depends!</em>&rdquo;.</p>

<p>node.js packages can be written in JavaScript but they can also compile to native
code using C++. The latter can be used to extend the functionality of node.js with
features that JavaScript alone wouldn&rsquo;t be capable of. Such modules however often
heavily depend on a specific V8 version (so do not necessarily compile in a node.js
version with a different version of V8) and often rely on node.js internals.</p>

<p>ArangoDB can load modules that are written in pure JavaScript. Modules that
depend on non-JavaScript functionality (such as native modules for node.js) or modules
that rely on node.js internals cannot be loaded in ArangoDB. As a rule of thumb,
any module will run in ArangoDB that is implemented in pure JavaScript, does not
access global variables and only requires other modules that obey the same restrictions.</p>

<p>ArangoDB also uses several externally maintained JavaScript-only libraries, such as
underscore.js. This module will run everywhere because it conforms to the mentioned
restrictions.</p>

<p>ArangoDB also uses several other modules that are maintained on npm.js.
An example module is <a href="https://www.npmjs.com/package/aqb">AQB</a>, a query builder for AQL.
It is written in pure JavaScript too, so it can be used from a node.js application and
from within ArangoDB. If there is an updated version of this module, we use npm to
install it in a subdirectory of ArangoDB. As per npm convention, the node.js modules
shipped with ArangoDB reside in a directory named <code>node_modules</code>. Probably this is
what caused some of the confusion.</p>
]]></content>
  </entry>
  
</feed>
