<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ArangoShell | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/arangoshell/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2015-01-14T01:39:31+01:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using ES6 Features in ArangoDB]]></title>
    <link href="http://jsteemann.github.io/blog/2014/12/19/using-es6-features-in-arangodb/"/>
    <updated>2014-12-19T19:12:06+01:00</updated>
    <id>http://jsteemann.github.io/blog/2014/12/19/using-es6-features-in-arangodb</id>
    <content type="html"><![CDATA[<p>ArangoDB 2.4 will be shipped with an <em>updated version of V8</em>.</p>

<p>The V8 version included in 2.4 will be 3.29.59. This version will replace the
almost two year old 3.16.14. A lot of things happened in V8 since then, and a lot
of ES6 features have been added to it.</p>

<p><strong>ES6 is not finalized yet</strong>, and support for it is a <a href="http://kangax.github.io/compat-table/es6/">work in progress on all
platforms</a>.</p>

<p>ES6 provides many cool features that can make JavaScript developer&rsquo;s life easier.
In this blog post, I&rsquo;ll summarize a few ES6 features that are available in
ArangoDB, either for scripting purposes in the ArangoShell, or in your server-side
Foxx actions inside the database.</p>

<p>I don&rsquo;t want to put you off until Doomsday. ArangoDB 2.4 should be released next
week. Time to play with some ES6 features!</p>

<!-- more -->


<h1>Summary for the impatient</h1>

<p>The following ES6 features are available in ArangoDB 2.4 by default:</p>

<ul>
<li>iterators</li>
<li>the <code>of</code> operator</li>
<li>symbols</li>
<li>predefined collections types (Map, Set etc.)</li>
<li>typed arrays</li>
</ul>


<p>Many other ES6 features are disabled by default, but can be made available by
starting arangod or arangosh with the appropriate options:</p>

<ul>
<li>arrow functions</li>
<li>proxies</li>
<li>generators</li>
<li>String, Array, and Number enhancements</li>
<li>constants</li>
<li>enhanced object and numeric literals</li>
</ul>


<p>To activate all these ES6 features, start arangod or arangosh with the following
options:</p>

<pre><code>arangosh --javascript.v8-options="--harmony --harmony_generators"
</code></pre>

<h1>Activating ES6 features</h1>

<p>Work on ES6, also dubbed <em>Harmony</em> or <em>ES.next</em>, is still in progress. At the time
of this writing, the ES6 specification was still in draft status.</p>

<p>Therefore no platform has implemented all ES6 features yet. And because ES6 is
still a moving target, the already implemented features should still be considered
experimental.</p>

<p>This is true for all environments that implement ES6 features. For example, Firefox
and other browsers contain lots of experimental ES6 features already, providing a
notice that these might change in future versions.</p>

<p>V8 is no exception here. It has turned most ES6 features off by default, but it
provides several command-line options to turn them on explicitly.</p>

<p>The V8 version used for ArangoDB 2.4 provides the following ES6-related switches:</p>

<ul>
<li><code>--harmony_scoping</code> (enable harmony block scoping)</li>
<li><code>--harmony_modules</code> (enable harmony modules (implies block scoping))</li>
<li><code>--harmony_proxies</code> (enable harmony proxies)</li>
<li><code>--harmony_generators</code> (enable harmony generators)</li>
<li><code>--harmony_numeric_literals</code> (enable harmony numeric literals (0o77, 0b11))</li>
<li><code>--harmony_strings</code> (enable harmony string)</li>
<li><code>--harmony_arrays</code> (enable harmony arrays)</li>
<li><code>--harmony_arrow_functions</code> (enable harmony arrow functions)</li>
<li><code>--harmony_classes</code> (enable harmony classes)</li>
<li><code>--harmony_object_literals</code> (enable harmony object literal extensions)</li>
<li><code>--harmony</code> (enable all harmony features (except proxies))</li>
</ul>


<p>These switches are all off by default. To turn on features for either arangod
or arangosh, start it with the V8 option(s) wrapped into the ArangoDB option
<code>--javascript.v8-options</code>, e.g.:</p>

<pre><code>arangosh --javascript.v8-options="--harmony_proxies --harmony_generators --harmony_array"
</code></pre>

<p>On a side note: node.js is also using V8. Turning on ES6 features in node.js almost
works the same way. Just omit the surrounding <code>--javascript.v8-options="..."</code>:</p>

<pre><code>node --harmony_proxies --harmony_generators --harmony_array
</code></pre>

<p>Note that the V8 options can only be set for the entire process (i.e. arangosh, arangod
or node.js), and not just for a specific script or application. In reality this shouldn&rsquo;t be
too problematic as the vast majority of ES6 features is downwards-compatible to ES5.1.</p>

<h1>ES6 features by example</h1>

<p>Following I have listed a few select ES6 features that are usable in ArangoDB 2.4,
in no particular order. I have omitted a few ES6 features that aren&rsquo;t supported in bundled
V8 version, and also omitted <em>classes</em> and <em>modules</em> due to lack of time.</p>

<h2>Arrow functions</h2>

<p>ES6 provides an optional arrow function syntax. The arrow function syntax is a shorthand for
writing a full-blown function declaration. Here&rsquo;s an example:</p>

<p>```js a simple arrow function
/<em> defines function pow </em>/
var pow = (value => value * value);</p>

<p>/<em> calls pow </em>/
pow(15);  /<em> 225 </em>/
```</p>

<p>Arrow functions can also take multiple parameters. The syntax then becomes:
```js arrow function with multiple parameters
/<em> defines function sum </em>/
var sum = (a, b) => a + b;</p>

<p>/<em> calls sum </em>/
sum(3, 7);  /<em> 10 </em>/
```</p>

<p>So far we have only seen arrow functions with simple expressions, but arrow function bodies
can also be more complex and can contain multiple statements:
```js more complex arrow functions
var translations = {
  &ldquo;en&rdquo; : &ldquo;English&rdquo;,
  &ldquo;fr&rdquo; : &ldquo;French&rdquo;,
  &ldquo;de&rdquo; : &ldquo;German&rdquo;
};</p>

<p>/<em> using multiple statements </em>/
[&ldquo;en&rdquo;, &ldquo;fr&rdquo;, &ldquo;xx&rdquo;].map(value => {
  if (translations.hasOwnProperty(value)) {</p>

<pre><code>return translations[value];
</code></pre>

<p>  }
  return &ldquo;unknown!&rdquo;;
});
```</p>

<p>Arrow functions are turned off by default. To enable them in arangod or arangosh, start them
with the option <code>--javascript.v8-options="--harmony_arrow_functions"</code>.</p>

<h2>Maps and sets</h2>

<p>ES6 maps provide a specialized alternative to regular objects in case a <em>lookup-by-key</em>
functionality is required.</p>

<p>When no maps are available, storing keys mapped to objects is normally done using a plain
object. With ES6, the same use case can be handled with using a <strong>Map</strong> object:
```js using an ES6 Map object
var m = new Map();</p>

<p>/<em> set 5M keys </em>/
for (var i = 0; i &lt; 5000000; ++i) {
  m.set(&ldquo;test&rdquo; + i, i);
}
```</p>

<p>ES6 maps can be more efficient than plain objects in some cases. For the above case of
storing 5M entries, an ES6 map is about twice as fast as a plain object on my laptop.
Though there might be cases we are plain objects are still faster.</p>

<p>There&rsquo;s more to ES6 Maps than just efficiency:</p>

<ul>
<li>ES6 maps provide a member <code>size</code> which keeps track of the number of objects in the map.
This is hard to achieve with a plain object.</li>
<li>Objects can only have string keys, whereas map keys can have different key types.</li>
<li>They don&rsquo;t inherit keys from the prototype, so there is no <code>hasOwnProperty</code> hassle with Maps.</li>
</ul>


<p>ES6 also comes with a specialized <strong>Set</strong> object. The Set object is a good alternative to
plain JavaScript objects when the use case is to track unique values. Using a Set is more
intuitive, potentially more efficient and may require even less memory than when implementing
the same functionality with a plain JavaScript object:</p>

<p>```js using an ES6 Set object
var s = new Set();</p>

<p>/<em> set 5M values </em>/
for (var i = 0; i &lt; 5000000; ++i) {
  s.add(&ldquo;test&rdquo; + i);
}
```</p>

<p>Maps and sets are enabled by default in arangod and arangosh. No special configuration is needed
to use them in your code.</p>

<h2>Proxy objects</h2>

<p>Proxy objects can be used to intercept object property accesses at runtime. This can be used
for meta-programming in many real-world situations, e.g.:</p>

<ul>
<li>preventing, auditing and logging property accesses</li>
<li>calculated / derived properties</li>
<li>adding a compatibility layer on top of an object</li>
</ul>


<p>Here&rsquo;s an example that logs property accesses on the proxied object:
```js using a Proxy object
var proxy = Proxy.create({
  get: function (obj, name) {</p>

<pre><code>console.log("read-accessing property '%s'", name);
</code></pre>

<p>  },
  set: function (obj, name) {</p>

<pre><code>console.log("write-accessing property '%s'", name);
</code></pre>

<p>  }
});</p>

<p>proxy.foo = &ldquo;bar&rdquo;;   /<em> write-accessing property &lsquo;foo&rsquo; </em>/
proxy.foo;           /<em> read-accessing property &lsquo;foo&rsquo; </em>/
```</p>

<p>Proxy objects are not available by default. To enable them in arangod or arangosh, start them
with the option <code>--javascript.v8-options="--harmony_proxies"</code>.</p>

<h2>Iterators and generators</h2>

<p>ES6 provides generators and iterators. They can be used individually or in combination.</p>

<p>Let&rsquo;s start with a simple example of a generator that will generate only two values:
```js a simple generator that generates two values
function* generate () {
  yield 23;
  yield 42;
}</p>

<p>var generator = generate();
console.log(generator.next());  /<em> { &ldquo;value&rdquo; : 23, &ldquo;done&rdquo; : false } </em>/
console.log(generator.next());  /<em> { &ldquo;value&rdquo; : 42, &ldquo;done&rdquo; : false } </em>/
console.log(generator.next());  /<em> { &ldquo;value&rdquo; : undefined, &ldquo;done&rdquo; : true } </em>/
<code>``
As can be seen above, the value yielded by the generator function will be returned
wrapped into an object with a</code>value<code>and a</code>done` attribute automatically.</p>

<p>The general pattern to consume all values from a generator function is to call
its <code>next()</code> method until its <code>done</code> value is <code>true</code>:
```js consuming all values from a generator function
var generator = generate();</p>

<p>while (true) {
  value = generator.next();
  if (value.done) {</p>

<pre><code>break;
</code></pre>

<p>  }
  console.log(value.value);
}
```</p>

<p>An alternative to that is to use an iterator (note the new <code>of</code> operator):
```js consuming all values from a generator function
var generator = generate();</p>

<p>for (var value of generator) {
  console.log(value);
}
```</p>

<p>Generator functions produce their values lazily. Therefore it is possible
and not inefficent to write generators that produce never-ending sequences.
Though one must be careful to abort iterating over the generator values
at some point if the sequence does not terminate:
```js a generator producing an endless sequence
function* generate () {
  var i = 0;
  while (true) {</p>

<pre><code>yield ++i;
</code></pre>

<p>  }
}</p>

<p>var generator = generate();</p>

<p>/<em> note: this will not terminate </em>/
for (var value of generator) {
  console.log(value);
}
```</p>

<p>We have now seen two uses of iterators as part of the previous examples.
As demoed, generator function values can be iterated with the <code>of</code> operator
without any further ado. Apart from generators, a few other built-in types
also provide ready-to-use iterators. The most prominent are <code>String</code> and <code>Array</code>:
```js iterating over the characters of a string
var text = &ldquo;this is a test string&rdquo;;</p>

<p>for (var value of text) {
  console.log(value);
}
```
The above example will iterate all the individual characters of the string.</p>

<p>The following example iterates the values of an Array:
```js iterating over the values of an array
var values = [ &ldquo;this&rdquo;, &ldquo;is&rdquo;, &ldquo;a&rdquo;, &ldquo;test&rdquo; ];</p>

<p>for (var value of values) {
  console.log(value);
}
<code>``
This will produce</code>&ldquo;this&rdquo;<code>,</code>&ldquo;is&rdquo;<code>,</code>&ldquo;a&rdquo;<code>,</code>&ldquo;test&rdquo;<code>. This is normally what is
desired when iterating over the values of an Array. Compare this to the</code>in<code>
operator which would produce</code>0<code>,</code>1<code>,</code>2<code>and</code>3` instead.</p>

<p>Map and Set objects also implement iterators:
```js iterating over the contents of a Map
var m = new Map();</p>

<p>m.set(&ldquo;Sweden&rdquo;, &ldquo;Europe&rdquo;);
m.set(&ldquo;China&rdquo;, &ldquo;Asia&rdquo;);
m.set(&ldquo;Bolivia&rdquo;, &ldquo;South America&rdquo;);
m.set(&ldquo;Australia&rdquo;, &ldquo;Australia&rdquo;);
m.set(&ldquo;South Africa&rdquo;, &ldquo;Africa&rdquo;);</p>

<p>for (var value of m) {
  console.log(value);
}
```</p>

<p>Note that Maps also provide dedicated iterators for just their keys or
their values:
```js iterating over keys and values of a Map
for (var country of m.keys()) {
  console.log(country);
}</p>

<p>for (var continent of m.values()) {
  console.log(continent);
}
```</p>

<p>Rolling an iterator for your own object is also possible by implementing the method
<code>Symbol.iterator</code> for it:
```js creating an iterator for an object
function Sentence (text) {
  this.text = text;
}</p>

<p>/<em> create the actual iterator method </em>/
/<em> note that the iterator is a generator function here </em>/
Sentence.prototype[Symbol.iterator] = function*() {
  var regex = /\S+/g;
  var text = this.text;
  var match;
  while (match = regex.exec(text)) {</p>

<pre><code>yield match[0]; 
</code></pre>

<p>  }
};</p>

<p>var sentence = new Sentence(&ldquo;The quick brown fox jumped over the lazy dog&rdquo;);
/<em> invoke the iterator </em>/
for (var word of sentence) {
  console.log(word);
}
```</p>

<p>Generators and iterators are not available by default. To enable them in arangod
or arangosh, start them with the option <code>--javascript.v8-options="--harmony_generators"</code>.</p>

<h2>String enhancements</h2>

<p>ES6 provides the following convenience string functions:</p>

<ul>
<li>string.startsWith(what)</li>
<li>string.endsWith(what)</li>
<li>string.contains(what)</li>
<li>string.repeat(count)</li>
<li>string.normalize(method)</li>
<li>string.codePointAt(position)</li>
<li>String.fromCodePoint(codePoint)</li>
</ul>


<p>These functions are mostly self-explaining, so I won&rsquo;t explain them in more
detail here. Apart from that, these functions are turned off by default.
To enable them in arangod or arangosh, start them with the option
<code>--javascript.v8-options="--harmony_strings"</code>.</p>

<h2>Array enhancements</h2>

<p>ES6 provides the following enhancements for the <code>Array</code> object:</p>

<ul>
<li>array.find(function)</li>
<li>array.findIndex(function)</li>
<li>array.keys()</li>
<li>array.values()</li>
<li>Array.observe(what, function)</li>
</ul>


<p>Here are a few examples demoing these functions:
```js Array enhancements
var values = [ 1, 2, 9, 23, 42 ];</p>

<p>/<em> returns the first Array element for which the function returns true </em>/
values.find(function (value) {
  return value === 23;
});</p>

<p>/<em> returns the first Array index for which the function returns true </em>/
values.findIndex(function (value) {
  return value === 23;
});</p>

<p>/<em> iterate over the keys of the Array </em>/
for (var key of values.keys()) {
  console.log(key);
}</p>

<p>/<em> iterate over the values of the Array </em>/
for (var key of values.values()) {
  console.log(key);
}</p>

<p>/<em> observe all changes to an Array </em>/
Array.observe(values, function (changes) {
  console.log(changes);
});</p>

<p>/<em> trigger a change to the observed Array </em>/
values.push(117);
```</p>

<p>The Array enhancements are turned off by default. To enable them in arangod or
arangosh, start them with the option <code>--javascript.v8-options="--harmony_arrays"</code>.</p>

<h2>Number enhancements</h2>

<p>The <code>Number</code> object is extended with the following ES6 functions:</p>

<ul>
<li>Number.isInteger(value)</li>
<li>Number.isSafeInteger(value)</li>
</ul>


<p>There are also <code>Number.MIN_SAFE_INTEGER</code> and <code>Number.MAX_SAFE_INTEGER</code> so applications
can programmatically check whether a numeric value can still be stored in the range of
-2<sup>53</sup> to +2<sup>53</sup> without potential precision loss.</p>

<h2>Constants</h2>

<p>The <code>const</code> keyword can be used to define a read-only constant. The constant must be
initialized and a variable with the same name should not be redeclared in the same scope.</p>

<p>Here is an example of using <code>const</code>:
<code>js using const to create a read-only variable
function calculate (value) {
  const magicPrime = 23;
  return magicPrime ^ value;
}
</code></p>

<p>In non-strict mode, <code>const</code> variables behave non-intuitively. Re-assigning a value
to a variable declared <code>const</code> does not throw an exception, but the assignment will
not be carried out either. Instead, the assignment will silently fail and the <code>const</code>
variable will keep its original value:</p>

<p><code>js re-assigning a value to a const variable
function mystery () {
  const life = 42;
  life = 23;        /* does not change value and does not throw! */
  return life;      /* will return 42 */
}
</code></p>

<p><code>js re-assigning a value to a const variable, using strict mode
function mystery () {
  "use strict";
  const life = 42;
  life = 23;        /* will throw SyntaxError "assignment to constant variable" */
}
</code></p>

<p>The <code>const</code> keyword is disabled by default. To enable it in arangod or arangosh,
start them with the option <code>--javascript.v8-options="--harmony_scoping"</code>.</p>

<h2>Enhanced object literals</h2>

<p>ES6 provides a shorthand for defining methods in object literals.</p>

<p>The following example creates a normal method named <code>save</code> in <code>myObject</code>:</p>

<p>```js shorthand method declaration
var myObject = {
  type: &ldquo;myType&rdquo;,
  save () {</p>

<pre><code>console.log("save");
</code></pre>

<p>  }
};
```</p>

<p>Interestingly, the object literals seem to work for method declarations only.
I did not get them to work for non-method object properties, though ES6 allows that.
It seems that this is not implemented in V8 yet.</p>

<p>Enhanced object literals are turned off by default. To enable them in arangod
or arangosh, start them with the option <code>--javascript.v8-options="--harmony_object_literals"</code>.</p>

<h2>Enhanced numeric literals</h2>

<p>For the ones that love working with binary- or octal-encoded numbers, ES6 has
support for this too:
<code>js numeric literals
var life = 0b101010;          /* binary, 42 in decimal */
var filePermissions = 0o777;  /* octal, 511 in decimal */
</code></p>

<p>Enhanced numeric literals are turned off by default. To enable them in arangod
or arangosh, start them with the option <code>--javascript.v8-options="--harmony_numeric_literals"</code>.</p>

<h2>Symbols</h2>

<p>ES6 also provides a Symbol type. Symbols are created using the global <code>Symbol()</code> function.
Each time this function is called, a new Symbol object will be created.
A Symbol can be given an optional name, but this name cannot be used to identify the
Symbol later. However, Symbols can be compared by identity.</p>

<p>What one normally wants is to use the same Symbol from different program parts. In this
case, a Symbol should not be created with the <code>Symbol()</code> function, but with <code>Symbol.for()</code>.
This will register the Symbol in a global symbol table if it is not there yet, and return
the Symbol if already created:</p>

<p>```js using named Symbols
var typeAttribute = Symbol.for(&ldquo;type&rdquo;);
var carType = Symbol.for(&ldquo;car&rdquo;);
var trainType = Symbol.for(&ldquo;train&rdquo;);</p>

<p>var object1 = { };
object1[typeAttribute] = carType;</p>

<p>var object2 = { };
object2[typeAttribute] = trainType;</p>

<p>/<em> check if the objects have the same type </em>/
object1[typeAttribute] === object2[typeAttribute];  /<em> false </em>/
object1[typeAttribute] === carType;                 /<em> true </em>/
object2[typeAttribute] === carType;                 /<em> false </em>/
object2[typeAttribute] === trainType;               /<em> true </em>/
```</p>

<p>Symbol object properties are not enumerated by default, so they can be used to implement
&ldquo;hidden&rdquo; or internal properties.</p>

<p>Symbols can be used by default in arangod and arangosh. No special configuration is required.</p>

<h2>TypedArrays</h2>

<p>TypedArrays are Arrays whose members all have the same type and size. They are more
specialized (read: limited but efficient) alternatives to the all-purpose <code>Array</code> type.</p>

<p>TypedArrays look and feel a bit like C arrays, and they are often used as an Array-like
view into binary data (for which JavaScript has no native support).</p>

<p>A TypedArray is created (and all of its memory is allocated) by invoking the appropriate
TypedArray constructor:</p>

<ul>
<li>Int8Array</li>
<li>Uint8Array</li>
<li>Uint8ClampedArray</li>
<li>Int16Array</li>
<li>Uint16Array</li>
<li>Int32Array</li>
<li>Uint32Array</li>
<li>Float32Array</li>
<li>Float64Array</li>
</ul>


<p>```js using an Array of unsigned 8 bit integers
var data = new Uint8Array(2);
data[0] = 0b00010101;  /<em> 23 </em>/
data[1] = 0b00101010;  /<em> 42 </em>/</p>

<p>console.log(data[0]);  /<em> 23 </em>/
console.log(data.length * data.BYTES_PER_ELEMENT); /<em> 2 bytes </em>/
```</p>

<p>```js using an Array of 64 bit floating point values
var data = new Float64Array(2);
data[0] = 23.23;</p>

<p>console.log(data[0]);  /<em> 23.23 </em>/
console.log(data[1]);  /<em> 0.0 </em>/
console.log(data.length * data.BYTES_PER_ELEMENT); /<em> 16 bytes </em>/
```</p>

<p>TypedArrays can be used in arangod and arangosh by default. No special
configuration is required to activate them.</p>

<h2>Unsupported ES6 features</h2>

<p>As mentioned before, V8 does not yet support every proposed ES6 feature.
For example, the following ES6 features are currently missing:</p>

<ul>
<li>template strings</li>
<li>function default parameters</li>
<li>rest function parameter</li>
<li>spread operator</li>
<li>destructuring</li>
<li>array comprehension</li>
<li><code>let</code></li>
</ul>


<p>I strongly hope these features will make it into the final version of ES6 and will be
implemented by the V8 team in future versions of V8.</p>

<p>Apart from that, a lot of nice ES6 features are there already and can be used
in ArangoDB applications.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Where Operations Are Executed]]></title>
    <link href="http://jsteemann.github.io/blog/2014/08/30/understanding-where-operations-are-executed/"/>
    <updated>2014-08-30T22:38:42+02:00</updated>
    <id>http://jsteemann.github.io/blog/2014/08/30/understanding-where-operations-are-executed</id>
    <content type="html"><![CDATA[<p>I recently had to deal with some data processing operation that took
about 20 minutes to complete. When looking into this, I found that the
easiest and most beneficial change to the whole setup was to make the
operation a <em>server-side</em> operation instead of executing it <em>client-side</em>.</p>

<p>This change reduced the operation&rsquo;s total execution time to a few seconds.</p>

<!-- more -->


<p>I can&rsquo;t show the original processing task here, so I&rsquo;ll start with a
contrived example. Imagine the following <em>for</em> loop inserting 100K documents
into a collection named <code>test</code>:
<code>js inserting 100k documents
for (i = 0; i &lt; 100000; ++i) {
  db.test.save({ value: i });
}
</code>
Now we only need a client application to execute the operation. As I don&rsquo;t
have a presentable client application right now, I will use the ArangoShell as
my client application.</p>

<h2>What&rsquo;s in a for loop?</h2>

<p>Running the above <em>for</em> loop inside the ArangoShell will lead to the loop being
executed inside the <em>arangosh</em> process.</p>

<p>In order to save a document in the collection, arangosh (our client) must make a
call to the ArangoDB server. This means issuing an HTTP POST request
to the server&rsquo;s REST API at <code>/_api/document/?collection=test</code>.
The server process will receive this request, insert the document, and
respond with an HTTP status code 201 or 202 to our client.
The client will then continue the loop until all documents have been inserted.</p>

<p>Now it&rsquo;s easy to see that the simple 3-line loop will issue 100,000 HTTP requests
in total. This means lots of data being pushed through the network stack(s).
It is pretty easy to imagine that this will come at a cost.</p>

<p>If we instead execute the above loop directly inside the ArangoDB server, we
can get rid of all the network overhead. The server has no need to send HTTP
calls to itself. It can simply execute the 100K inserts and is then done.
We therefore assume the loop to run somewhat faster when executed server-side.</p>

<p>A quick test on a crap laptop produced the following execution times for running
the loops:</p>

<ul>
<li>server-side execution (arangod): 1.34 seconds</li>
<li>client-side execution (arangosh): 17.32 seconds</li>
</ul>


<p><strong>Ouch</strong>. It looks like the client-server request-response overhead matters.</p>

<p>The following sections deal with how to get rid of some or even all the
client-server ping pong.</p>

<h2>Graph traversals</h2>

<p>The above <em>for</em> loop example was contrived, but imagine running
a client-side graph traversal instead. In fact, the original problem mentioned
in the introduction has been a graph traversal.</p>

<p>The problem of a graph traversal is that is often iterative and highly
dynamic. Decisions are made during the traversal as nodes are encountered,
leading to dynamic inclusion or exclusion etc. This means that it makes sense to
process nodes and edges only when needed, at the point when they are visited.</p>

<p>Even if the client can employ some sort of caching for already visited
nodes, the client still needs to ask the server about each visited
node&rsquo;s connections at least once. Otherwise it could not follow them.</p>

<p>This normally means lots of requests and responses. Compare this to the
<em>single</em> request-response alternative in which a client kicks off a server-side
traversal, and finally receives the overal result once it is assembled.</p>

<p><strong>Conclusion</strong>: traversals on anything but very small graphs should be run server-side.
A server-side action (see below) is a good way to do this. Please note that
running a server-side traversal does not mean giving up flexibility and
control flow functionality. Server-side traversals remain highly configurable
through custom JavaScript functions that allow implementation of user-defined
business logic.</p>

<h2>AQL queries</h2>

<p>We won&rsquo;t have your application send a series of 100,000 individual
insert statements to the relational database of our choice. We already
know from the past that this is going to be rather slow, so we have
learned to avoid this. In the relational context, we rather use SQL queries
that create or modify many rows in one go, e.g. an <code>INSERT INTO ... SELECT ...</code>,
bulk inserts etc.</p>

<p>ArangoDB is no different. In general, you should try to avoid issuing lots
of individual queries to the database from a client application. Instead and if
the queries look alike, try converting multiple individual operations into a
single AQL query. This will already save a lot of network overhead.</p>

<p>AQL provides multi-document operations to insert, update, and remove data. An
overview is given <a href="http://docs.arangodb.org/Aql/DataModification.html">here</a>.</p>

<p>The above 100K inserts from the contrived example can easily be transformed
into this single AQL query:
<code>
FOR i IN 1..100000 INSERT { value: i } INTO test
</code></p>

<h2>Bulk imports</h2>

<p>For importing larger amounts of documents from files, there is the specialized
<a href="http://docs.arangodb.org/Arangoimp/README.html">arangoimp</a> import tool. It can
load data from JSON and CSV files into ArangoDB. The tool is shipped with
ArangoDB.</p>

<p>ArangoDB also provides a REST API for <a href="http://docs.arangodb.org/HttpBulkImports/README.html">bulk imports</a>
of documents.</p>

<h2>Joins</h2>

<p>A special note about <em>joins</em>: the fact that several NoSQL databases do not
provide join functionality has driven some people to emulate join functionality
on the client-side, in their applications.</p>

<p>This can be a recipe for disaster: client-side join implementation might lead
to horrendous amounts of queries that might need to be sent to the database for
fetching all the records. More than that, if data are queried individually,
the overall result may lack consistency. By the way, the same is true for
fetching referenced or linked documents.</p>

<p>ArangoDB provides join functionality via AQL queries. Additionally, AQL queries
can be used to fetch other documents with the original documents. Note that
ArangoDB has no way of defining references or links between documents, but
still AQL allows combining arbitrary documents in one query.</p>

<p>In almost all cases it make more sense to use an AQL query that performs
joins or reference-fetching server-side and close to the data than having to
deal with that on the application-side of things.</p>

<p>AQL joins are described <a href="http://docs.arangodb.org/AqlExamples/Join.html">here</a>.</p>

<h2>Server-side actions</h2>

<p>With <em>stored procedures</em>, relational databases provide another way for an
application to trigger the execution of a large amount of queries. Stored
procedures are executed server-side, too, so they allow avoiding a lot of
request-response ping pong between the application and the database, at least
for defined tasks. Additionally, stored procedures provide control flow
functionality, which can also be handy when operations depend on each other.</p>

<p>Coming back to ArangoDB: complex data-processing tasks that need to execute
multiple operations or need control flow functionality might benefit if
converted from multiple application-side operations into a single server-side
action.</p>

<p>Server-side actions run inside the ArangoDB server, closer to the data, and
can be much faster than a series of client-side operations.
A server-side action is called with just one HTTP request from the application,
so it may lead to saving lots of request-response cycles and reduction in
network overhead. Apart from that, server-side actions in ArangoDB can employ
transactions and provide the necessary control over isolation and atomicity
when executing a series of operations.</p>

<p>Business logic and control flow functionality can be integrated
easily because server-side actions in ArangoDB are JavaScript functions,
with all of the language&rsquo;s programming features being available.</p>

<p>But there&rsquo;s even more to it: a single server-side operation can be written
to put together its result in a format most convenient for the client
application. This can also lead to better encapsulation, because all an
application needs to know about a server-side action is its API or contract.
Any internals of the action can be hidden from the client application. Overall,
this supports a service-oriented approach.</p>

<p>To learn more about how to write server-side actions, please have a look
at ArangoDB&rsquo;s <a href="http://docs.arangodb.org/Foxx/README.html">Foxx</a>. It is all
about making server-side actions available via REST APIs.</p>
]]></content>
  </entry>
  
</feed>
