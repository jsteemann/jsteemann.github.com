<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ArangoShell | J@ArangoDB]]></title>
  <link href="http://jsteemann.github.io/blog/categories/arangoshell/atom.xml" rel="self"/>
  <link href="http://jsteemann.github.io/"/>
  <updated>2015-07-14T22:32:53+02:00</updated>
  <id>http://jsteemann.github.io/</id>
  <author>
    <name><![CDATA[jsteemann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ES6 Features in ArangoDB 2.7]]></title>
    <link href="http://jsteemann.github.io/blog/2015/07/14/es6-features-in-arangodb-27/"/>
    <updated>2015-07-14T20:33:55+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/07/14/es6-features-in-arangodb-27</id>
    <content type="html"><![CDATA[<p>ArangoDB 2.6 uses V8 engine version 3.31.74.1 for running its own and all user-defined
JavaScript code. In ArangoDB 2.7 (currently in development), we have upgraded V8 to
version 4.3.61.</p>

<p>The new V8 version in ArangoDB 2.7 provides several additional ES6 features that can
be used to improve JavaScript usability and code quality. This blog post showcases <em>strong
mode</em> and <em>rest parameters</em>, and also shows how to activate <em>TurboFan</em>, V8&rsquo;s new JIT compiler
for JavaScript.</p>

<p>ArangoDB 2.7 is in development right now, but it can be tried today by
<a href="/blog/2014/10/16/how-to-compile-arangodb-from-source/">compiling it from source</a>.</p>

<!-- more -->


<h2>JavaScript strong mode</h2>

<p>V8 v4 comes with an optional and experimental <em>strong mode</em>. This mode provides only a
subset of JavaScript, with the idea of intentionally deactivating some of
<a href="http://archive.oreilly.com/pub/a/javascript/excerpts/javascript-good-parts/bad-parts.html">JavaScript&rsquo;s bad parts</a>.
It is based on <em>strict mode</em>, but goes further.</p>

<p>Committing to <em>strong mode</em> may not only provide better and stronger semantics, but may
also enable more optimization opportunities for the JavaScript compiler. For example, the
strong mode disables JavaScript&rsquo;s <em>with</em> statement and <code>delete</code>! Additionally, <code>var</code> cannot
be used anymore but is deprecated in favor of <code>let</code> and <code>const</code>.</p>

<p>The proposal for the strong mode can be found
<a href="https://docs.google.com/document/d/1Qk0qC4s_XNCLemj42FqfsRLp49nDQMZ1y7fwf5YjaI4/view">here</a>,
and the V8 team also has a <a href="https://developers.google.com/v8/experiments">page about it</a>.</p>

<p>Strong mode must be turned on explicitly. This can be done by adding the <code>--strong-mode=true</code>
v8 option when starting <em>arangod</em> or <em>arangosh</em>:</p>

<p><code>bash enabling strong mode
arangosh  --javascript.v8-options="--strong_mode=true"
</code></p>

<p>Note that I am using <em>arangosh</em> above, but the same would work for <em>arangod</em>, too, so the feature
can be used for Foxx routes as well.</p>

<h2>Rest parameters</h2>

<p>How to pass a variable number of arguments to a function?</p>

<p>C and C++ programmers have been using and abusing the ellipsis (<code>...</code>) and <code>__VA_ARGS__</code> features
of the C preprocessor for a long time. Then came the macros of <code>stdarg.h</code> / <code>cstdarg</code>,
until C++11 really improved the situation with <code>std::initializer_list</code> and variadic templates.</p>

<p>In JavaScript, one can use the <code>arguments</code> object:
```js
function logSimple () {
  for (value of arguments) {</p>

<pre><code>console.log(value);
</code></pre>

<p>  }
}</p>

<p>logSimple(&ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;);
```</p>

<p>This does the job, and the above will print something like:
<code>plain
2015-07-14T19:01:51Z [5245] INFO foo
2015-07-14T19:01:51Z [5245] INFO bar
2015-07-14T19:01:51Z [5245] INFO baz
</code></p>

<p>This is fine as long as all arguments shall be treated the same way. But what if some
arguments have a designated meaning and should be treated specially?</p>

<p>The solution is to use <em>ES6 rest parameters</em>. The last parameter in an argument list can be
prefixed with <code>...</code> to capture any number of function parameters:</p>

<p>```js
function logWithContext (context, &hellip;values) {
  for (value of values) {</p>

<pre><code>console.log('[' + context + '] ' + value);
</code></pre>

<p>  }
}</p>

<p>logWithContext(&ldquo;es6&rdquo;, &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;);
```</p>

<p>As can be seen, the <code>logWithContext</code> function specially handles its <code>context</code> argument, while
we can still pass any number of further parameters into it. Here&rsquo;s what the above will print:</p>

<p><code>plain
2015-07-14T19:07:27Z [5245] INFO [es6]: foo
2015-07-14T19:07:27Z [5245] INFO [es6]: bar
2015-07-14T19:07:27Z [5245] INFO [es6]: baz
</code></p>

<p>Note that rest parameters cannot be used with the default configuration and must be turned on
explicitly in <em>arangosh</em> or <em>arangod</em>.</p>

<p>The startup option to turn them on is:</p>

<p><code>bash enabling rest parameters
arangosh --javascript.v8-options="--harmony_rest_parameters=true"
</code></p>

<h2>TurboFan</h2>

<p>The new V8 version comes with <em>TurboFan</em>, a new JIT compiler for JavaScript.
According to <a href="http://blog.chromium.org/2015/07/revving-up-javascript-performance-with.html">this post</a>
it is already used in Chrome for compiling certain types of JavaScript code.</p>

<p>As fas as I can see, it is turned off by default in our version of V8, and the compiler
also seems to be rather experimental. To get an idea of what it can already do and where
its limits are, it can already be tried in ArangoDB 2.7.</p>

<p>By default, it seems to be turned off. Using the following startup option, it can be turned on for
JavaScript functions with a certain name pattern (i.e. all function names starting with <em>testTurboFan</em>):</p>

<p><code>bash starting ArangoShell with TurboFan enabled
arangosh --javascript.v8-options="--turbo-filter=testTurboFan*"`
</code></p>

<p>Without turning on V8 tracing, one will not be able to tell which compiler is used to compile a
specific function. To turn it on and actually confirm V8 is using TurboFan, use these options:</p>

<p><code>bash starting ArangoShell with TurboFan and debug output
arangosh --javascript.v8-options="--always-opt --trace_opt --turbo-filter=testTurboFan*"
</code></p>

<p>This will be very verbose, but it is good to tell which internal compiler is used to compile a given
JavaScript function.</p>

<p>For example, after starting the ArangoShell with the above options, run the following test code
to see that V8 uses TurboFan for compiling the first two functions (which match the name pattern),
and Crankshaft for the third (which does not match the name pattern):</p>

<p>```js test code for invoking the TurboFan compiler
function testTurboFan1 () {
  console.log(&ldquo;turbo-fan 1&rdquo;);
}
testTurboFan1();</p>

<p>function testTurboFan2 () {
  console.log(&ldquo;turbo-fan 2&rdquo;);
}
testTurboFan2();</p>

<p>function testSomethingElse () {
  console.log(&ldquo;something else&rdquo;);
}
testSomethingElse();
```</p>

<p>Here&rsquo;s the confirmation that TurboFan is used:</p>

<p><code>plain debug output
...
[compiling method 0x31ca8804e351 &lt;JS Function testTurboFan1 (SharedFunctionInfo 0x31ca8804e171)&gt; using TurboFan]
...
[compiling method 0x31ca8804e7f9 &lt;JS Function testTurboFan2 (SharedFunctionInfo 0x31ca8804e619)&gt; using TurboFan]
...
[compiling method 0x31ca8804ec71 &lt;JS Function testSomethingElse (SharedFunctionInfo 0x31ca8804ea91)&gt; using Crankshaft]
...
</code></p>

<p>Have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bulk Document Lookups]]></title>
    <link href="http://jsteemann.github.io/blog/2015/05/07/bulk-document-lookups/"/>
    <updated>2015-05-07T17:48:21+02:00</updated>
    <id>http://jsteemann.github.io/blog/2015/05/07/bulk-document-lookups</id>
    <content type="html"><![CDATA[<p>ArangoDB 2.6 comes with a specialized API for bulk document lookups.</p>

<p>The new API allows fetching multiple documents from the server using a single
request, making bulk document retrieval more efficient than when using
one request per document to fetch.</p>

<!-- more -->


<p>The straight-forward implementation of a client application that needs to
fetch several documents from an ArangoDB server looks like this:</p>

<p>```js fetching multiple documents from the server one by one
// list of document keys
var keys = [ &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;, &hellip;];</p>

<p>// sequentially fetch all documents from the server
var results = [ ];
for (var i = 0; i &lt; keys.length; ++i) {
  results.push(db.test.document(keys[i]));
}
// now all documents are contained in variable &lsquo;results&rsquo;
```</p>

<p>This works fine but causes excessive HTTP communication between the client
application and the server when many documents need to be fetched. In fact,
the above code will issue as many HTTP requests as there are documents to fetch.</p>

<p>From the performance point of view, it would be much better to reduce the
number of HTTP requests, and retrieve multiple documents from the server in
one go, using a single request.</p>

<p>This is where the new document lookup function comes into play. Provided the
documents keys are known, all the client application needs to do is to call the
collection&rsquo;s <code>lookupByKeys</code> method:</p>

<p>```js bulk method: fetching multiple documents at once
// list of document keys
var keys = [ &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;, &hellip;];</p>

<p>var results = db.test.lookupByKeys(keys);
// now all documents are contained in variable &lsquo;results&rsquo;
```</p>

<p>Following is a comparison of the execution times for the two different methds.
All test runs were conducted in the same ArangoDB 2.6 instance. The tests were
run from the ArangoShell. The ArangoShell and the ArangoDB server were located on
the same physical host.</p>

<p>```plain comparing single document requests and bulk requests</p>

<h2>Number of keys     Single documents        Bulk</h2>

<pre><code>     1,000               0.24 s      0.04 s
    10,000               1.23 s      0.31 s
   100,000              10.89 s      2.13 s
</code></pre>

<p>```</p>

<p>As can be seen, the bulk method can provide a substantial speedup in case lots
of documents need to be fetched by their keys at once. The actual speedups might be
even higher when using a remote ArangoDB server instead of a localhost connection.</p>

<p>In 2.6 there is currently an ArangoShell implementation for bulk document lookups.
Other drivers will follow.</p>

<p>Additionally, the server-side REST API method for bulk document lookups can be
invoked directly via HTTP as follows:</p>

<p><code>plain invoking bulk document lookups via HTTP
curl                                                  \
  -X PUT                                              \
  http://127.0.0.1:8529/_api/simple/lookup-by-keys    \
  --data '{"collection":"test","keys":["foo","bar","baz"]}'
</code></p>

<p>Restrictions: the bulk document API works only with document keys, not document ids.
Additionally, it works on a single collection at a time and cannot be leveraged to fetch
documents from multiple collections. Still, a client application can group document keys
by collection beforehand and send one bulk request per involved collection. Finally,
trying to fetch a document using a non-existing key will not produce an error with the
bulk API. Using the one-by-one method, trying to fetch a non-existing document will throw
an exception.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using ES6 Features in ArangoDB]]></title>
    <link href="http://jsteemann.github.io/blog/2014/12/19/using-es6-features-in-arangodb/"/>
    <updated>2014-12-19T19:12:06+01:00</updated>
    <id>http://jsteemann.github.io/blog/2014/12/19/using-es6-features-in-arangodb</id>
    <content type="html"><![CDATA[<p>ArangoDB 2.4 will be shipped with an <em>updated version of V8</em>.</p>

<p>The V8 version included in 2.4 will be 3.29.59. This version will replace the
almost two year old 3.16.14. A lot of things happened in V8 since then, and a lot
of ES6 features have been added to it.</p>

<p><strong>ES6 is not finalized yet</strong>, and support for it is a <a href="http://kangax.github.io/compat-table/es6/">work in progress on all
platforms</a>.</p>

<p>ES6 provides many cool features that can make JavaScript developer&rsquo;s life easier.
In this blog post, I&rsquo;ll summarize a few ES6 features that are available in
ArangoDB, either for scripting purposes in the ArangoShell, or in your server-side
Foxx actions inside the database.</p>

<p>I don&rsquo;t want to put you off until Doomsday. ArangoDB 2.4 should be released next
week. Time to play with some ES6 features!</p>

<!-- more -->


<h1>Summary for the impatient</h1>

<p>The following ES6 features are available in ArangoDB 2.4 by default:</p>

<ul>
<li>iterators</li>
<li>the <code>of</code> operator</li>
<li>symbols</li>
<li>predefined collections types (Map, Set etc.)</li>
<li>typed arrays</li>
</ul>


<p>Many other ES6 features are disabled by default, but can be made available by
starting arangod or arangosh with the appropriate options:</p>

<ul>
<li>arrow functions</li>
<li>proxies</li>
<li>generators</li>
<li>String, Array, and Number enhancements</li>
<li>constants</li>
<li>enhanced object and numeric literals</li>
</ul>


<p>To activate all these ES6 features, start arangod or arangosh with the following
options:</p>

<pre><code>arangosh --javascript.v8-options="--harmony --harmony_generators"
</code></pre>

<h1>Activating ES6 features</h1>

<p>Work on ES6, also dubbed <em>Harmony</em> or <em>ES.next</em>, is still in progress. At the time
of this writing, the ES6 specification was still in draft status.</p>

<p>Therefore no platform has implemented all ES6 features yet. And because ES6 is
still a moving target, the already implemented features should still be considered
experimental.</p>

<p>This is true for all environments that implement ES6 features. For example, Firefox
and other browsers contain lots of experimental ES6 features already, providing a
notice that these might change in future versions.</p>

<p>V8 is no exception here. It has turned most ES6 features off by default, but it
provides several command-line options to turn them on explicitly.</p>

<p>The V8 version used for ArangoDB 2.4 provides the following ES6-related switches:</p>

<ul>
<li><code>--harmony_scoping</code> (enable harmony block scoping)</li>
<li><code>--harmony_modules</code> (enable harmony modules (implies block scoping))</li>
<li><code>--harmony_proxies</code> (enable harmony proxies)</li>
<li><code>--harmony_generators</code> (enable harmony generators)</li>
<li><code>--harmony_numeric_literals</code> (enable harmony numeric literals (0o77, 0b11))</li>
<li><code>--harmony_strings</code> (enable harmony string)</li>
<li><code>--harmony_arrays</code> (enable harmony arrays)</li>
<li><code>--harmony_arrow_functions</code> (enable harmony arrow functions)</li>
<li><code>--harmony_classes</code> (enable harmony classes)</li>
<li><code>--harmony_object_literals</code> (enable harmony object literal extensions)</li>
<li><code>--harmony</code> (enable all harmony features (except proxies))</li>
</ul>


<p>These switches are all off by default. To turn on features for either arangod
or arangosh, start it with the V8 option(s) wrapped into the ArangoDB option
<code>--javascript.v8-options</code>, e.g.:</p>

<pre><code>arangosh --javascript.v8-options="--harmony_proxies --harmony_generators --harmony_array"
</code></pre>

<p>On a side note: node.js is also using V8. Turning on ES6 features in node.js almost
works the same way. Just omit the surrounding <code>--javascript.v8-options="..."</code>:</p>

<pre><code>node --harmony_proxies --harmony_generators --harmony_array
</code></pre>

<p>Note that the V8 options can only be set for the entire process (i.e. arangosh, arangod
or node.js), and not just for a specific script or application. In reality this shouldn&rsquo;t be
too problematic as the vast majority of ES6 features is downwards-compatible to ES5.1.</p>

<h1>ES6 features by example</h1>

<p>Following I have listed a few select ES6 features that are usable in ArangoDB 2.4,
in no particular order. I have omitted a few ES6 features that aren&rsquo;t supported in bundled
V8 version, and also omitted <em>classes</em> and <em>modules</em> due to lack of time.</p>

<h2>Arrow functions</h2>

<p>ES6 provides an optional arrow function syntax. The arrow function syntax is a shorthand for
writing a full-blown function declaration. Here&rsquo;s an example:</p>

<p>```js a simple arrow function
/<em> defines function pow </em>/
var pow = (value => value * value);</p>

<p>/<em> calls pow </em>/
pow(15);  /<em> 225 </em>/
```</p>

<p>Arrow functions can also take multiple parameters. The syntax then becomes:
```js arrow function with multiple parameters
/<em> defines function sum </em>/
var sum = (a, b) => a + b;</p>

<p>/<em> calls sum </em>/
sum(3, 7);  /<em> 10 </em>/
```</p>

<p>So far we have only seen arrow functions with simple expressions, but arrow function bodies
can also be more complex and can contain multiple statements:
```js more complex arrow functions
var translations = {
  &ldquo;en&rdquo; : &ldquo;English&rdquo;,
  &ldquo;fr&rdquo; : &ldquo;French&rdquo;,
  &ldquo;de&rdquo; : &ldquo;German&rdquo;
};</p>

<p>/<em> using multiple statements </em>/
[&ldquo;en&rdquo;, &ldquo;fr&rdquo;, &ldquo;xx&rdquo;].map(value => {
  if (translations.hasOwnProperty(value)) {</p>

<pre><code>return translations[value];
</code></pre>

<p>  }
  return &ldquo;unknown!&rdquo;;
});
```</p>

<p>Arrow functions are turned off by default. To enable them in arangod or arangosh, start them
with the option <code>--javascript.v8-options="--harmony_arrow_functions"</code>.</p>

<h2>Maps and sets</h2>

<p>ES6 maps provide a specialized alternative to regular objects in case a <em>lookup-by-key</em>
functionality is required.</p>

<p>When no maps are available, storing keys mapped to objects is normally done using a plain
object. With ES6, the same use case can be handled with using a <strong>Map</strong> object:
```js using an ES6 Map object
var m = new Map();</p>

<p>/<em> set 5M keys </em>/
for (var i = 0; i &lt; 5000000; ++i) {
  m.set(&ldquo;test&rdquo; + i, i);
}
```</p>

<p>ES6 maps can be more efficient than plain objects in some cases. For the above case of
storing 5M entries, an ES6 map is about twice as fast as a plain object on my laptop.
Though there might be cases we are plain objects are still faster.</p>

<p>There&rsquo;s more to ES6 Maps than just efficiency:</p>

<ul>
<li>ES6 maps provide a member <code>size</code> which keeps track of the number of objects in the map.
This is hard to achieve with a plain object.</li>
<li>Objects can only have string keys, whereas map keys can have different key types.</li>
<li>They don&rsquo;t inherit keys from the prototype, so there is no <code>hasOwnProperty</code> hassle with Maps.</li>
</ul>


<p>ES6 also comes with a specialized <strong>Set</strong> object. The Set object is a good alternative to
plain JavaScript objects when the use case is to track unique values. Using a Set is more
intuitive, potentially more efficient and may require even less memory than when implementing
the same functionality with a plain JavaScript object:</p>

<p>```js using an ES6 Set object
var s = new Set();</p>

<p>/<em> set 5M values </em>/
for (var i = 0; i &lt; 5000000; ++i) {
  s.add(&ldquo;test&rdquo; + i);
}
```</p>

<p>Maps and sets are enabled by default in arangod and arangosh. No special configuration is needed
to use them in your code.</p>

<h2>Proxy objects</h2>

<p>Proxy objects can be used to intercept object property accesses at runtime. This can be used
for meta-programming in many real-world situations, e.g.:</p>

<ul>
<li>preventing, auditing and logging property accesses</li>
<li>calculated / derived properties</li>
<li>adding a compatibility layer on top of an object</li>
</ul>


<p>Here&rsquo;s an example that logs property accesses on the proxied object:
```js using a Proxy object
var proxy = Proxy.create({
  get: function (obj, name) {</p>

<pre><code>console.log("read-accessing property '%s'", name);
</code></pre>

<p>  },
  set: function (obj, name) {</p>

<pre><code>console.log("write-accessing property '%s'", name);
</code></pre>

<p>  }
});</p>

<p>proxy.foo = &ldquo;bar&rdquo;;   /<em> write-accessing property &lsquo;foo&rsquo; </em>/
proxy.foo;           /<em> read-accessing property &lsquo;foo&rsquo; </em>/
```</p>

<p>Proxy objects are not available by default. To enable them in arangod or arangosh, start them
with the option <code>--javascript.v8-options="--harmony_proxies"</code>.</p>

<h2>Iterators and generators</h2>

<p>ES6 provides generators and iterators. They can be used individually or in combination.</p>

<p>Let&rsquo;s start with a simple example of a generator that will generate only two values:
```js a simple generator that generates two values
function* generate () {
  yield 23;
  yield 42;
}</p>

<p>var generator = generate();
console.log(generator.next());  /<em> { &ldquo;value&rdquo; : 23, &ldquo;done&rdquo; : false } </em>/
console.log(generator.next());  /<em> { &ldquo;value&rdquo; : 42, &ldquo;done&rdquo; : false } </em>/
console.log(generator.next());  /<em> { &ldquo;value&rdquo; : undefined, &ldquo;done&rdquo; : true } </em>/
<code>``
As can be seen above, the value yielded by the generator function will be returned
wrapped into an object with a</code>value<code>and a</code>done` attribute automatically.</p>

<p>The general pattern to consume all values from a generator function is to call
its <code>next()</code> method until its <code>done</code> value is <code>true</code>:
```js consuming all values from a generator function
var generator = generate();</p>

<p>while (true) {
  value = generator.next();
  if (value.done) {</p>

<pre><code>break;
</code></pre>

<p>  }
  console.log(value.value);
}
```</p>

<p>An alternative to that is to use an iterator (note the new <code>of</code> operator):
```js consuming all values from a generator function
var generator = generate();</p>

<p>for (var value of generator) {
  console.log(value);
}
```</p>

<p>Generator functions produce their values lazily. Therefore it is possible
and not inefficent to write generators that produce never-ending sequences.
Though one must be careful to abort iterating over the generator values
at some point if the sequence does not terminate:
```js a generator producing an endless sequence
function* generate () {
  var i = 0;
  while (true) {</p>

<pre><code>yield ++i;
</code></pre>

<p>  }
}</p>

<p>var generator = generate();</p>

<p>/<em> note: this will not terminate </em>/
for (var value of generator) {
  console.log(value);
}
```</p>

<p>We have now seen two uses of iterators as part of the previous examples.
As demoed, generator function values can be iterated with the <code>of</code> operator
without any further ado. Apart from generators, a few other built-in types
also provide ready-to-use iterators. The most prominent are <code>String</code> and <code>Array</code>:
```js iterating over the characters of a string
var text = &ldquo;this is a test string&rdquo;;</p>

<p>for (var value of text) {
  console.log(value);
}
```
The above example will iterate all the individual characters of the string.</p>

<p>The following example iterates the values of an Array:
```js iterating over the values of an array
var values = [ &ldquo;this&rdquo;, &ldquo;is&rdquo;, &ldquo;a&rdquo;, &ldquo;test&rdquo; ];</p>

<p>for (var value of values) {
  console.log(value);
}
<code>``
This will produce</code>&ldquo;this&rdquo;<code>,</code>&ldquo;is&rdquo;<code>,</code>&ldquo;a&rdquo;<code>,</code>&ldquo;test&rdquo;<code>. This is normally what is
desired when iterating over the values of an Array. Compare this to the</code>in<code>
operator which would produce</code>0<code>,</code>1<code>,</code>2<code>and</code>3` instead.</p>

<p>Map and Set objects also implement iterators:
```js iterating over the contents of a Map
var m = new Map();</p>

<p>m.set(&ldquo;Sweden&rdquo;, &ldquo;Europe&rdquo;);
m.set(&ldquo;China&rdquo;, &ldquo;Asia&rdquo;);
m.set(&ldquo;Bolivia&rdquo;, &ldquo;South America&rdquo;);
m.set(&ldquo;Australia&rdquo;, &ldquo;Australia&rdquo;);
m.set(&ldquo;South Africa&rdquo;, &ldquo;Africa&rdquo;);</p>

<p>for (var value of m) {
  console.log(value);
}
```</p>

<p>Note that Maps also provide dedicated iterators for just their keys or
their values:
```js iterating over keys and values of a Map
for (var country of m.keys()) {
  console.log(country);
}</p>

<p>for (var continent of m.values()) {
  console.log(continent);
}
```</p>

<p>Rolling an iterator for your own object is also possible by implementing the method
<code>Symbol.iterator</code> for it:
```js creating an iterator for an object
function Sentence (text) {
  this.text = text;
}</p>

<p>/<em> create the actual iterator method </em>/
/<em> note that the iterator is a generator function here </em>/
Sentence.prototype[Symbol.iterator] = function*() {
  var regex = /\S+/g;
  var text = this.text;
  var match;
  while (match = regex.exec(text)) {</p>

<pre><code>yield match[0]; 
</code></pre>

<p>  }
};</p>

<p>var sentence = new Sentence(&ldquo;The quick brown fox jumped over the lazy dog&rdquo;);
/<em> invoke the iterator </em>/
for (var word of sentence) {
  console.log(word);
}
```</p>

<p>Generators and iterators are not available by default. To enable them in arangod
or arangosh, start them with the option <code>--javascript.v8-options="--harmony_generators"</code>.</p>

<h2>String enhancements</h2>

<p>ES6 provides the following convenience string functions:</p>

<ul>
<li>string.startsWith(what)</li>
<li>string.endsWith(what)</li>
<li>string.includes(what)</li>
<li>string.repeat(count)</li>
<li>string.normalize(method)</li>
<li>string.codePointAt(position)</li>
<li>String.fromCodePoint(codePoint)</li>
</ul>


<p>These functions are mostly self-explaining, so I won&rsquo;t explain them in more
detail here. Apart from that, these functions are turned off by default.
To enable them in arangod or arangosh, start them with the option
<code>--javascript.v8-options="--harmony_strings"</code>.</p>

<h2>Array enhancements</h2>

<p>ES6 provides the following enhancements for the <code>Array</code> object:</p>

<ul>
<li>array.find(function)</li>
<li>array.findIndex(function)</li>
<li>array.keys()</li>
<li>array.values()</li>
<li>Array.observe(what, function)</li>
</ul>


<p>Here are a few examples demoing these functions:
```js Array enhancements
var values = [ 1, 2, 9, 23, 42 ];</p>

<p>/<em> returns the first Array element for which the function returns true </em>/
values.find(function (value) {
  return value === 23;
});</p>

<p>/<em> returns the first Array index for which the function returns true </em>/
values.findIndex(function (value) {
  return value === 23;
});</p>

<p>/<em> iterate over the keys of the Array </em>/
for (var key of values.keys()) {
  console.log(key);
}</p>

<p>/<em> iterate over the values of the Array </em>/
for (var key of values.values()) {
  console.log(key);
}</p>

<p>/<em> observe all changes to an Array </em>/
Array.observe(values, function (changes) {
  console.log(changes);
});</p>

<p>/<em> trigger a change to the observed Array </em>/
values.push(117);
```</p>

<p>The Array enhancements are turned off by default. To enable them in arangod or
arangosh, start them with the option <code>--javascript.v8-options="--harmony_arrays"</code>.</p>

<h2>Number enhancements</h2>

<p>The <code>Number</code> object is extended with the following ES6 functions:</p>

<ul>
<li>Number.isInteger(value)</li>
<li>Number.isSafeInteger(value)</li>
</ul>


<p>There are also <code>Number.MIN_SAFE_INTEGER</code> and <code>Number.MAX_SAFE_INTEGER</code> so applications
can programmatically check whether a numeric value can still be stored in the range of
-2<sup>53</sup> to +2<sup>53</sup> without potential precision loss.</p>

<h2>Constants</h2>

<p>The <code>const</code> keyword can be used to define a read-only constant. The constant must be
initialized and a variable with the same name should not be redeclared in the same scope.</p>

<p>Here is an example of using <code>const</code>:
<code>js using const to create a read-only variable
function calculate (value) {
  const magicPrime = 23;
  return magicPrime ^ value;
}
</code></p>

<p>In non-strict mode, <code>const</code> variables behave non-intuitively. Re-assigning a value
to a variable declared <code>const</code> does not throw an exception, but the assignment will
not be carried out either. Instead, the assignment will silently fail and the <code>const</code>
variable will keep its original value:</p>

<p><code>js re-assigning a value to a const variable
function mystery () {
  const life = 42;
  life = 23;        /* does not change value and does not throw! */
  return life;      /* will return 42 */
}
</code></p>

<p><code>js re-assigning a value to a const variable, using strict mode
function mystery () {
  "use strict";
  const life = 42;
  life = 23;        /* will throw SyntaxError "assignment to constant variable" */
}
</code></p>

<p>The <code>const</code> keyword is disabled by default. To enable it in arangod or arangosh,
start them with the option <code>--javascript.v8-options="--harmony_scoping"</code>.</p>

<h2>Enhanced object literals</h2>

<p>ES6 provides a shorthand for defining methods in object literals.</p>

<p>The following example creates a normal method named <code>save</code> in <code>myObject</code>:</p>

<p>```js shorthand method declaration
var myObject = {
  type: &ldquo;myType&rdquo;,
  save () {</p>

<pre><code>console.log("save");
</code></pre>

<p>  }
};
```</p>

<p>Interestingly, the object literals seem to work for method declarations only.
I did not get them to work for non-method object properties, though ES6 allows that.
It seems that this is not implemented in V8 yet.</p>

<p>Enhanced object literals are turned off by default. To enable them in arangod
or arangosh, start them with the option <code>--javascript.v8-options="--harmony_object_literals"</code>.</p>

<h2>Enhanced numeric literals</h2>

<p>For the ones that love working with binary- or octal-encoded numbers, ES6 has
support for this too:
<code>js numeric literals
var life = 0b101010;          /* binary, 42 in decimal */
var filePermissions = 0o777;  /* octal, 511 in decimal */
</code></p>

<p>Enhanced numeric literals are turned off by default. To enable them in arangod
or arangosh, start them with the option <code>--javascript.v8-options="--harmony_numeric_literals"</code>.</p>

<h2>Symbols</h2>

<p>ES6 also provides a Symbol type. Symbols are created using the global <code>Symbol()</code> function.
Each time this function is called, a new Symbol object will be created.
A Symbol can be given an optional name, but this name cannot be used to identify the
Symbol later. However, Symbols can be compared by identity.</p>

<p>What one normally wants is to use the same Symbol from different program parts. In this
case, a Symbol should not be created with the <code>Symbol()</code> function, but with <code>Symbol.for()</code>.
This will register the Symbol in a global symbol table if it is not there yet, and return
the Symbol if already created:</p>

<p>```js using named Symbols
var typeAttribute = Symbol.for(&ldquo;type&rdquo;);
var carType = Symbol.for(&ldquo;car&rdquo;);
var trainType = Symbol.for(&ldquo;train&rdquo;);</p>

<p>var object1 = { };
object1[typeAttribute] = carType;</p>

<p>var object2 = { };
object2[typeAttribute] = trainType;</p>

<p>/<em> check if the objects have the same type </em>/
object1[typeAttribute] === object2[typeAttribute];  /<em> false </em>/
object1[typeAttribute] === carType;                 /<em> true </em>/
object2[typeAttribute] === carType;                 /<em> false </em>/
object2[typeAttribute] === trainType;               /<em> true </em>/
```</p>

<p>Symbol object properties are not enumerated by default, so they can be used to implement
&ldquo;hidden&rdquo; or internal properties.</p>

<p>Symbols can be used by default in arangod and arangosh. No special configuration is required.</p>

<h2>TypedArrays</h2>

<p>TypedArrays are Arrays whose members all have the same type and size. They are more
specialized (read: limited but efficient) alternatives to the all-purpose <code>Array</code> type.</p>

<p>TypedArrays look and feel a bit like C arrays, and they are often used as an Array-like
view into binary data (for which JavaScript has no native support).</p>

<p>A TypedArray is created (and all of its memory is allocated) by invoking the appropriate
TypedArray constructor:</p>

<ul>
<li>Int8Array</li>
<li>Uint8Array</li>
<li>Uint8ClampedArray</li>
<li>Int16Array</li>
<li>Uint16Array</li>
<li>Int32Array</li>
<li>Uint32Array</li>
<li>Float32Array</li>
<li>Float64Array</li>
</ul>


<p>```js using an Array of unsigned 8 bit integers
var data = new Uint8Array(2);
data[0] = 0b00010101;  /<em> 23 </em>/
data[1] = 0b00101010;  /<em> 42 </em>/</p>

<p>console.log(data[0]);  /<em> 23 </em>/
console.log(data.length * data.BYTES_PER_ELEMENT); /<em> 2 bytes </em>/
```</p>

<p>```js using an Array of 64 bit floating point values
var data = new Float64Array(2);
data[0] = 23.23;</p>

<p>console.log(data[0]);  /<em> 23.23 </em>/
console.log(data[1]);  /<em> 0.0 </em>/
console.log(data.length * data.BYTES_PER_ELEMENT); /<em> 16 bytes </em>/
```</p>

<p>TypedArrays can be used in arangod and arangosh by default. No special
configuration is required to activate them.</p>

<h2>Unsupported ES6 features</h2>

<p>As mentioned before, V8 does not yet support every proposed ES6 feature.
For example, the following ES6 features are currently missing:</p>

<ul>
<li>template strings</li>
<li>function default parameters</li>
<li>rest function parameter</li>
<li>spread operator</li>
<li>destructuring</li>
<li>array comprehension</li>
<li><code>let</code></li>
</ul>


<p>I strongly hope these features will make it into the final version of ES6 and will be
implemented by the V8 team in future versions of V8.</p>

<p>Apart from that, a lot of nice ES6 features are there already and can be used
in ArangoDB applications.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Where Operations Are Executed]]></title>
    <link href="http://jsteemann.github.io/blog/2014/08/30/understanding-where-operations-are-executed/"/>
    <updated>2014-08-30T22:38:42+02:00</updated>
    <id>http://jsteemann.github.io/blog/2014/08/30/understanding-where-operations-are-executed</id>
    <content type="html"><![CDATA[<p>I recently had to deal with some data processing operation that took
about 20 minutes to complete. When looking into this, I found that the
easiest and most beneficial change to the whole setup was to make the
operation a <em>server-side</em> operation instead of executing it <em>client-side</em>.</p>

<p>This change reduced the operation&rsquo;s total execution time to a few seconds.</p>

<!-- more -->


<p>I can&rsquo;t show the original processing task here, so I&rsquo;ll start with a
contrived example. Imagine the following <em>for</em> loop inserting 100K documents
into a collection named <code>test</code>:
<code>js inserting 100k documents
for (i = 0; i &lt; 100000; ++i) {
  db.test.save({ value: i });
}
</code>
Now we only need a client application to execute the operation. As I don&rsquo;t
have a presentable client application right now, I will use the ArangoShell as
my client application.</p>

<h2>What&rsquo;s in a for loop?</h2>

<p>Running the above <em>for</em> loop inside the ArangoShell will lead to the loop being
executed inside the <em>arangosh</em> process.</p>

<p>In order to save a document in the collection, arangosh (our client) must make a
call to the ArangoDB server. This means issuing an HTTP POST request
to the server&rsquo;s REST API at <code>/_api/document/?collection=test</code>.
The server process will receive this request, insert the document, and
respond with an HTTP status code 201 or 202 to our client.
The client will then continue the loop until all documents have been inserted.</p>

<p>Now it&rsquo;s easy to see that the simple 3-line loop will issue 100,000 HTTP requests
in total. This means lots of data being pushed through the network stack(s).
It is pretty easy to imagine that this will come at a cost.</p>

<p>If we instead execute the above loop directly inside the ArangoDB server, we
can get rid of all the network overhead. The server has no need to send HTTP
calls to itself. It can simply execute the 100K inserts and is then done.
We therefore assume the loop to run somewhat faster when executed server-side.</p>

<p>A quick test on a crap laptop produced the following execution times for running
the loops:</p>

<ul>
<li>server-side execution (arangod): 1.34 seconds</li>
<li>client-side execution (arangosh): 17.32 seconds</li>
</ul>


<p><strong>Ouch</strong>. It looks like the client-server request-response overhead matters.</p>

<p>The following sections deal with how to get rid of some or even all the
client-server ping pong.</p>

<h2>Graph traversals</h2>

<p>The above <em>for</em> loop example was contrived, but imagine running
a client-side graph traversal instead. In fact, the original problem mentioned
in the introduction has been a graph traversal.</p>

<p>The problem of a graph traversal is that is often iterative and highly
dynamic. Decisions are made during the traversal as nodes are encountered,
leading to dynamic inclusion or exclusion etc. This means that it makes sense to
process nodes and edges only when needed, at the point when they are visited.</p>

<p>Even if the client can employ some sort of caching for already visited
nodes, the client still needs to ask the server about each visited
node&rsquo;s connections at least once. Otherwise it could not follow them.</p>

<p>This normally means lots of requests and responses. Compare this to the
<em>single</em> request-response alternative in which a client kicks off a server-side
traversal, and finally receives the overal result once it is assembled.</p>

<p><strong>Conclusion</strong>: traversals on anything but very small graphs should be run server-side.
A server-side action (see below) is a good way to do this. Please note that
running a server-side traversal does not mean giving up flexibility and
control flow functionality. Server-side traversals remain highly configurable
through custom JavaScript functions that allow implementation of user-defined
business logic.</p>

<h2>AQL queries</h2>

<p>We won&rsquo;t have your application send a series of 100,000 individual
insert statements to the relational database of our choice. We already
know from the past that this is going to be rather slow, so we have
learned to avoid this. In the relational context, we rather use SQL queries
that create or modify many rows in one go, e.g. an <code>INSERT INTO ... SELECT ...</code>,
bulk inserts etc.</p>

<p>ArangoDB is no different. In general, you should try to avoid issuing lots
of individual queries to the database from a client application. Instead and if
the queries look alike, try converting multiple individual operations into a
single AQL query. This will already save a lot of network overhead.</p>

<p>AQL provides multi-document operations to insert, update, and remove data. An
overview is given <a href="http://docs.arangodb.org/Aql/DataModification.html">here</a>.</p>

<p>The above 100K inserts from the contrived example can easily be transformed
into this single AQL query:
<code>
FOR i IN 1..100000 INSERT { value: i } INTO test
</code></p>

<h2>Bulk imports</h2>

<p>For importing larger amounts of documents from files, there is the specialized
<a href="http://docs.arangodb.org/Arangoimp/README.html">arangoimp</a> import tool. It can
load data from JSON and CSV files into ArangoDB. The tool is shipped with
ArangoDB.</p>

<p>ArangoDB also provides a REST API for <a href="http://docs.arangodb.org/HttpBulkImports/README.html">bulk imports</a>
of documents.</p>

<h2>Joins</h2>

<p>A special note about <em>joins</em>: the fact that several NoSQL databases do not
provide join functionality has driven some people to emulate join functionality
on the client-side, in their applications.</p>

<p>This can be a recipe for disaster: client-side join implementation might lead
to horrendous amounts of queries that might need to be sent to the database for
fetching all the records. More than that, if data are queried individually,
the overall result may lack consistency. By the way, the same is true for
fetching referenced or linked documents.</p>

<p>ArangoDB provides join functionality via AQL queries. Additionally, AQL queries
can be used to fetch other documents with the original documents. Note that
ArangoDB has no way of defining references or links between documents, but
still AQL allows combining arbitrary documents in one query.</p>

<p>In almost all cases it make more sense to use an AQL query that performs
joins or reference-fetching server-side and close to the data than having to
deal with that on the application-side of things.</p>

<p>AQL joins are described <a href="http://docs.arangodb.org/AqlExamples/Join.html">here</a>.</p>

<h2>Server-side actions</h2>

<p>With <em>stored procedures</em>, relational databases provide another way for an
application to trigger the execution of a large amount of queries. Stored
procedures are executed server-side, too, so they allow avoiding a lot of
request-response ping pong between the application and the database, at least
for defined tasks. Additionally, stored procedures provide control flow
functionality, which can also be handy when operations depend on each other.</p>

<p>Coming back to ArangoDB: complex data-processing tasks that need to execute
multiple operations or need control flow functionality might benefit if
converted from multiple application-side operations into a single server-side
action.</p>

<p>Server-side actions run inside the ArangoDB server, closer to the data, and
can be much faster than a series of client-side operations.
A server-side action is called with just one HTTP request from the application,
so it may lead to saving lots of request-response cycles and reduction in
network overhead. Apart from that, server-side actions in ArangoDB can employ
transactions and provide the necessary control over isolation and atomicity
when executing a series of operations.</p>

<p>Business logic and control flow functionality can be integrated
easily because server-side actions in ArangoDB are JavaScript functions,
with all of the language&rsquo;s programming features being available.</p>

<p>But there&rsquo;s even more to it: a single server-side operation can be written
to put together its result in a format most convenient for the client
application. This can also lead to better encapsulation, because all an
application needs to know about a server-side action is its API or contract.
Any internals of the action can be hidden from the client application. Overall,
this supports a service-oriented approach.</p>

<p>To learn more about how to write server-side actions, please have a look
at ArangoDB&rsquo;s <a href="http://docs.arangodb.org/Foxx/README.html">Foxx</a>. It is all
about making server-side actions available via REST APIs.</p>
]]></content>
  </entry>
  
</feed>
